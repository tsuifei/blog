<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS 的 小技巧</title>
      <link href="/tsuifei.github.io/CSS_Tips/"/>
      <url>/tsuifei.github.io/CSS_Tips/</url>
      
        <content type="html"><![CDATA[<p>有時候在設計網站的時候，如果多一些輕量小技巧，就可以增加網站的質感，此篇記錄有可能會用到的一些 CSS 小技巧，來幫忙點綴網頁。</p><h2 id="網頁上文字選取時的反白顏色"><a href="#網頁上文字選取時的反白顏色" class="headerlink" title="網頁上文字選取時的反白顏色"></a>網頁上文字選取時的反白顏色</h2><p>一般網頁上的文字在選取時預設是淺藍色的底與白色的字，我們可已透過 CSS 的選擇器來設定和網站風格相搭配的顏色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::selection</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#76b852</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-moz-selection</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#76b852</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">::selection</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">::-moz-selection</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以此記錄，將來會陸續增加…。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RWD 圖片選擇的 Html 屬性</title>
      <link href="/tsuifei.github.io/RWD_Images-adaptatives/"/>
      <url>/tsuifei.github.io/RWD_Images-adaptatives/</url>
      
        <content type="html"><![CDATA[<p>RWD (responsive web design）中文為「響應式設計」簡單來說就是網頁會依照我們使用的載具(電腦、平版、手機)的螢幕大小與螢幕的像素密度不同，而顯示指定的圖片圖像。<br>而針對 RWD 中的網頁圖像的處理，我們稱為是響應式圖片(responsive image)，使用 JS 或是 CSS 都可以操控要顯示的圖像，但使用具有語義性的 HTML 方法與屬性，可以讓瀏覽器原生就支援這個功能。</p><p>如果只是把一張圖片以<code>&lt;img&gt;</code>包起來，如<code>&lt;img src=&quot;paris.png&quot;&gt;</code>，那麼在手機或是在桌上型電腦上瀏覽時都會出現「同一張」<code>paris.png</code>的圖片。使用同意張圖片，卻要給不同的載據顯示，可能造成的問題會是在大螢幕瀏覽這張圖時解析度可能不夠、在手機上瀏覽這張圖時，會因為過大而顯示很慢。這時依照載具的條件不同，來載入相對應的圖像就變得很重要。</p><p>HTML 提供了多個方法與屬性，讓我們可以在「響應式設計」上更彈性，以下是幾個常用的屬性。</p><a id="more"></a><h3 id="srcset-螢幕的像素密度選擇"><a href="#srcset-螢幕的像素密度選擇" class="headerlink" title="srcset 螢幕的像素密度選擇"></a><code>srcset</code> 螢幕的像素密度選擇</h3><p>一般的桌上型顯示器是單倍像素密度，而手機的螢幕往往是多倍像素密度，就是多個像素合成為一個像素，也稱為 Retina 。有時圖像在桌上型顯示器看很清晰，但從手機上看會有點模糊，因為大部分的手機螢幕像素的像素密度有可能是 1.5 或是 2 倍，所以在手機上圖像像素被擴充放大了。</p><p>這時如果我們希望依不同的載具來顯示不同大小的圖片與像素密度，<code>&lt;img&gt;</code>的屬性<code>srcset</code> 就可派上用場。<code>srcset</code>屬性用來指定多張圖像，來適應不同像素密度的螢幕，語法為<code>&lt;img srcset=&quot;[圖像][像素密度描述符]&quot;&gt;</code>，不同的尺寸以逗點隔開。圖像後面的像素密度描述符，格式是像素密度倍數 + 字母 <code>x</code>。1x 表示單倍像素密度，可以省略。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">"paris-320w.png,</span></span></span><br><span class="line"><span class="tag"><span class="string">             paris-480w.png 1.5x,</span></span></span><br><span class="line"><span class="tag"><span class="string">             paris-640w.png 2x"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">"paris-640w.png"</span> &gt;</span></span><br></pre></td></tr></table></figure><p>瀏覽器會依照當前螢幕設備的像素密度，去選擇載入的圖像，如果<code>srcset</code>屬性都沒有符合的條件，那麼就會去載入<code>src</code>的圖像。</p><h3 id="srcset-sizes-屬性-圖像大小的選擇"><a href="#srcset-sizes-屬性-圖像大小的選擇" class="headerlink" title="srcset + sizes 屬性 = 圖像大小的選擇"></a><code>srcset</code> + <code>sizes</code> 屬性 = 圖像大小的選擇</h3><p>想要依照螢幕的「像素密度」和「螢幕大小」顯示載入的圖像，就必須加上<code>sizes</code> 屬性，使用時必須在不同的圖像後加上「寬度描述符」。<br>「寬度描述符」其實就是圖像原始的寬度，再加上代表寬度的<code>w</code>。所以在<code>paris-320.png 320w</code>裡的<code>320w</code>表示這張圖像的原始寬度為 320。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">"paris-320.png 320w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             paris-480.png 480w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             paris-640.png 640w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             paris-1280.png 1280w"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">sizes</span>=<span class="string">"(max-width: 440px) 100vw,</span></span></span><br><span class="line"><span class="tag"><span class="string">             (max-width: 800px) 33vw,</span></span></span><br><span class="line"><span class="tag"><span class="string">             320px"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">"paris-1280w.png"</span> &gt;</span></span><br></pre></td></tr></table></figure><p><code>sizes</code>屬性會列出不同載據的圖像顯示寬度，語法：<code>sizes=&quot;([媒體查詢表達式]) [圖像的顯示寬度]</code>。<br><code>(max-width: 440px) 100vw</code>＝ 如果載具的螢幕最大寬度是(不超過) 440px，圖像顯示寬度就為 100％。<br><code>(max-width: 800px) 33vw</code>＝ 載具螢幕寬度 441~800px，圖像顯示寬度就為 33％。<br>最後一個<code>320px</code>即是載具螢幕寬度為 800px 以上，圖像顯示寬度就為 320px。</p><h3 id="小測試"><a href="#小測試" class="headerlink" title="小測試"></a>小測試</h3><p>問題 <strong>- What is the meaning of the “800px” value below?</strong><br>“800px” 在下列程式碼中代表什麼？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">srcset</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://i.imgur.com/wdpNu4W.jpeg 480w,</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://i.imgur.com/mY3Cz2I.jpg  800w</span></span></span><br><span class="line"><span class="tag"><span class="string">  "</span></span></span><br><span class="line"><span class="tag">  <span class="attr">sizes</span>=<span class="string">"(max-width:600px) 480px, 800px"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://i.imgur.com/JiVQRCg.jpg"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>答案：如果螢幕大小最大是 600px 就把圖片寬度以 480px 顯示，600px 以上就顯示 800px。答對了嗎？</p><p>後記：每一個語言和技術都會有新的語法和擴充功能，雖然 HTML 和 CSS 用了這麼多年，但每次碰到這些問題，都還是覺得自己所學不足，所以特地記錄一下。</p><p>參考：</p><ul><li><a href="https://developer.mozilla.org/fr/docs/Apprendre/HTML/Comment/Ajouter_des_images_adaptatives_%C3%A0_une_page_web" target="_blank" rel="noopener">Images adaptatives - Apprendre le développement web | MDN</a></li><li><a href="http://www.ruanyifeng.com/blog/2019/06/responsive-images.html" target="_blank" rel="noopener">響應式圖像教程 - 阮一峰的網絡日誌</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> RWD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> RWD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML figure 標籤的用法</title>
      <link href="/tsuifei.github.io/Html_figure/"/>
      <url>/tsuifei.github.io/Html_figure/</url>
      
        <content type="html"><![CDATA[<p>通常我們在處理許多條列式的內容時，常會使用 List 的方式去排列文字或圖形，但如果每一個 <code>&lt;li&gt;</code> 的內容太過繁瑣，就會顯的有些零散，尤其是含有圖片或是影片的內容列表，會包含圖片的標題、圖說、作者介紹等等零碎資訊，這個時候 <code>&lt;figure&gt;</code> 便可派上用場。</p><p><code>&lt;figure&gt;</code> 是 HTML5 增加的語義化標籤。figure 的英文解釋可以是數字、人物、圖形甚至輪廓，但在 HTML 裡，個人偏向解釋為「含有資訊的區塊輪廓」，就像我們在美術館觀賞一幅畫作，旁邊總會有一個解說牌，說明畫作的標題、作者、尺寸、年份與媒材，我們可以把畫作和解說牌當成是一組的 figure，而解說牌的標題當成是 <code>&lt;figure&gt;</code> 的子元素 <code>&lt;figcaption&gt;</code> ，這也很像我們在閱讀雜誌時，圖片總是會有圖說，來更詳細的解說圖片。</p><a id="more"></a><p>也因此 <code>&lt;figure&gt;</code> 和 <code>&lt;figcaption&gt;</code> 這兩個語義化元素，常常會一起使用。</p><h2 id="lt-figure-gt-的使用時機"><a href="#lt-figure-gt-的使用時機" class="headerlink" title="&lt;figure&gt;的使用時機"></a><code>&lt;figure&gt;</code>的使用時機</h2><p><code>&lt;figure&gt;</code> 最常使用在圖片上，但是並不是只有「一張」圖片，事實上我們可以同時放很多張圖片在 <code>&lt;figure&gt;</code> 裡面，如果這些圖片是有關連的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"cat01.jpg"</span> <span class="attr">alt</span>=<span class="string">"A white cat"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"cat02.jpg"</span> <span class="attr">alt</span>=<span class="string">"A black cat"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"cat03.jpg"</span> <span class="attr">alt</span>=<span class="string">"A old cat"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之前提過， <code>&lt;figure&gt;</code> 不只可以用在圖片區塊，也可使用在例如影片、程式碼、音檔、表格、圖表或是廣告上。 <code>&lt;figure&gt;</code> 也可以使用嵌套的方式，在 <code>&lt;figure&gt;</code> 裡嵌套另一組 <code>&lt;figure&gt;</code> ，例如有好幾張圖片有各自的圖說，這些 <code>&lt;figure&gt;</code> 可以再用一組 <code>&lt;figure&gt;</code> 包起來。</p><h2 id="lt-figcaption-gt-的使用方式"><a href="#lt-figcaption-gt-的使用方式" class="headerlink" title="&lt;figcaption&gt; 的使用方式"></a><code>&lt;figcaption&gt;</code> 的使用方式</h2><p><code>&lt;figcaption&gt;</code> 元素是代表 <code>&lt;figure&gt;</code> 元素裡的一個標題或者是其相關的解釋。雖然常是和 <code>&lt;figure&gt;</code> 一起搭配使用，但並不表示 <code>&lt;figure&gt;</code> 一定需要 <code>&lt;figcaption&gt;</code> ，需要注意的是，如果使用 <code>&lt;figcaption&gt;</code> 最好放在 <code>&lt;figure&gt;</code> 的第一個會最後一個元素，方便查找。</p><p>我們也可以在 <code>&lt;figcaption&gt;</code> 的元素裡，放入多個元素，標題或段落都可以。</p><h2 id="使用-lt-figure-gt-和-lt-figcaption-gt-的好處"><a href="#使用-lt-figure-gt-和-lt-figcaption-gt-的好處" class="headerlink" title="使用&lt;figure&gt;和&lt;figcaption&gt;的好處"></a>使用<code>&lt;figure&gt;</code>和<code>&lt;figcaption&gt;</code>的好處</h2><p>使用這兩個 HTML 語義化標籤的好處，是可以讓搜尋引擎的機器人，在讀取時知道<code>&lt;figure&gt;</code> 的內容性質，友善搜尋引擎的速度與標記，自然會對優化 SEO 有幫助。</p><h3 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/figure" target="_blank" rel="noopener"><code>&lt;figure&gt;</code>：可附標題內容元素 | MDN</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/figcaption" target="_blank" rel="noopener"><code>&lt;figcaption&gt;</code> | MDN</a></p><p><a href="https://www.sitepoint.com/how-to-use-aria-effectively-with-html5/" target="_blank" rel="noopener">How to Use ARIA Effectively with HTML5</a><br><a href="https://lepture.com/zh/2015/fe-aria-label" target="_blank" rel="noopener">前端的基礎修養：aria-label</a></p><p>aria-label 是一個 HTML attribute，用來告訴「讀螢幕內容軟體」某個元素是什麼，提升 Web Accessibility。<br>例如一個關閉按鈕「×」，視覺上看來都能理解，但是「讀螢幕內容軟體」並不能正確讀出，這時就可以用 aria-label 來提示，讓「讀螢幕內容軟體」可以知道這個區塊的內容，例如：</p><p><button aria-label="關閉">&times;</button></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">aria-label</span>=<span class="string">"關閉"</span>&gt;</span><span class="symbol">&amp;times;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>網站速度優化分析工具：SEO Lighthouse</title>
      <link href="/tsuifei.github.io/DevTool_Chrome_Lighthouse/"/>
      <url>/tsuifei.github.io/DevTool_Chrome_Lighthouse/</url>
      
        <content type="html"><![CDATA[<p>網站載入的速度不只會影響使用者體驗，也會影響 SEO，因為網頁載入的速度也是 Google 搜尋排序的一個指標，進而影響排名，也因為載入速度同時影響網站的排名和使用者體驗，所以更不該忽視。</p><p>但怎麼知道我們的網站效能？這個有一個小小燈塔圖形的 Chrome 外掛工具，就是一個超好用的網站速度優化工具：SEO Lighthouse 它可以幫上我們！</p><h2 id="Lighthouse-是什麼？有什麼用途？"><a href="#Lighthouse-是什麼？有什麼用途？" class="headerlink" title="Lighthouse 是什麼？有什麼用途？"></a>Lighthouse 是什麼？有什麼用途？</h2><p>燈塔工具(Lighthouse)是 Google Chrome 的擴充應用程式，是一個網路開發者(Web developer)的工具，主要功能是針對網頁的性能做詳細與全面的分析(包含網頁載入速度)，並產生分析報告，報告上會有詳細的分析結果與如何優化改善的建議，以及每個頁面的各種數據和指標的表現。</p><a id="more"></a><h2 id="要如何使用-Lighthouse？"><a href="#要如何使用-Lighthouse？" class="headerlink" title="要如何使用 Lighthouse？"></a>要如何使用 Lighthouse？</h2><p>開啟瀏覽器 Chrome 的「更多工具」裡的「擴充功能」直接輸入關鍵字<a href="https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk?hl=zh-TW" target="_blank" rel="noopener">Lighthouse</a>搜尋進行安裝。</p><p>安裝完畢後在瀏覽器的又上方會有一個小燈塔的圖示，接著在我們想要測試的網頁上點擊這個小燈塔，並按下「Generate Report」小燈塔就會開始進行網頁分析，並於分析完後，直接跳出一個分析的報告視窗。</p><h2 id="如何看懂分析報告？"><a href="#如何看懂分析報告？" class="headerlink" title="如何看懂分析報告？"></a>如何看懂分析報告？</h2><p>我們可以透過這份報告得知，網頁的哪一個部分最耗效能，並以五個綜合評分指標來說明網頁在不同層面的表現，接著再一一細部顯示各個指標的細部說明，並提供方向與建議來改善網頁。<br><img src="/images/lighthouse_01.png" alt="lighthouse 01"><br><img src="/images/lighthouse_02.png" alt="lighthouse 02"><br>如果不善英文，也可以使用 Google 翻譯，就能輕易理解 Lighthouse 的解說。</p><p>下圖的效能部分，可以得知網站詳細各頁的載入速度，再一一去修正與優化。<br><img src="/images/lighthouse_Performance.png" alt="Performance"></p><p>Opportunities 所列舉的是可以幫助更快地加載頁面的方法，例如刪除未使用的 CSS 或 JavaScript 可以節省多少時間等等。</p><p><img src="/images/lighthouse_Opportunities.png" alt="Opportunities"></p><p>而 Diagnostics 的區塊則是有關應用程序性能的更多訊息，例如如何確保網頁在 Webfont 載入期間保持可見度等等，按開每個訊息右邊的小三角形，可以找到一些解決的方式。<br><img src="/images/lighthouse_Diagnostics.png" alt="Diagnostics"></p><h2 id="有優化就一定會效能提升"><a href="#有優化就一定會效能提升" class="headerlink" title="有優化就一定會效能提升"></a>有優化就一定會效能提升</h2><p>在查閱完 Lighthouse 給我們的訊息與可修正的方向後，就可以一一去對每個細部做修正與優化，但建議從排行越前面，也就是越影響效能的部分著手，這樣在優化後也能比較明顯的體驗到提升效能優化前和後的差異。</p><p>Lighthouse 也很貼心的將這些分析功能，合併整合到 google 的網頁測速工具(Page Speed Insights)當中，只要透過<a href="http://www.ec-world.com/blog/google-pagespeed-insights-lighthouse" target="_blank" rel="noopener">Google PageSpeed Insights</a>工具就可以直接輸入網址，且以中文的界面顯示測試報告的結果分析，非常方便。（應該早點說的 XD）</p><p>當然，也建議看看官方更詳盡的說明<a href="https://developers.google.com/web/tools/lighthouse/?hl=zh-tw" target="_blank" rel="noopener">使用 Lighthouse 審查網絡應用</a>，在這些工具給的建議一一修正優化之後，相信在 SEO 的排名上也會有不少的提升。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>網路工具越來越強大，平時常會忽略這些工具真的是件可惜的事，且還佛心的免費讓我們用，現能有一部份是圖片沒有優化所造成，不妨先研究圖片優化的方式，就會發現更多好用的優化圖片工具，能善用這些工具，真的是可以大大提升開發的品質啊！尤其網頁載入速度會影響 SEO，所以不得不正視網頁效能這部分啊！</p><p>其他網站性能優化工具：<br><a href="https://webpagetest.org/" target="_blank" rel="noopener">WebPageTest - Website Performance and Optimization Test</a></p>]]></content>
      
      
      <categories>
          
          <category> DevTool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
            <tag> Extension </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON 的方法和型別</title>
      <link href="/tsuifei.github.io/debug_note_02/"/>
      <url>/tsuifei.github.io/debug_note_02/</url>
      
        <content type="html"><![CDATA[<p>有時候在學習的時候，最怕就是遇到一個問題越解越混淆的狀況，原本只是一個小小的問題，卻越發不可收拾，努力了幾個小時決定上網問人，好險都能在好心人的幫助下，釐清自己的一些觀念。</p><p>今天試著接 API ，對於教學範例的 API 都是結構較於單純的 JSON ，自己上網找到想接的巴黎開放數據，資料結構卻很複雜，包了好幾層物件、陣列，在一一抓出來後在迴圈的使用上又有點生疏，然後在休息的時候找到一個範例，剛好講到處理 JSON 的一些方法，然後就照著範例丟到瀏覽器的開發工具，然後無限迴圈就開始了。</p><p>先來釐清幾件事：<br>MDN <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank" rel="noopener">JSON.parse()</a> 方法把會把一個 JSON <strong>字串</strong>轉換成 JavaScript 的<strong>數值</strong>或是<strong>物件</strong>。</p><p>MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener">JSON.stringify()</a> 方法將一個 JavaScript <strong>物件</strong>或<strong>值</strong>轉換為 JSON <strong>字串</strong></p><a id="more"></a><p>MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON" target="_blank" rel="noopener">JSON</a> 是一種語法，用來序列化物件、陣列、數值、字串、布林值和 null 。它基於 JavaScript 語法，但與之不同：JavaScript 不是 JSON，JSON 也不是 JavaScript。</p><p>JSON 物件包含兩個方法: 用於解析 JavaScript Object Notation (JSON) 的 parse() 方法，以及將物件/值轉換為 JSON 字串的 stringify() 方法。除了這兩個方法, JSON 這個物件本身並沒有其他作用，也不能被呼叫或者作為建構式函式呼叫。</p><p>讓我混亂的範例是這樣的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> json = &#123;</span><br><span class="line">  name: <span class="string">'jason'</span>,</span><br><span class="line">  age: <span class="string">'23'</span>,</span><br><span class="line">  phone: <span class="string">'0922'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排除 age</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">JSON</span>.parse(json, (key, value) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">'age'</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;name: "jason", phone: "0922"&#125;</span></span><br></pre></td></tr></table></figure><p>丟到 Chrome 的開發工具的 console 發現出錯 <code>Uncaught SyntaxError: Unexpected token o in JSON at position 1</code>，想說有可能是哪個地方出問題，想把它修好，然後一直修不好。</p><p>去 MDN 看 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank" rel="noopener">JSON.parse()</a>的範例，但範例是直接把整個物件外加上括號<code>&#39;</code>丟進去<code>JSON.parse()</code>裡面，但我想要的是把物件加上括號放進去一個變數，在當成參數帶進去<code>JSON.parse()</code>裡面卻一直出錯，一樣是<code>Uncaught SyntaxError</code>的錯誤，然後到六角的 slack 去問，很多人熱心解答，也發現我傻傻分不清楚<code>JSON.parse()</code>裡參數應該是字串，而在過程中，又發現 Chrome 的 console，會自己改樣子，像是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> json = &#123;</span><br><span class="line">  name: <span class="string">'jason'</span>,</span><br><span class="line">  age: <span class="string">'23'</span>,</span><br><span class="line">  phone: <span class="string">'0922'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(json);</span><br><span class="line"><span class="comment">// &#123;name: "jason", age: "23", phone: "0922"&#125;</span></span><br></pre></td></tr></table></figure><p>原本<code>key</code>有的字串型態，都不見了！又一個自己不懂的問題。怎麼解釋這個現象？</p><h2 id="JS-強制轉型有兩種"><a href="#JS-強制轉型有兩種" class="headerlink" title="JS 強制轉型有兩種"></a>JS 強制轉型有兩種</h2><p>在 slack 上有人建議推薦看這篇 Summer 的<a href="https://cythilya.github.io/2018/10/15/coercion/" target="_blank" rel="noopener">你懂 JavaScript 嗎？#8 強制轉型（Coercion）</a>嚇出一身汗，越發現自己處於「不知道自己不知道」的狀態下。原來 JavaScript 裡的強制轉型，明的暗的轉型都應該無時無刻的注意，否則這些強制轉型帶來的副作用，應該會讓人鬱悶。</p><p>接著在 slack 上也有人一一跟我詳解，是我把字串和物件搞混了，的確，我沒注意到許多方法的參數示意定要某種型別這件事，還有人寫了範例給我，真的超感動的。</p><p>繼續在 Chrome console 測試，結果越試越亂，越覺得是不是太久沒關機，電腦開始秀逗了（其實是我自己！）。決定關機出去走一走，回來煮完吃完飯後繼續，很想搞懂真正的「JSON」格式應該什麼樣子，為什麼要使用 JSON 這兩種方法，找著找著就找到這篇 MIS 腳印的<a href="https://www.footmark.info/programming-language/javascript/json-format-and-javascript/" target="_blank" rel="noopener">JSON 格式與 JavaScript 解析教學範例</a>看到這段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宣告字串須使用 '' 括起來，否則就會變成是 JavaScript object 了</span></span><br><span class="line"><span class="comment">// 如在不同行必須在每行結尾處加上 \，否則會產生 SyntaxError</span></span><br><span class="line"><span class="keyword">var</span> jsonString =</span><br><span class="line">  <span class="string">'&#123; \</span></span><br><span class="line"><span class="string">    "number": "1020501", \</span></span><br><span class="line"><span class="string">    "name": "小傑", \</span></span><br><span class="line"><span class="string">    "age": 32, \</span></span><br><span class="line"><span class="string">    "sex": "M", \</span></span><br><span class="line"><span class="string">&#125;'</span>;</span><br></pre></td></tr></table></figure><p>然後照著範例的作法，在每行尾部加上<code>\</code>與在物件前後使用<code>&#39;</code>將物件框起來，就可以將此變數 <code>jsonString</code>帶進<code>JSON.parse()</code>裡當參數了。但為什麼？如果有一大堆資料需要轉，這樣一行行加不會很費時嗎？</p><p>記得之前也看了一篇 MIS 腳印的文章，或許是寫作風格的不同，他的文筆比較容易理解，解釋的也很清楚。這部分的達其實也是自己需要加強的，也許自己在釐清問題和發問時，都不夠詳細，才會有時問的時候覺得沒有描述的很清楚，回應自然無法真的解決我想解決的問題。</p><p>我想寫程式就是這樣吧，既然是要和機器溝通就得講的清清楚楚，一點模糊地帶都不允許，這或許也是磨練自己一向太感性或隨意的問題，把寫程式當設計來做可行不通，切記。</p><p>常常想起大哥的話，在得知我要轉職前，身為資深工程師的他說：「妳確定你要走這條路？妳到底知不知道解 BUG 的辛苦？」我當時確實是不知道啊！但是當我可以在 42 熬了一個月都為了不懂的事情而在那裡試著理解，就想自己對此應該是有耐性和熱忱的，或許需要的時間很多，或許自己投入的時機也不太對，但是自己是個容易忘記辛苦的人，所以，就讓我繼續下去吧。</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 函式的方法與 This</title>
      <link href="/tsuifei.github.io/JS_Basic_function_method/"/>
      <url>/tsuifei.github.io/JS_Basic_function_method/</url>
      
        <content type="html"><![CDATA[<p>函式也是一個物件，所以也會有它的方法，需要以物件的方式調用，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是fun函式'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun.call(); <span class="comment">// 我是fun函式</span></span><br><span class="line">fun.apply(); <span class="comment">// 我是fun函式</span></span><br></pre></td></tr></table></figure><p>剛開始接觸程式時，常常把<code>fun</code>和<code>fun()</code>搞混，其實這兩者是不同的，<code>fun</code>指的是這個函式本身，函式在 Javascript 裡是物件型別，所以<code>fun</code>也是一個物件。<code>fun()</code>指的是呼叫這個函式。</p><p>使用函式的方法<code>call()</code>和<code>apply()</code>都必須以物件的方式調用，且會執行此函式。當我們使用<code>fun()</code>,<code>fun.call()</code>和<code>fun.apply()</code>時，都會執行<code>fun()</code>此函式，但有什麼不同？<br>使用函式的<code>call()</code>和<code>apply()</code>方法可修改 this，因為可以將一個物件，指定為這兩個方法的第一個參數，如果沒使用這兩個方法，單純執行函式，函式的 this 是 window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">fun(); <span class="comment">// Window</span></span><br><span class="line">fun.call(obj); <span class="comment">// &#123;&#125;</span></span><br><span class="line">fun.apply(obj); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a = '</span> + a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b = '</span> + b);</span><br><span class="line">  <span class="comment">//alert(this);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'obj'</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call()和 apply()"></a>call()和 apply()</h3><ul><li>這兩個方法都是函式物件的方法，需要通過函式物件來調用</li><li>當對函式調用 call()和 apply()都會調用函式執行</li><li>在調用 call()和 apply()可以將一個物件指定為第一個參數<br><strong>此時這個物件將會成為函式執行時的 this</strong></li><li>call()方法可以將實參在物件之後依次傳遞</li><li>apply()方法需要將實參封裝到一個陣列中統一傳遞</li></ul><h3 id="this-的情況："><a href="#this-的情況：" class="headerlink" title="this 的情況："></a>this 的情況：</h3><ul><li>以函式形式呼叫時，this 永遠都是 window</li><li>以方法的形式調用時，this 是調用方法的物件</li><li>以構造函式的形式調用時，this 是新創建的那個物件</li><li>使用 call 和 apply 調用時，this 是指定的那個物件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fun.call(obj,2,3);</span></span><br><span class="line">fun.apply(obj, [<span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">'obj2'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*fun.apply();</span></span><br><span class="line"><span class="comment">fun.call();</span></span><br><span class="line"><span class="comment">fun();*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fun.call(obj);</span></span><br><span class="line"><span class="comment">//fun.apply(obj);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fun();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obj.sayName.apply(obj2);</span></span><br></pre></td></tr></table></figure><p>這題的重點是 <code>add()</code>出現兩次！雖然程式是一行行跑的，但是因為 JS 的 hoisting 特色，所以所有的函式都會優先被提升，而在提升的規則裡，如果有重複的變數或函式，後面的會覆蓋前面的，所以第一個<code>add()</code>基本上是無效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>,</span><br><span class="line"><span class="keyword">var</span> y = (z = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n = n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y = add(x); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n = n + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">z = add(x); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><code>arguments</code>所依據的是實參而不是形參。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 JSON 物件陣列上增加一對鍵與唯一值</title>
      <link href="/tsuifei.github.io/Add_unique_generated_Identifier_on_array_of_json_objec/"/>
      <url>/tsuifei.github.io/Add_unique_generated_Identifier_on_array_of_json_objec/</url>
      
        <content type="html"><![CDATA[<p>最近在學習的時候，常常遇到問題卻不知怎麼問人的窘狀，也發現自己常常把問題「複雜化」，而這個後果就是會讓自己如鬼打牆般轉不出來。程式設計最吸引我的一部份就是程式的結果或許一樣，但這中間的運作卻是多樣的，每次在看到其他人解出題來時，總會對於解題的方式感到讚嘆，自己不知要練多久才有那個程度。而也在透過「試著讀懂」其他人的程式碼的過程中又學習到許多。</p><p>在使用 Vue.js 的<code>v-for</code>時，需要使用<code>v-bind:key=&#39;uniqueValue&#39;</code>去綁定一個唯一值，這樣可以讓 Vue 知道哪一個元素有變動而單一渲染，但是有時拿到的資料並沒有「唯一」值，如果使用陣列的索引值(index)當 key 的唯一值，會有因陣列的變動而索引值被改動的問題。如果後端給的資料沒有在每一筆資料裡給各唯一值，那麼只好自己生成，但是怎麼在 JSON 格式裡為每一個陣列裡的物間自動加上一對「鍵與唯一值」例如:</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> amis = [&#123; <span class="attr">name</span>: <span class="string">'Tracy'</span>, <span class="attr">age</span>: <span class="number">42</span> &#125;];</span><br><span class="line"><span class="comment">// 希望變成有 鍵與唯一值</span></span><br><span class="line"><span class="keyword">const</span> amis = [&#123; <span class="attr">name</span>: <span class="string">'Tracy'</span>, <span class="attr">age</span>: <span class="number">42</span>, <span class="attr">id</span>: 唯一值 &#125;];</span><br></pre></td></tr></table></figure><p>想一想在程式中，有哪些東西會產生連續的數字？除了 索引值(index)之外，還有跑 for 回圈常用的計算陣列長度的<code>arr.length</code>與代表陣列每一個元素的變數<code>i</code>，利用迴圈和陣列長度就可以產生連續的唯一值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; list.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125; <span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><p>理解了上面的原理就可以思考，如果是 JSON 的資料型態如何利用 for 迴圈來增加一對鍵與唯一值？<br>自己把事情複雜化的把型別轉來轉去，使用了<code>JSON.stringify()</code>又使用了<code>JSON.parse()</code>都不行，因為自己連基本的「資料結構都還沒真的弄懂」，所以才會複雜化，來看了這篇<a href="https://www.footmark.info/programming-language/javascript/json-format-and-javascript/#fm-chapter-5-1" target="_blank" rel="noopener">JSON 格式與 JavaScript 解析教學範例</a>，再一個個去試，才對這些方法比較瞭解也算是收穫。</p><p>後來又去 <a href="https://stackoverflow.com/questions/52935903/add-unique-generated-identifier-on-array-of-json-object" target="_blank" rel="noopener">stackoverflow</a> 繞了一圈，才看到可以這樣解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原資料</span></span><br><span class="line"><span class="keyword">const</span> amis = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'tracy'</span>, <span class="attr">age</span>: <span class="number">42</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'phi'</span>, <span class="attr">age</span>: <span class="number">58</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'ayde'</span>, <span class="attr">age</span>: <span class="number">38</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; amis.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(amis[i]);</span><br><span class="line">  <span class="built_in">console</span>.log(i + <span class="number">1</span>);</span><br><span class="line">  amis[i].uniqueId = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(amis);</span><br><span class="line"><span class="comment">// 結果</span></span><br><span class="line"><span class="comment">// amis = [</span></span><br><span class="line"><span class="comment">//   &#123; name: 'tracy', age: 42, uniqueId: 1 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: 'phi', age: 58, uniqueId: 2 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: 'ayde', age: 38, uniqueId: 3 &#125;,</span></span><br><span class="line"><span class="comment">// ];</span></span><br></pre></td></tr></table></figure><p>試著寫成一支函式，以後就可以用了，但還是不夠完善，想試著把唯一 key 也提出來做參數，卻一直失敗。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addUniKeyValue</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i].uniqueId = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>決定請教朋友給的提示，他沒幾分鐘就寫出來了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addUniKeyValue</span>(<span class="params">arr, id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="function">(<span class="params">el, i</span>) =&gt;</span> &#123;</span><br><span class="line">    el[id] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> amis3 = addUniKeyValue(amis, <span class="string">'ok'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(amis);</span><br></pre></td></tr></table></figure><p>接著就是自己真的要好好理解這段碼了。</p><p>發現這樣得到的 陣列是淺拷貝，所以就來試了一下深拷貝，拿出去年學的，有點耗效能的 JSON.parse and JSON.stringify (Deep copy)深拷貝，也就是把陣列轉成字串，在字串轉成物件。<br>JSON.stringify：將物件轉字串。 / JSON.parse：將字串轉物件。<br>就可以利用這個函式將一份沒有鍵與唯一值的資料，轉成有鍵與唯一值的 JSON 資料，而且還可以指定鍵值名稱。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷貝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addDeep</span>(<span class="params">arr, id</span>) </span>&#123;</span><br><span class="line">  arr.map(<span class="function">(<span class="params">el, i</span>) =&gt;</span> &#123;</span><br><span class="line">    el[id] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> amis3 = addDeep(amis, <span class="string">'ok'</span>);</span><br></pre></td></tr></table></figure><p>…待續…</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> JavaScript </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript Date &amp; Times 時間處理</title>
      <link href="/tsuifei.github.io/JS_Date_objects/"/>
      <url>/tsuifei.github.io/JS_Date_objects/</url>
      
        <content type="html"><![CDATA[<h3 id="new-Date-物件的時間處理"><a href="#new-Date-物件的時間處理" class="headerlink" title="new Date() 物件的時間處理"></a>new Date() 物件的時間處理</h3><p>我們常需要在網頁上處理或顯示時間，例如文章是何時編輯的、購物時間或是在觀察程式碼的效能時也會需要時間的處理，JavaScript 是如何處理日期和時間的呢？</p><p>JavaScript 包含了一個處理時間的物件：<code>new Date()</code>，透過這個構造式裡的方法或參數，我們可以精準的計算任何形式的時間。在這個物件的時間計算單位為毫秒（1000 毫秒為一秒），所以處理時需要另外除以 1000 才能得到我們熟悉的秒數。</p><p><code>Date()</code>物件是基於世界標準時間（UTC） 1970 年 1 月 1 日開始的毫秒數值來儲存時間的。要得到當下的時間是很容易的，這個當下時間來自於我們本身使用的電腦當下的時間，而電腦的時間，有可能是透過網路而得到電腦當下所在時區的時間。但如果我們想要「計算時間」就必須透過一些方式與計算，例如想要計算不是在同時需的時間，或是要對某個時間點做倒數。</p><a id="more"></a><p>我們先來看看<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Date" target="_blank" rel="noopener">Date - JavaScript | MDN</a> 怎麼解釋。</p><h2 id="構造函式-new-Date"><a href="#構造函式-new-Date" class="headerlink" title="構造函式 new Date()"></a>構造函式 new Date()</h2><p>因為是構造式，創建時間的物件須先以<code>new Date()</code>創建，所回傳的值是一個封裝好的物件，以這個構造式被執行的時間點為標記傳回時間。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(date); <span class="comment">// Sat Aug 08 2020 15:36:59 GMT+0200 (中歐夏令時間)</span></span><br></pre></td></tr></table></figure><p>以上的範例傳回<code>// Sat Aug 08 2020 15:36:59 GMT+0200 (中歐夏令時間)</code><br>如果我們沒有給<code>Date()</code>任何參數，回傳的會是依電腦系統的設定，產生當下時間的 Date 物件。</p><h2 id="以參數的方式取得時間"><a href="#以參數的方式取得時間" class="headerlink" title="以參數的方式取得時間"></a>以參數的方式取得時間</h2><p><code>Date()</code>可接受多種格式參數，回傳一個該參數對應的時間。</p><ul><li>參數為字串：如果想指定我們所需要的特定日期（月/日/年）時間(時：分：秒)，傳入一個表示時間的字串作為參數，回傳值則是我們指定的日期時間。</li><li>參數為毫秒：參數為時間零點開始計算的毫秒數，回傳從 1970/1/1 00:00:00 開始算起的時間點。</li><li>參數為多個整數值：參數為代表年、月、日、小時、分鐘、秒、毫秒，回傳對應的時間。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 參數為時間零點開始計算的毫秒數</span></span><br><span class="line"><span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">157821628600</span>);</span><br><span class="line"><span class="comment">// Wed Jan 01 1975 16:20:28 GMT+0100 (中歐標準時間)</span></span><br><span class="line"><span class="comment">// 從 1970/1/1 00:00:00 開始算起的時間點</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 參數為字串的時間日期</span></span><br><span class="line"><span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'08/08/2020'</span>);</span><br><span class="line"><span class="comment">// Sat Aug 08 2020 00:00:00 GMT+0200 (中歐夏令時間)</span></span><br><span class="line"><span class="keyword">let</span> date3 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'08/08/2020 12:42:24'</span>);</span><br><span class="line"><span class="comment">// Sat Aug 08 2020 12:42:24 GMT+0200 (中歐夏令時間)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 參數為多個整數值: 年、月、日、小時、分鐘、秒、毫秒</span></span><br><span class="line"><span class="keyword">let</span> date4 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2020</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// Tue Sep 08 2020 00:00:00 GMT+0200 (中歐夏令時間)</span></span><br></pre></td></tr></table></figure><p>只要是能被<code>Date.parse()</code>解析的字串，都可以當作是<code>Date()</code>的參數，所以不同的參數寫法都可以得到相同的時間。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020/5/8'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-8-8'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'05/8/2020'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-August-8'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'August 8, 2020'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'August, 8, 2020'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'8, August, 2020'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'8 August 2020'</span>);</span><br><span class="line"><span class="comment">// Sat Aug 08 2020 00:00:00 GMT+0200 (中歐夏令時間)</span></span><br></pre></td></tr></table></figure><h2 id="Date-以物件的方法取得時間計算"><a href="#Date-以物件的方法取得時間計算" class="headerlink" title="Date() 以物件的方法取得時間計算"></a>Date() 以物件的方法取得時間計算</h2><p><code>Date()</code>包含了許多的方法，透過呼叫這些方法，可以得到較為細節的時間，以下我們只介紹我們常用的方法。</p><h3 id="get-得到特定的時間，並回傳整數"><a href="#get-得到特定的時間，並回傳整數" class="headerlink" title="get*() 得到特定的時間，並回傳整數"></a>get*() 得到特定的時間，並回傳整數</h3><p>以 get 開頭的方法顧名思義是用來取得時間的，以字串為參數，直接指定時間，回傳的整數皆以 0 為起始，以星期來說，0 為週日、月份 0 為一月，以此類推。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'08/08/2020 12:42:24'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(date); <span class="comment">// Sat Aug 08 2020 12:42:24 GMT+0200 (中歐夏令時間)</span></span><br><span class="line"><span class="keyword">let</span> day = date.getDay(); <span class="comment">// 回傳數字 6 ，表示 08/08/2020 這天是週六</span></span><br></pre></td></tr></table></figure><p>以下為常用的<code>get*()</code>方法</p><ul><li>getTime()：回傳當下時間距離 1970 年 1 月 1 日 00:00:00 的毫秒數</li><li>getDate()：回傳當下時間對應每個月的幾號（從 1 開始）。</li><li>getDay()：回傳星期幾，星期日為 0，星期一為 1，以此類推。</li><li>getFullYear()：回傳四位的年份。</li><li>getMonth()：回傳月份（0 表示 1 月，11 表示 12 月）。</li><li>getHours()：回傳小時（0-23）。</li><li>getMilliseconds()：回傳毫秒（0-999）。</li><li>getMinutes()：回傳分鐘（0-59）。</li><li>getSeconds()：回傳秒（0-59）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> time = date.getTime();</span><br><span class="line"><span class="comment">// 回傳的是從1970年到至今的時間</span></span><br><span class="line"><span class="built_in">console</span>.log(time / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span> / <span class="number">365</span>);</span><br><span class="line"><span class="comment">// 得到的時間值除以毫秒單位/秒單位/分單位/時單位/日單位</span></span><br><span class="line"><span class="comment">// 50.63727990001903</span></span><br><span class="line"><span class="comment">// 從1970 到現在 08/08/2020 共經過了50.637年</span></span><br></pre></td></tr></table></figure><p>如果把戳印時間減去現在時間，原本應該是得到 0，卻回傳-3600000，是因為時區不同的原因，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> testDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1/1/1970 0:0:0'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(testDate);</span><br><span class="line"><span class="comment">// Thu Jan 01 1970 00:00:00 GMT+0100 (中歐標準時間)</span></span><br><span class="line"><span class="comment">// 現在時間</span></span><br><span class="line"><span class="keyword">let</span> nowTime = testDate.getTime();</span><br><span class="line"><span class="built_in">console</span>.log(nowTime); <span class="comment">// -3600000</span></span><br><span class="line"><span class="comment">// 和標準時間相差值</span></span><br><span class="line"><span class="keyword">let</span> differTime = nowTime / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span>;</span><br><span class="line"><span class="built_in">console</span>.log(differTime); <span class="comment">// -1 差一小時</span></span><br></pre></td></tr></table></figure><h3 id="now-回傳當下的時間戳印"><a href="#now-回傳當下的時間戳印" class="headerlink" title="now()回傳當下的時間戳印"></a>now()回傳當下的時間戳印</h3><p>可利用<code>now()</code>方法得到當下的時間，利用時間的戳印特性來測試程式碼的執行效能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="built_in">console</span>.log(start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// console.log(i);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> end = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="built_in">console</span>.log(end);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`執行了<span class="subst">$&#123;end - start&#125;</span>毫秒`</span>);</span><br></pre></td></tr></table></figure><p>取執行前和執行後的時間戳印相減，即可得執行時間</p><h3 id="set-設置時間的方法"><a href="#set-設置時間的方法" class="headerlink" title="set*() 設置時間的方法"></a>set*() 設置時間的方法</h3><p>以 set 為開頭的方法，主要以設定時間為主，<code>set*()</code>來設定當下的時間點，常用的有：</p><ul><li>setDate(date)：設置當前時間對應的每個月的幾號（1-31），返回改變後時間(毫秒)。</li><li>setFullYear(year)：設置四位數的年份。</li><li>setHours(hour)：設置小時（0-23）。</li><li>setMilliseconds()：設置毫秒（0-999）。</li><li>setMinutes(min)：設置分鐘（0-59）。</li><li>setMonth(month)：設置月份（0-11）。</li><li>setSeconds(sec)：設置秒（0-59）。</li><li>setTime(milliseconds)：設置毫秒時間。</li></ul><h3 id="Timer-設定定時的方法"><a href="#Timer-設定定時的方法" class="headerlink" title="Timer 設定定時的方法"></a>Timer 設定定時的方法</h3><p>使用定時的方法可以讓我們時做出不同的效果，另如定時器、倒數、重複時間循環。</p><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h4><p><code>setTimeout()</code>用來指定某個函數或某段 code 在多少毫秒之後執行。<br>此方法有兩個參數： <code>setTimeout(function|code, delay);</code><br><code>setTimeout(將要延遲執行的函式或 code, 延遲執行的毫秒數)</code>，如果省略第二個參數，則默認為 0(也就沒有延遲的意義並馬上執行)。</p><h4 id="clearTimeout"><a href="#clearTimeout" class="headerlink" title="clearTimeout()"></a>clearTimeout()</h4><p>取消｀ setTimeout()｀設的定時器。</p><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h4><p>和<code>setTimeout()</code>完全一致，差別在於<code>setInterval()</code>可以無限次的設置定時器的執行。<br>此方法有兩個參數：<code>setInterval(function|code, delay);</code>第一參數為執行的函式或程式、第二參數為延遲的毫秒數。</p><h4 id="clearInterval"><a href="#clearInterval" class="headerlink" title="clearInterval()"></a>clearInterval()</h4><p>取消<code>setInterval()</code>設的定時器。</p><h2 id="實作電子時鐘"><a href="#實作電子時鐘" class="headerlink" title="實作電子時鐘"></a>實作電子時鐘</h2>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS Axios API、D3js 顯示圖表</title>
      <link href="/tsuifei.github.io/JS_60_note30/"/>
      <url>/tsuifei.github.io/JS_60_note30/</url>
      
        <content type="html"><![CDATA[<h2 id="第三十關，第三十關-C3-js-圖表整合"><a href="#第三十關，第三十關-C3-js-圖表整合" class="headerlink" title="第三十關，第三十關 C3.js 圖表整合"></a>第三十關，第三十關 C3.js 圖表整合</h2><p>內容：以 Axios 讀取 API、使用 D3js 顯示視覺畫圖表。<br>方式：</p><h3 id="引進所需的函式庫"><a href="#引進所需的函式庫" class="headerlink" title="引進所需的函式庫"></a>引進所需的函式庫</h3><p>讀取 API 的 Axios<br>資料視覺畫的 D3js, C3js 以及 C3 所需的 CSS</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 載入 CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.18/c3.css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 載入 JavaScript --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/axios/0.19.2/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.18/c3.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接著是 html 的內容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>JavaScript 特訓班關卡進度<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"chart"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="定義所需變數"><a href="#定義所需變數" class="headerlink" title="定義所需變數"></a>定義所需變數</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = []; <span class="comment">//存放回傳資料用</span></span><br><span class="line"><span class="comment">// 宣告 columns 變數要放入完成率的資料。</span></span><br><span class="line"><span class="keyword">let</span> columns = [<span class="string">'完成率'</span>]; <span class="comment">//data 對應名稱與存放數據資料用</span></span><br><span class="line"><span class="comment">// 宣告 category 變數要放入參賽者姓名資料。</span></span><br><span class="line"><span class="keyword">let</span> category = [];</span><br><span class="line"><span class="keyword">let</span> url =</span><br><span class="line">  <span class="string">'https://raw.githubusercontent.com/hexschool/hexschoolNewbieJS/master/data.json'</span>;</span><br></pre></td></tr></table></figure><h3 id="讀取-API-資料"><a href="#讀取-API-資料" class="headerlink" title="讀取 API 資料"></a>讀取 API 資料</h3><p>使用 Axios 取出 API 的資料，並且以<code>then()</code> 和<code>catch()</code>觀察取出資料狀態。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取資料</span></span><br><span class="line">axios</span><br><span class="line">  .get(url)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    data = response.data;</span><br><span class="line">    <span class="comment">// console.log(data);</span></span><br><span class="line">    <span class="comment">// renderRecord();</span></span><br><span class="line">    sortData();</span><br><span class="line">    renderLoad(columns, category);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="資料處理"><a href="#資料處理" class="headerlink" title="資料處理"></a>資料處理</h3><p>排序、將符合條件的資料取出並存入指定陣列中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 資料排序函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先排序</span></span><br><span class="line">  data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="built_in">parseFloat</span>(b.process) - <span class="built_in">parseFloat</span>(a.process));</span><br><span class="line">  <span class="comment">// 將資料撈出並推進陣列</span></span><br><span class="line">  data.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.process !== <span class="string">'0%'</span>) &#123;</span><br><span class="line">      <span class="comment">// 只顯示有進度的</span></span><br><span class="line">      columns.push(<span class="built_in">parseInt</span>(item.process));</span><br><span class="line">      category.push(item.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// console.log(columns, category);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="資料圖形化並渲染畫面"><a href="#資料圖形化並渲染畫面" class="headerlink" title="資料圖形化並渲染畫面"></a>資料圖形化並渲染畫面</h3><p>使用 C3js 來渲染畫面，並細部設定資料呈現的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 資料圖形化＋渲染函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderLoad</span>(<span class="params">columns, category</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> chart = c3.generate(&#123;</span><br><span class="line">    bindto: <span class="string">'#chart'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      columns: [[...columns]], <span class="comment">//</span></span><br><span class="line">      axes: &#123;</span><br><span class="line">        <span class="comment">// 軸數</span></span><br><span class="line">        完成率: <span class="string">'y2'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//自訂圖表類型</span></span><br><span class="line">      type: <span class="string">'bar'</span>,</span><br><span class="line">      colors: &#123; 完成率: <span class="string">'#9ccc65'</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 控制圖表尺寸</span></span><br><span class="line">    size: &#123;</span><br><span class="line">      height: category.length * <span class="number">30</span>, <span class="comment">//調整圖表高度</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 控制軸線顯示</span></span><br><span class="line">    axis: &#123;</span><br><span class="line">      <span class="comment">// 軸</span></span><br><span class="line">      rotated: <span class="literal">true</span>, <span class="comment">// 轉橫向</span></span><br><span class="line">      <span class="comment">// X 軸</span></span><br><span class="line">      x: &#123;</span><br><span class="line">        type: <span class="string">'category'</span>, <span class="comment">// 左側 X 軸顯示</span></span><br><span class="line">        categories: category, <span class="comment">//參賽姓名資料</span></span><br><span class="line">        label: &#123; <span class="attr">text</span>: <span class="string">'X軸 參賽者姓名'</span>, <span class="attr">position</span>: <span class="string">'outer-center'</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//  Y 軸</span></span><br><span class="line">      y: &#123;</span><br><span class="line">        show: <span class="literal">true</span>, <span class="comment">//下方 Y 軸顯示</span></span><br><span class="line">        label: &#123; <span class="attr">text</span>: <span class="string">'Y軸 完成率'</span>, <span class="attr">position</span>: <span class="string">'outer-middle'</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      y2: &#123;</span><br><span class="line">        show: <span class="literal">true</span>, <span class="comment">//上方 Y 軸顯示</span></span><br><span class="line">        label: &#123;</span><br><span class="line">          text: <span class="string">'Y2軸 完成率完成率'</span>,</span><br><span class="line">          position: <span class="string">'outer-middle'</span>, <span class="comment">//名稱位置</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C3js-的使用方式"><a href="#C3js-的使用方式" class="headerlink" title="C3js 的使用方式"></a>C3js 的使用方式</h2><p>進行前先說明一下使用 C3js 的方式：<br>除了先引進必須的樣式表和函式庫外，C3js 需要先透過 C3 的<code>generate()</code>的函式來產生圖表，並透過此函式內的物件參數，來控制圖表。<br><a href="https://c3js.org/gettingstarted.html" target="_blank" rel="noopener">C3.js | D3-based reusable chart library</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> chart = c3.generate(&#123;</span><br><span class="line">  bindto: <span class="string">'#chart'</span>, <span class="comment">// 綁定 DOM</span></span><br><span class="line">  <span class="comment">//控制、處理與資料、數據相關部分</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    columns: [</span><br><span class="line">      <span class="comment">// 資料來源</span></span><br><span class="line">      [<span class="string">'資料1'</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>],</span><br><span class="line">      [<span class="string">'資料2'</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>],</span><br><span class="line">    ],</span><br><span class="line">    axes: &#123;</span><br><span class="line">      <span class="comment">// 軸數</span></span><br><span class="line"></span><br><span class="line">      完成率: <span class="string">'y2'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//自訂圖表類型</span></span><br><span class="line">    type: <span class="string">'bar'</span>,</span><br><span class="line">    <span class="comment">//圖表顏色</span></span><br><span class="line">    colors: &#123; 完成率: <span class="string">'#9ccc65'</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 控制尺寸</span></span><br><span class="line">  size: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 控制圖表的 X,Y軸說明</span></span><br><span class="line">  axis: &#123;</span><br><span class="line">    <span class="comment">// 軸</span></span><br><span class="line">    rotated: <span class="literal">true</span>, <span class="comment">// 轉橫向</span></span><br><span class="line">    <span class="comment">// X 軸</span></span><br><span class="line">    x: &#123;</span><br><span class="line">      type: <span class="string">'category'</span>, <span class="comment">// 左側 X 軸顯示</span></span><br><span class="line">      categories: category, <span class="comment">//參賽姓名資料</span></span><br><span class="line">      label: &#123; <span class="attr">text</span>: <span class="string">'參賽者姓名'</span>, <span class="attr">position</span>: <span class="string">'outer-center'</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//  Y 軸</span></span><br><span class="line">    y: &#123;</span><br><span class="line">      show: <span class="literal">true</span>, <span class="comment">//下方 Y 軸顯示</span></span><br><span class="line">      label: &#123; <span class="attr">text</span>: <span class="string">'完成率'</span>, <span class="attr">position</span>: <span class="string">'outer-middle'</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    y2: &#123;</span><br><span class="line">      show: <span class="literal">true</span>, <span class="comment">//上方 Y 軸顯示</span></span><br><span class="line">      label: &#123;</span><br><span class="line">        text: <span class="string">'完成率'</span>,</span><br><span class="line">        position: <span class="string">'outer-middle'</span>, <span class="comment">//名稱位置</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在這份作業裡，我們可以把整份 C3js 的控制成一個函式，藉由帶參數的方式，將可重複使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderLoad</span>(<span class="params">columns, category</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> chart = c3.generate(&#123;</span><br><span class="line">    bindto: <span class="string">'#chart'</span>, <span class="comment">// 綁定顯示位置 DOM</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      <span class="comment">// 圖表的資料來源</span></span><br><span class="line">      columns: [[...columns]], <span class="comment">// 要顯示的資料數據</span></span><br><span class="line">      axes: &#123;</span><br><span class="line">        <span class="comment">// 軸數</span></span><br><span class="line">        完成率: <span class="string">'y2'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//自訂義圖表類型</span></span><br><span class="line">      type: <span class="string">'bar'</span>,</span><br><span class="line">      colors: &#123; 完成率: <span class="string">'#9ccc65'</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 控制圖表尺寸</span></span><br><span class="line">    size: &#123;</span><br><span class="line">      height: category.length * <span class="number">30</span>, <span class="comment">//調整圖表高度</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 控制軸線顯示</span></span><br><span class="line">    axis: &#123;</span><br><span class="line">      <span class="comment">// 軸</span></span><br><span class="line">      rotated: <span class="literal">true</span>, <span class="comment">// 轉橫向</span></span><br><span class="line">      <span class="comment">// X 軸</span></span><br><span class="line">      x: &#123;</span><br><span class="line">        type: <span class="string">'category'</span>, <span class="comment">// 左側 X 軸顯示</span></span><br><span class="line">        categories: category, <span class="comment">//參賽姓名資料</span></span><br><span class="line">        label: &#123; <span class="attr">text</span>: <span class="string">'參賽者姓名'</span>, <span class="attr">position</span>: <span class="string">'outer-center'</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//  Y 軸</span></span><br><span class="line">      y: &#123;</span><br><span class="line">        show: <span class="literal">true</span>, <span class="comment">//下方 Y 軸顯示</span></span><br><span class="line">        label: &#123; <span class="attr">text</span>: <span class="string">'完成率'</span>, <span class="attr">position</span>: <span class="string">'outer-middle'</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      y2: &#123;</span><br><span class="line">        show: <span class="literal">true</span>, <span class="comment">//上方 Y 軸顯示</span></span><br><span class="line">        label: &#123;</span><br><span class="line">          text: <span class="string">'完成率'</span>,</span><br><span class="line">          position: <span class="string">'outer-middle'</span>, <span class="comment">//名稱位置</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 六角JS學徒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS Axios API、表單元素切換顯示資料</title>
      <link href="/tsuifei.github.io/JS_60_note29/"/>
      <url>/tsuifei.github.io/JS_60_note29/</url>
      
        <content type="html"><![CDATA[<p>學習路上跌跌撞撞、過程總是零散，生活中總是被瑣事切割成碎片，如何把碎片時間拾揀與拼湊成可專心學習的塊狀已是一種考驗。</p><p>遇到六角舉辦的「JS 學徒特訓班」，給自己一次機會跟上進度，也要求自己要真的理解才寫，這需要時間，而語法的不熟悉仍然花時間，這樣一次、兩次、三次的記憶，希望能夠多留在腦中，很清楚知道自己忘的比記的還快，也在找尋且動自己對語法記憶的一把鑰匙。學習程式是非常全面性的，也因此看到自己在幾十年歲月裡看不到的盲點，雖然開始的非常慢，但總是比沒開始的好，那就透過寫程式當作一種自我的修煉吧。</p><a id="more"></a><p>這次的特訓班題目都很實用，尤其是對自己較不熟悉的 API 銜接、資料處理、資料圖形化的部分，覺得練習內容很受用，以此篇來記錄一下。</p><h2 id="第二十九關，監聽切換排序功能"><a href="#第二十九關，監聽切換排序功能" class="headerlink" title="第二十九關，監聽切換排序功能"></a>第二十九關，監聽切換排序功能</h2><p>內容：以 Axios 讀取 API、使用表單元素 select 切換資料條件。<br>方式：</p><ul><li>抓取 DOM</li><li>以 Axios 讀取 API 的資料</li><li>監聽 select 切換</li><li>處理資料</li><li>渲染畫面</li></ul><p>常常會忘記有些 JS 內建函式的參數是「函式」，然後常常用箭頭函式寫法忘記花括號…。</p><p>首先，需要先把 Axios 函式庫引進來</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/axios/0.19.2/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接著是 html 的內容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"choose"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;option value=""&gt;請選擇排序依據&lt;/option&gt; --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"id"</span>&gt;</span>依照 id 編號排序(由1開始從上往下)<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"process"</span>&gt;</span>依照完課率排序(由最高到最低)<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再來就是 JavaScript 的部分了：</p><h3 id="抓取-DOM"><a href="#抓取-DOM" class="headerlink" title="抓取 DOM"></a>抓取 DOM</h3><p>把會用到的 DOM 和 裝載資料的變數先抓好</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="built_in">document</span>.querySelector(<span class="string">'.list'</span>);</span><br><span class="line"><span class="keyword">const</span> selector = <span class="built_in">document</span>.querySelector(<span class="string">'.choose'</span>);</span><br><span class="line"><span class="keyword">const</span> url =</span><br><span class="line">  <span class="string">'https://raw.githubusercontent.com/hexschool/hexschoolNewbieJS/master/data.json'</span>;</span><br><span class="line"><span class="keyword">let</span> data = [];</span><br></pre></td></tr></table></figure><h3 id="讀取資料"><a href="#讀取資料" class="headerlink" title="讀取資料"></a>讀取資料</h3><p>以 Axios 讀取 API 的資料</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.get(url).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  data = response.data;</span><br><span class="line">  <span class="comment">// console.log(data);</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="監聽-select-切換，取值"><a href="#監聽-select-切換，取值" class="headerlink" title="監聽 select 切換，取值"></a>監聽 select 切換，取值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 監聽事件綁定</span></span><br><span class="line">selector.addEventListener(<span class="string">'change'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.target.value == <span class="string">''</span>) <span class="keyword">return</span>;</span><br><span class="line">  getSortData(event.target.value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="處理資料"><a href="#處理資料" class="headerlink" title="處理資料"></a>處理資料</h3><p>資料需要以 ID 或 完成率來做排序，所以這個函式負責排序資料的處理。當選單的值為<code>id</code>時，以<code>id</code>來排序，不然就是用完成率來排名。<br>而為了讓排序更精準，在使用<code>sort()</code>時，給函式當參數。記得最後要呼叫渲染畫面的函式<code>render()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得選單的value 並排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSortData</span>(<span class="params">choose</span>) </span>&#123;</span><br><span class="line">  data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (choose == <span class="string">'id'</span>) <span class="keyword">return</span> <span class="built_in">parseInt</span>(a.id) - <span class="built_in">parseInt</span>(b.id);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(b.process) - <span class="built_in">parseInt</span>(a.process);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 排序完炫染畫面</span></span><br><span class="line">  render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染畫面"><a href="#渲染畫面" class="headerlink" title="渲染畫面"></a>渲染畫面</h3><p>以<code>forEach()</code>把資料一一撈出來，放在要渲染頁面的元素裡。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染畫面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line">  data.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    str += <span class="string">`&lt;li&gt;ID: <span class="subst">$&#123;item.id&#125;</span> 是 <span class="subst">$&#123;item.name&#125;</span>，他的特訓班完成度是 <span class="subst">$&#123;item.process&#125;</span>&lt;/li&gt;`</span>;</span><br><span class="line">    <span class="comment">// console.log(item);</span></span><br><span class="line">  &#125;);</span><br><span class="line">  list.innerHTML = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 六角JS學徒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zhs $ Hexo 故障解決記錄</title>
      <link href="/tsuifei.github.io/debug_note_01/"/>
      <url>/tsuifei.github.io/debug_note_01/</url>
      
        <content type="html"><![CDATA[<h2 id="想解決問題的慾望"><a href="#想解決問題的慾望" class="headerlink" title="想解決問題的慾望"></a>想解決問題的慾望</h2><p>大約是一週前，準備在因新冠疫情禁足的一個月之後，重啟一天發一篇文的挑戰。</p><p>因為每日練習英文打字，加上五十肩的疼痛，在無法讓肩膀適時休息之下，肩膀痛到不行，也因此學習之旅走鐘的頗嚴重，同時也清楚如果自己不持續下去，勢必有些學過的東西又會遺忘，所以決定每天就打一小小篇文就好。結果計畫又因一個<code>zsh: command not found hexo</code>的出現，又壞壞去了。</p><p>實在搞不清楚為什麼平常用得好好的指令突然就不能用了，在找問題出現在哪，且花了許多還是找不出來的狀況下，決定上「親愛的好想」的 slack 發問，在許多夥伴的幫助下，慢慢釐清可能的問題點，但由於自己的基本知識欠缺，而發生一知半解的狀況。</p><a id="more"></a><p>雖然一路下來花了很多時間在爬文，但由於是系統的設置，每個人都不太一樣，尤其是在上台電腦使用 sudo 最高權限操作，導致有許多問題產生，這些問題來自於網路上的求解，跟著指令做的解法也有許多風險，尤其是在自己不是很了解跟著做的指令，到底做了什麼、動到多少系統的基本配置，導致於最後有問題都不太能解決，所以新的電腦就決定盡量不要用 sudo 或是盡量安裝程式或套件時，安裝在需要用的專案裡就好。</p><p>ㄧ整個星期每次修都花好幾個小時，連做夢都夢到這件事，今天本來想說，好把，先把這個事情放掉，先用跛腳的卸掉<code>zsh</code>的方法上傳文章，因為<code>hexo</code>本身沒有壞，但是ㄧ手癢又開始試了，結果幾個小時過後，終於解決了！</p><p>知道要在<code>zsh</code>的設定檔<code>.zshrc</code>裡頭去設一個路徑變數，但是其實我連基本路徑變數語法都不知道，在解決的途中心裡一直想著，真的應該要去好好學學<code>Linux</code>的指令和系統架構，至少讓自己知道各個不同設定檔案應該會在哪些地方、放在哪裡、層級有什麼不同、全域變數應該是在哪裡可以找得到…等等。雖然會的指令可應付一般，但遇到問題仍然所知不足，所以解決後想說，那就開始學吧！</p><p>離題了，紀錄一下這次的處理：<br>狀況：出現<code>zsh: command not found hexo</code>的錯誤</p><ol><li>字面上來看，是<code>zsh</code>認不出<code>hexo</code>指令</li><li>把<code>zsh</code>卸掉<code>hexo</code>指令就可以用，表示<code>hexo</code>沒壞</li><li>在<code>/usr/local/bin/hexo</code>做了<code>hexo</code>軟連結仍然沒用，表示沒找到<code>hexo</code></li><li>用<code>which hexo</code>或<code>whereis hexo</code>仍然沒找到<code>hexo</code>，於是開始一層層找，一層層試<code>which hexo</code></li><li>找到<code>hexo</code>之後，將路徑寫成<code>PATH</code>放到<code>.zshrc</code>仍沒用</li><li>發現又被軟連結連到另一個地方，去哪裡試了<code>which hexo</code>與<code>hexo -v</code>成功，確認路徑</li><li>將<code>PATH</code>丟到<code>~/.bash_profile</code>沒成功</li><li>再將<code>PATH</code>丟到<code>~/.zshrc</code>成功!</li><li><code>PATH</code>的設定為<code>export PATH=~/.npm-global/lib/node_modules/hexo-cli/bin:\$PATH</code>並寫下註解<code># 把 hexo 指到指定位置</code></li><li>重啟<code>zsh</code>並試著更新文章：成功。</li></ol><p>問題解決後，就開始學習那些以前的不足，還知識債的概念。</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Other </tag>
            
            <tag> Hexo </tag>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueJs Vue Cli 3 environment deployment 開發部署</title>
      <link href="/tsuifei.github.io/Vue_14_Cli3_environment_deployment/"/>
      <url>/tsuifei.github.io/Vue_14_Cli3_environment_deployment/</url>
      
        <content type="html"><![CDATA[<p>大部分的許多專案的開發，都是偏向 Cli 環境部署的方式開發，也就是常聽到的「腳手架」的方式，但為什麼是「腳手架」？還是這也代表「起手式」？也就是專案在開發，應該就把要開發與運行的環境架設好，到時要打包輸出相容個瀏覽器的語法就會變得簡單多了。</p><p>雖然剛開始設定有點繁複，但只要習慣了、工具都齊了，這樣開發起來在測試也會順手許多，所以開發基本功還是要學起來。</p><p>實際上以 Cli 的方式部署，也有許多優點，因為他不只會幫你部署，還把整個專案需要用的檔案與資料夾都自動生成，讓你一安裝完就可以寫「Hello World」，當然這些自動生成的檔案我們也需要去了解其作用與規則，不然檔案放錯位置也是會產生錯誤的。</p><a id="more"></a><p>需注意的是，每一個 Cli 的版本都會不太ㄧ樣，所以安裝時的選項也會依版本而略有不同。</p><p>安裝後產生的檔案包也可以稱為「開發模板」我們可以在 <a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">vue-cli 的 github</a> 或<a href="https://cli.vuejs.org/" target="_blank" rel="noopener">官網</a>上找到文件。</p><h2 id="Vue-Cli-3-的開發環境部署步驟"><a href="#Vue-Cli-3-的開發環境部署步驟" class="headerlink" title="Vue Cli 3 的開發環境部署步驟"></a>Vue Cli 3 的開發環境部署步驟</h2><h4 id="1-先確認本機是否裝了-Vue-的-cli-套件"><a href="#1-先確認本機是否裝了-Vue-的-cli-套件" class="headerlink" title="1.先確認本機是否裝了 Vue 的 cli 套件"></a>1.先確認本機是否裝了 Vue 的 cli 套件</h4><p><code>vue -- version</code> 或是 <code>vue -V</code>(大寫的 V)</p><p>如果沒有，先以以下兩個方式一個選裝好 cli<br><code>npm install -g @vue/cli</code><br><code>npm install -g @vue/cli-service-global</code><br>或是<code>yarn global add @vue/cli</code><br>如果連<code>npm</code>和<code>yarn</code>都跑不起來，表示你的電腦上沒安裝管理套件工具，請先去<code>npm</code>和<code>yarn</code>的官方網站看看怎麼安裝囉。</p><h4 id="2-至想創建專案的位置，執行並給予專案名稱-小寫"><a href="#2-至想創建專案的位置，執行並給予專案名稱-小寫" class="headerlink" title="2.至想創建專案的位置，執行並給予專案名稱(小寫)"></a>2.至想創建專案的位置，執行並給予專案名稱(小寫)</h4><p><a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create" target="_blank" rel="noopener">官網解說</a></p><p><code>vue create [ProjectName]</code></p><h4 id="3-進入設置專案選項-一律以上下移動與按空白鍵選取選項"><a href="#3-進入設置專案選項-一律以上下移動與按空白鍵選取選項" class="headerlink" title="3.進入設置專案選項(一律以上下移動與按空白鍵選取選項)"></a>3.進入設置專案選項(一律以上下移動與按空白鍵選取選項)</h4><p>這時即進入開發部署的選項區，最好先了解一下，各個選項的作用，當然之後也可以修改，但比較麻煩，所以如果可以還是先想好自己要的開發環境，以及需要什麼工具，一次就把它安裝好。</p><p>==選擇套件工具==</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Please pick a preset: (Use arrow keys)</span><br><span class="line">❯ default (babel, eslint) // 預設</span><br><span class="line">  Manually select features // 自選，有其他選項如sass</span><br></pre></td></tr></table></figure><p>==進入選擇 list==<br>使用<code>&lt;space&gt;</code>選擇 ｜ <code>&lt;a&gt;</code>全選或全不選 ｜ <code>&lt;i&gt;</code> 相反，選了可取消</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">? Check the features needed for your project:</span><br><span class="line">❯◉ Babel</span><br><span class="line"> ◯ TypeScript</span><br><span class="line"> ◯ Progressive Web App (PWA) Support</span><br><span class="line"> ◯ Router</span><br><span class="line"> ◯ Vuex</span><br><span class="line"> ◯ CSS Pre-processors // 使用 sass</span><br><span class="line"> ◉ Linter / Formatter</span><br><span class="line"> ◯ Unit Testing</span><br><span class="line"> ◯ E2E Testing</span><br></pre></td></tr></table></figure><p>==進入各細項的選擇==<br>SASS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supporte</span><br><span class="line">d by default): (Use arrow keys)</span><br><span class="line">❯ Sass/SCSS (with dart-sass)</span><br><span class="line">  Sass/SCSS (with node-sass) // Node</span><br><span class="line">  Less</span><br><span class="line">  Stylus</span><br></pre></td></tr></table></figure><p>寫作風格與語法檢查</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pick a linter / formatter config: (Use arrow keys)</span><br><span class="line">❯ ESLint with error prevention only</span><br><span class="line">  ESLint + Airbnb config</span><br><span class="line">  ESLint + Standard config</span><br><span class="line">  ESLint + Prettier</span><br></pre></td></tr></table></figure><p>何時檢查語法寫作風格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Pick additional lint features:</span><br><span class="line">❯◉ Lint on save // 儲存時檢查</span><br><span class="line"> ◯ Lint and fix on commit // git commit 時檢查</span><br></pre></td></tr></table></figure><p>要將這些套件的設定值放哪裡？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.?</span><br><span class="line">  In dedicated config files</span><br><span class="line">❯ In package.json</span><br></pre></td></tr></table></figure><p>要將這些預設值儲存起來以後用嗎？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? Save this as a preset for future projects? (y/N)</span><br></pre></td></tr></table></figure><p>如果選 y 以後一開始的選項就可選擇。</p><h4 id="4-安裝完成啟動伺服器"><a href="#4-安裝完成啟動伺服器" class="headerlink" title="4. 安裝完成啟動伺服器"></a>4. 安裝完成啟動伺服器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">⚓  Running completion hooks...</span><br><span class="line"></span><br><span class="line">📄  Generating README.md...</span><br><span class="line"></span><br><span class="line">🎉  Successfully created project test.</span><br><span class="line">👉  Get started with the following commands:</span><br><span class="line"></span><br><span class="line"><span class="meta"> $</span> cd test // 先進入專案檔案內</span><br><span class="line"><span class="meta"> $</span> npm run serve // 啟動伺服器</span><br></pre></td></tr></table></figure><p>啟動完畢會顯示本地和客戶端的位址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  App running at:</span><br><span class="line">  - Local:   http://localhost:8080/</span><br><span class="line">  - Network: http://192.168.53.40:8080/</span><br><span class="line"></span><br><span class="line">  Note that the development build is not optimized.</span><br><span class="line">  To create a production build, run npm run build.</span><br><span class="line">// 請注意，開發版本未進行優化。 要創建生產版本，請運行npm run build。</span><br></pre></td></tr></table></figure><h3 id="部署完成的檔案的結構"><a href="#部署完成的檔案的結構" class="headerlink" title="部署完成的檔案的結構"></a>部署完成的檔案的結構</h3><p>部署完成後，檔案的結構大致上長這樣，但會依安裝的套件不同而些許不ㄧ樣。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hello-world/        (專案目錄)</span><br><span class="line">│</span><br><span class="line">├── dist/           (使用 npm run build 構建完成的檔案)</span><br><span class="line">│</span><br><span class="line">├── node_modules/   (依賴的模組)</span><br><span class="line">│</span><br><span class="line">├── public/         (公共資源檔案，不做任何編譯壓縮處理，使用絕對路徑指定的檔案)</span><br><span class="line">│   │</span><br><span class="line">│   ├── favicon.ico (icon 圖片)</span><br><span class="line">│   └── index.html  (網站入口)</span><br><span class="line">│</span><br><span class="line">├── src/            (Vue 與前端的原始檔案)</span><br><span class="line">│   │</span><br><span class="line">│   ├── assets/     (公共資源檔案，與 public 不同的是，assets 會經由 webpack 構建處理，使用相對路徑指定的檔案，如 LOGO 圖片)</span><br><span class="line">│   ├── components/ (Vue 公共組件)</span><br><span class="line">│   ├── views/      (Vue Router 頁面組件)</span><br><span class="line">│   ├── App.vue     (項目入口)</span><br><span class="line">│   ├── main.js     (項目的核心)</span><br><span class="line">│   ├── router.js   (路由設定)</span><br><span class="line">│   └── store.js    (Vuex 狀態管理)</span><br><span class="line">│</span><br><span class="line">└── package.json    (相當於對整個項目的解釋說明文件)</span><br></pre></td></tr></table></figure><h4 id="在現有的專案中安裝插件"><a href="#在現有的專案中安裝插件" class="headerlink" title="在現有的專案中安裝插件"></a>在現有的專案中安裝插件</h4><p>使用 vue create 來創建一個新專案的時候，有些插件會根據你選擇的特性被預安裝好，如果想在一個已經被創建好的專案中安裝一個插件，可以使用。vue add 命令：<br><code>vue add @vue/eslint</code></p><h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4><p>npm 快速安裝 bootstrap<br><code>npm install bootstrap --save</code></p><h4 id="設定參考網站"><a href="#設定參考網站" class="headerlink" title="設定參考網站"></a>設定參考網站</h4><p><a href="https://footmark.info/programming-language/vuejs/vue-cli3-seting/" target="_blank" rel="noopener">MIS 腳印: Vue CLI 3 安裝與使用教學</a><br><a href="https://www.itread01.com/content/1548001296.html" target="_blank" rel="noopener">使用 vue-cli 3 快速建立 Vue 專案及專案配置 Vue.config.js</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法國面試筆記</title>
      <link href="/tsuifei.github.io/Question_Entretien_01/"/>
      <url>/tsuifei.github.io/Question_Entretien_01/</url>
      
        <content type="html"><![CDATA[<p>這系列是由觀看法國這位求職教練 Yves Gautier 的 QuestionEntretien 這一系列的影片<a href="https://youtu.be/8i4BaK9tUws" target="_blank" rel="noopener">Parlez moi de vous, présentez-vous, exemples de réponses (coaching emploi)</a>的筆記。</p><p>在法國找工作必須先進入「找工作」領域，也就是說，要先學習如何找工作。從如何寫履歷、寫動機信、得到面試機會，如何面試，都有種種的眉眉角角的地方要注意，而歐洲文化與東方的不同，也讓面試時所注重的點不同，這是文化上的差距，需要多聽聽法國的求職教練怎麼說，才能較為清楚與正確地在面試中表達自己。</p><p>在法國面試，一定會先請你口頭自我介紹，如何在幾分鐘內把自己的動機和特質介紹給對方，且讓對方對你有印象還真不是件容易的事，當對方請你做簡短的自我介紹，以下為建議。</p><h2 id="請你談談你自己"><a href="#請你談談你自己" class="headerlink" title="請你談談你自己"></a>請你談談你自己</h2><ol><li>為什麼自我介紹是必要的</li></ol><ul><li>是面試的開端</li><li>好的內容是給對方對的訊息</li><li>讓對方聆聽</li></ul><ol start="2"><li>常犯的錯誤</li></ol><ul><li>敘述履歷、太攏長、偏離主題</li></ul><ol start="3"><li>回答範例</li></ol><ul><li>有主題的敘述自己的專長與特質，從技術面、工作經驗等等條例式的敘述。</li><li>以目標來敘述自己，例如想成為開發者的，用關鍵字的方式說明自己的特質。</li><li>如果得到這個職位後的計畫。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Entretien </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Entretien </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 有疑問的部分</title>
      <link href="/tsuifei.github.io/Discutable_code/"/>
      <url>/tsuifei.github.io/Discutable_code/</url>
      
        <content type="html"><![CDATA[<p>重新看了 Chris 的鐵人賽糙扣系列，在這一篇裡<a href="https://ithelp.ithome.com.tw/articles/10203004" target="_blank" rel="noopener">糙 code 與他們的產地 - if 的判斷式</a> 看到了 Array 去重的部分，卻看不懂…先記下，看以後有沒有辦法看懂。</p><h2 id="Array-去掉重複值"><a href="#Array-去掉重複值" class="headerlink" title="Array 去掉重複值"></a>Array 去掉重複值</h2><p>在處理 Array 元素重複問題時，常常會寫 if 並且走訪元素找重複。<br>好一點的，會使用 Array.prototype.includes</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [];</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr2.includes(item)) &#123;</span><br><span class="line">    arr2.push(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">arr2; <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>但是，這很糙!!! &lt;– Chris 大大說的。<br>其實，只要換容器，就可以輕鬆做到這件事。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...new <span class="built_in">Set</span>(arr)]; <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>你看！沒有任何的 if 這樣的品味才對。&lt;– 也是 Chris 大大說的。</p><p>待續….</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 語法作用域(Lexical scope)</title>
      <link href="/tsuifei.github.io/JS_Basic_Lexical_Scope/"/>
      <url>/tsuifei.github.io/JS_Basic_Lexical_Scope/</url>
      
        <content type="html"><![CDATA[<p>常常聽到 JavaScript 的語法作用域和其它語言有些不同，主要是 JavaScript 是屬於使用「靜態作用域」的語言，那什麼又是「靜態作用域」呢？</p><p>簡單來說，「靜態作用域」就是變數的作用域在被解析時，就已經確定了作用域，且不會再改變。有靜態就有動態，而「動態作用域」又是什麼？<br>「動態作用域」是變數的作用域，在調用函式的時候才決定。</p><p>靜態作用域，是在 <strong>語法解析</strong>的時候，就已經確定了。<br>動態作用域，是在函式<strong>被調用呼叫的時候</strong>才決定的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> moi = <span class="string">'Tsuifei'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(moi);</span><br><span class="line">&#125;</span><br><span class="line">callName(); <span class="comment">// Tsuifei</span></span><br></pre></td></tr></table></figure><p>在<code>function</code>裡的變數因為被函式包住，所以是區域變數，而在函式最外層的則是全域變數，所以在上面這段程式中，我們呼叫了<code>callName()</code>這個函式，再進去一行行執行函式內，當我們要它印出<code>moi</code>時，他會先去上面（已經讀到的）找，這時會找到<code>let moi = &#39;Tsuifei&#39;;</code>而把<code>&#39;Tsuifei&#39;</code>印出來。</p><p>但是如果函式裡面找不到<code>moi</code>，又要在函式裡面印出<code>moi</code>呢？因為<code>moi</code>這個變數是在<code>callName()</code>這個函式被定義的，所以它的作用域就會在這個函式裡。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> moi = <span class="string">'Tsuifei'</span>;</span><br><span class="line">&#125;</span><br><span class="line">callName(); <span class="comment">//</span></span><br><span class="line"><span class="built_in">console</span>.log(moi);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> moi = <span class="string">'Philippe'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> moi = <span class="string">'Tsuifei'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'內：'</span> + moi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'外：'</span> + moi);</span><br><span class="line">callName();</span><br><span class="line"><span class="comment">// 外：Philippe</span></span><br><span class="line"><span class="comment">// 內：Tsuifei</span></span><br></pre></td></tr></table></figure><p>參考：<br><a href="https://ithelp.ithome.com.tw/articles/10223753" target="_blank" rel="noopener">Javascript 進階 2-3 語法作用域(Lexical scope) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JavaScript 30 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>淺談 Ajax 是什麼？</title>
      <link href="/tsuifei.github.io/Ajax_01/"/>
      <url>/tsuifei.github.io/Ajax_01/</url>
      
        <content type="html"><![CDATA[<p>Ajax 全名為 Asynchronous JavaScript and XML，一種允許瀏覽器與伺服器交換資料，而不需刷新頁面的技術，都可以叫做 Ajax.</p><p>Ajax 這個名字是在 2005 年 5 月的時候，Adaptive Path 的 Jasse James Garrett 在他所寫的文章 Ajax : New Approach to Web Application 中提出的。而 Ajax 這項技術，是由 Google 在 Google labs 發佈的 Google Maps 和 Google Suggest 後真正為人所認識。</p><p>Ajax 的技術特殊在於，資料在瀏覽器端與伺服器端交換資料時是「獨立傳輸」而不需要返回整個頁面，只需要更新頁面的一部分。</p><p>不需要更新整個頁面資料的技術有好幾種：</p><ul><li>Flash</li><li>Java applet</li><li>框架</li><li>隱藏的 iframe</li><li>XMLHttpRequest : 此物件是 JavaScript 的一個模組，可使網頁與伺服器進行溝通，是創建 Ajax 應用的最佳選擇，實際上通常我們會把 Ajax 當成 XMLHttpRequest 物件的代名詞。</li></ul><h3 id="Ajax-的工作原理"><a href="#Ajax-的工作原理" class="headerlink" title="Ajax 的工作原理"></a>Ajax 的工作原理</h3><table><thead><tr><th>客戶端</th><th>傳輸</th><th>伺服器端</th></tr></thead><tbody><tr><td>xhtml</td><td>協議：xmlhttp</td><td>PHP…等</td></tr><tr><td>css</td><td>載體： Text, xml, Json…</td><td>其他語言</td></tr><tr><td>JavaScript</td><td></td><td></td></tr></tbody></table><h3 id="Ajax-相關工具"><a href="#Ajax-相關工具" class="headerlink" title="Ajax 相關工具"></a>Ajax 相關工具</h3><p>Ajax 並不是新技術，它實際上是集合好幾種技術，每種技術各盡其職，整合起來而成的技術。</p><ul><li>伺服器端語言：伺服器端需具備像瀏覽器發送特定訊息的能力，Ajax 與伺服器端語言無關。</li><li>XML(eXtensible Markup Language, 可擴展標記語言)，是一種描述資料的格式。Ajax 需要某種格式化的格式來在客戶端和伺服器端之間傳遞資料，XML 是其中一種。</li><li>XHTML 和 CSS 標準化呈現</li><li>DOM 可以與之實現動態顯示與互動。<a href="https://www.html.cn/doc/javascript/htmldom/" target="_blank" rel="noopener">DOM 簡介</a></li><li>使用 XMLHTTP 組件 XHLHttpRequest 物件進行非同步資料讀取。</li><li>使用 JavaScript 綁定和處理所有的資料。</li></ul><h3 id="Ajax-缺點"><a href="#Ajax-缺點" class="headerlink" title="Ajax 缺點"></a>Ajax 缺點</h3><ul><li>由 JavaScript 和 AJAX 引擎導致的瀏覽器兼容問題。</li><li>頁面局部更新，導致後退功能失效。</li><li>對串接媒體的支持沒有 Flash, JavaScript 好。</li><li>部分 Mobile 設備如手機、平板支援度差。</li></ul><h2 id="XMLHttpRequest-概述"><a href="#XMLHttpRequest-概述" class="headerlink" title="XMLHttpRequest 概述"></a>XMLHttpRequest 概述</h2><p>XMLHttpRequest 最早是在 IE 5 中以 ActiveX 組件的型態實現的，它並不是 W3C 的標準。</p><ul><li>Internet Explorer 把 XMLHttpRequest 當成是一個 ActiveX 物件。</li><li>其他瀏覽器如 FireFox, Safari, Opera 把 XMLHttpRequest 當成一個本地端的 JavaSCript 的物件。</li><li>XMLHttpRequest 在不同瀏覽器上是可以互相兼容的，所以可以用同樣的方法去走訪 XMLHttpRequest 實例的屬性和方法，不論這個實例是用哪種方式創建。</li></ul><h2 id="創建-XMLHttpRequest-物件"><a href="#創建-XMLHttpRequest-物件" class="headerlink" title="創建 XMLHttpRequest 物件"></a>創建 XMLHttpRequest 物件</h2><p>為了每次寫 Ajax 的時候可快速開發，可以把 XMLHttpRequest 物件測試寫成一個可重複用的函式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHTTPObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP-請求-request-與回應-response"><a href="#HTTP-請求-request-與回應-response" class="headerlink" title="HTTP 請求(request)與回應(response)"></a>HTTP 請求(request)與回應(response)</h2><p><strong>一個 HTTP 請求(request)由四個部分組成</strong></p><ul><li>HTTP 請求方法(method)或「動詞」(verb)</li><li>所請求的 url</li><li>一組選擇性的請求標頭(headers)，其中包含認證(authentication)資訊</li><li>一組選擇性的請求主體(body)</li></ul><p><strong>伺服器所送出的的 HTTP 回應(response)有三個部分</strong></p><ul><li>由數值與文字所組成的狀態碼(status code)，指定請求或失敗。</li><li>一組回應標頭(headers)</li><li>回應主體(body)</li></ul><h2 id="使用-Axios"><a href="#使用-Axios" class="headerlink" title="使用 Axios"></a>使用 Axios</h2><p>Axios 在 Github 上說明，可透過 npm 安裝在開發專案上，或者也可以使用 CDN 將 Axios 引進來，就可以開始用了。</p><p>先以 GET 的方式向 Server 請求資料，因為 Axios 是非同步，所以<code>response</code>會在程式一行行都跑完後，最後才會跑<code>.then</code>的部分。</p><p>線上模擬 api <code>www.mocky.io</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用 GER 方法</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Make a request for a user with a given ID</span></span><br><span class="line"><span class="regexp">axios</span></span><br><span class="line"><span class="regexp">  .get('/u</span>ser?ID=<span class="number">12345</span><span class="string">')</span></span><br><span class="line"><span class="string">  .then(function (response) &#123;</span></span><br><span class="line"><span class="string">    // handle success 接收伺服器的回應</span></span><br><span class="line"><span class="string">    console.log(response);</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">  .catch(function (error) &#123;</span></span><br><span class="line"><span class="string">    // handle error 如有錯誤會到這裡</span></span><br><span class="line"><span class="string">    console.error(error);</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">  .then(function () &#123;</span></span><br><span class="line"><span class="string">    // always executed 無論如何都會執行</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 使用 POST 方法</span></span><br></pre></td></tr></table></figure><h2 id="HTTP-Methods"><a href="#HTTP-Methods" class="headerlink" title="HTTP Methods"></a>HTTP Methods</h2><p>運作方式為 Server -&gt; JSON -&gt; Client -&gt; AJAX -&gt; Server</p><h3 id="1-GET-讀取-readoncy"><a href="#1-GET-讀取-readoncy" class="headerlink" title="1. GET 讀取 readoncy"></a>1. GET 讀取 readoncy</h3><p>只有 GET 才應使用 Query String (重要)<br>如果 fd 結尾 -&gt; 讀取單一物<br>如果沒有 fd 結尾 -&gt; 讀取該物的 collection</p><h3 id="2-DELELE-刪除特定資料"><a href="#2-DELELE-刪除特定資料" class="headerlink" title="2. DELELE 刪除特定資料"></a>2. DELELE 刪除特定資料</h3><h3 id="3-POST-建立新資源"><a href="#3-POST-建立新資源" class="headerlink" title="3. POST 建立新資源"></a>3. POST 建立新資源</h3><p>會把資源的 ID 傳回給用戶<br>如果 POST 兩次怎麼辦？</p><h3 id="4-PATCH-更動資源的部分內容"><a href="#4-PATCH-更動資源的部分內容" class="headerlink" title="4. PATCH 更動資源的部分內容"></a>4. PATCH 更動資源的部分內容</h3><ul><li>URL = /v1/users/1001</li><li>Method = PATCH</li><li>Request Body = { “age” : 31}</li></ul><h3 id="5-PUT-新上傳的內容、覆蓋原來的"><a href="#5-PUT-新上傳的內容、覆蓋原來的" class="headerlink" title="5. PUT 新上傳的內容、覆蓋原來的"></a>5. PUT 新上傳的內容、覆蓋原來的</h3><p>或是 Partial Update 部分更動</p><h3 id="6-Method-OPTIONS"><a href="#6-Method-OPTIONS" class="headerlink" title="6. Method OPTIONS"></a>6. Method OPTIONS</h3><ul><li>用來查詢某ㄧ資源，並能使用的 method</li><li>在 cors domain request 時 Client 端會先發出 OPTIONS 查詢</li></ul><p>相關連結：<br><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios/axios: Promise based HTTP client for the browser and node.js</a></p>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js Custom Directives 自定義指令</title>
      <link href="/tsuifei.github.io/Vue_13_Custom_Directives/"/>
      <url>/tsuifei.github.io/Vue_13_Custom_Directives/</url>
      
        <content type="html"><![CDATA[<p>什麼時候會用到自定義指令？除了原本的默認內置指令，雖然 Vue 的元件是可以複用的，但有時候我們仍然需要對普通 DOM 元素進行不同效果的操作，這時候就會用到自定義指令。在 Vue 內建的指令無法滿足需求或需要一個特別的功能時，就可以自己攥寫自定義指令，好處是可以重複使用。</p><p>自定義指定有兩種：全域自定義指令與局部的自定義指令。有時候我們在一個頁面裡可能會引入或增加好幾個 Vue 的實例，如果是全域的自定義指令，表示所有的 Vue 實例都可使用這個指令，但如果是局部自定義指令，需要指定能使用這組指令的 Vue 實例。</p><a id="more"></a><p>先來看 codepen :<br><a href="https://codepen.io/tsuifei/pen/eYNgWzg" target="_blank" rel="noopener">Vue.Js Custom Directives 自定義指令</a></p><!-- more --><h3 id="全域的寫法"><a href="#全域的寫法" class="headerlink" title="全域的寫法"></a>全域的寫法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Global 全域自定義指令 ps. directive 沒有 s</span></span><br><span class="line">Vue.directive(<span class="string">'my-directive'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  el.innerHTML = binding.value.toupperCase();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="局部的寫法"><a href="#局部的寫法" class="headerlink" title="局部的寫法"></a>局部的寫法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 局部的自定義指令 ps. directives 有 s</span></span><br><span class="line">directives : &#123;</span><br><span class="line">    <span class="string">'my-directive'</span> : &#123;</span><br><span class="line">        bind (el, binding) &#123;</span><br><span class="line">          el.innerHTML = binding.value.toUpperCase()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 也可以寫成</span></span><br><span class="line">    <span class="string">'my-directive'</span>(el, binding) &#123;</span><br><span class="line">      el.innerHTML = binding.value.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>在 HTML 的元素標籤上，直接以自定義的指令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-my-directive</span> = <span class="string">'xxx'</span>;&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="實作兩個自定義指令"><a href="#實作兩個自定義指令" class="headerlink" title="實作兩個自定義指令"></a>實作兩個自定義指令</h2><ol><li>功能的類型為<code>v-text</code>，功能是可將字串轉換成大寫，取名為<code>v-upper-text</code></li><li>功能的類型為<code>v-text</code>，功能是可將字串轉換成小寫，取名為<code>v-lower-text</code></li></ol><p>需要注意的是，我們自訂的指令名，並不包含<code>v-</code>例如上述要實作的<code>v-upper-text</code>，指令名為<code>upper-text</code>，<code>v-</code>一但定義了這些自定義的指令，在使用時就需要加上<code>v-</code>。而只最終會被寫在 HTML 的元素標籤裡。</p><p>這個指令名會對應到一個「處理函式」，如以下範例的<code>Vue.directive()</code>的第二參數<br>以下面的範例的 callback 函式來看，有兩個參數，第一個為<code>el</code>表示使用這個指令的標籤，第二個參數<code>binding</code>我們可以試著<code>console.log()</code>出來觀察。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-upper-text</span>=<span class="string">"msg1"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-lower-text</span>=<span class="string">"msg1"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-upper-text</span>=<span class="string">"msg2"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-lower-text</span>=<span class="string">"msg2"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 註冊定義全局指令</span></span><br><span class="line"><span class="comment">// el : 指令屬性的所在標籤物件</span></span><br><span class="line"><span class="comment">// binding : 包含指令相關訊息的資料物件</span></span><br><span class="line">Vue.directive(<span class="string">'upper-text'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el, binding);</span><br><span class="line">  <span class="comment">// 把改變好的內容再指定回去</span></span><br><span class="line">  el.innerHTML = binding.value.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg1: <span class="string">'Hello Paris'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 註冊局部定義指令，只會對 #app1 這個實例有效</span></span><br><span class="line">  directives: &#123;</span><br><span class="line">    <span class="string">'lower-text'</span>(el, binding) &#123;</span><br><span class="line">      el.innerHTML = binding.value.toLowerCase();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg2: <span class="string">'Hello Taipei'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在官網也提供一個很實用的範例，例如會員登入頁，我們希望使用者一進入頁面，不需將滑鼠移至輸入帳號的 input 框裡，而可直接輸入在輸入框裡，就可設一個全域的自定義的指令，這樣無論在哪一個登入頁面，只要需要先登入，就可使用這個 input 聚焦的指令在 input 裡，達到到達頁面可直接輸入內容的效果。<br><strong>HTML 部分</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 部分</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 註冊一個全局自定義指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">  <span class="comment">// 當被綁定的元素插入到 DOM 中時……</span></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果想註冊局部指令，組件中也接受一個 directives 的選項：</span></span><br><span class="line"></span><br><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    <span class="comment">// 指令的定義</span></span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>參考：<a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">自定義指令 — Vue.js</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js Directives Vue 常用的內建指令</title>
      <link href="/tsuifei.github.io/Vue_12_Directives/"/>
      <url>/tsuifei.github.io/Vue_12_Directives/</url>
      
        <content type="html"><![CDATA[<p>之前的幾篇都有介紹此表前半段的 Vue 內建指令用法，這裡要介紹最後面的兩個內建指令<code>ref</code>和<code>v-cloak</code><br>先來 codepen 看看：<a href="https://codepen.io/tsuifei/pen/NWqddBX" target="_blank" rel="noopener">Vue.Js ref 唯一識別 與 v-cloak 隱藏表達式</a></p><table><thead><tr><th>指令</th><th>作用</th><th>Vue</th></tr></thead><tbody><tr><td>v-if</td><td>如果為 <code>true</code>, 當下的標籤元素才會輸出渲染到頁面</td><td></td></tr><tr><td>v-html</td><td>更新元素的 <code>innerHTML</code></td><td></td></tr><tr><td>v-else</td><td>如果為 <code>false</code>, 當前標籤才會輸出到頁面</td><td></td></tr><tr><td>v-show</td><td>通過控制 <code>display</code> 樣式來達到控制顯示和隱藏效果</td><td></td></tr><tr><td>v-for</td><td>遍歷陣列或物件，渲染出列表</td><td></td></tr><tr><td>v-text</td><td>更新元素的 <code>textContent</code></td><td></td></tr><tr><td>v-on</td><td>綁定事件監聽, 一般簡寫為<code>@</code></td><td></td></tr><tr><td>v-bind</td><td>強制綁定解析表達式, 可以省略 <code>v-bind</code> 一般簡寫為<code>:</code></td><td></td></tr><tr><td>v-model</td><td>雙向資料綁定</td><td></td></tr><tr><td>ref</td><td>為某個元素註冊一個唯一標識, vue 物件通過 <code>$refs</code> 屬性訪問這個元素物件</td><td></td></tr><tr><td>v-cloak</td><td>使用它防止閃現表達式, 與 css 配合: <code>[v-cloak] { display: none }</code></td><td></td></tr></tbody></table><a id="more"></a><h2 id="ref-元素的唯一識別"><a href="#ref-元素的唯一識別" class="headerlink" title="ref 元素的唯一識別"></a>ref 元素的唯一識別</h2><p>給需要一個標籤一個唯一識別，可用<code>ref</code>，但如何透過我們給標籤的<code>ref</code>取得標籤的內容，在實例的方法裡，可以使用<code>$refs</code>這個方法取得：<code>this.$refs.content.textContent</code>，可選用<code>innerText</code>或者是<code>textContent</code>效果是一樣的。</p><p><code>ref</code>的作用是為某個元素註冊一個唯一標識, vue 物件會透過 $refs 屬性來訪問這個元素物件或其內容。</p><p>參考：<a href="https://cn.vuejs.org/v2/api/#ref" target="_blank" rel="noopener">API — Vue.js ref</a></p><h2 id="v-cloak-防止在頁面出現-Vue-的表達式"><a href="#v-cloak-防止在頁面出現-Vue-的表達式" class="headerlink" title="v-cloak 防止在頁面出現 Vue 的表達式"></a>v-cloak 防止在頁面出現 Vue 的表達式</h2><p>因為程式是一行行執行的，有時因為頁面跳轉的關係，程式還沒讀取完即出現在頁面上，這時 Vue 的表達式像是<code></code>就會被看見，為了避免這樣的狀況產生，可以使用在標籤上使用<code>v-cloak</code>，並在 Style 以屬性選擇器<code>[v-cloak]</code>選取，並給予<code>display:none</code>先隱藏它，直到程式讀取到資料後，這個屬性會自動地被拿掉，就可預防出現 Vue 的表達式。<br><strong>HTML 部分</strong></p><p>來看看使用<code>ref</code>和<code>v-cloak</code>的範例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">"content"</span>&gt;</span>Hello Paris<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"hint"</span>&gt;</span>Hint<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- v-cloak --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloak</span>&gt;</span>Hello Taipei<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 部分</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">'Hello Taipei'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    hint() &#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.$refs.content.textContent);</span><br><span class="line">      alert(<span class="keyword">this</span>.$refs.content.innerText);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>參考：<a href="https://cn.vuejs.org/v2/api/#v-cloak" target="_blank" rel="noopener">API — Vue.js v-cloak</a></p><h2 id="v-once-只渲染元素和元件一次"><a href="#v-once-只渲染元素和元件一次" class="headerlink" title="v-once 只渲染元素和元件一次"></a>v-once 只渲染元素和元件一次</h2><p>有些元素在頁面中並不需要每次都渲染，如果使用<code>v-once</code>，Vue 就只會渲染元素和元件一次，之後如果重新渲染，元素/元件及其所有 DOM Tree 的子節點就會被視為靜態的內容並略過，這樣可以有助於優化效能。<br><strong>HTML 部分</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span></span><br><span class="line">        &#123;&#123;content&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 部分</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    content: <span class="string">'第一次的文字內容'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 第二次給值渲染</span></span><br><span class="line">app.content = <span class="string">'第二次的文字更新'</span>;</span><br></pre></td></tr></table></figure><p>以上的範例即使使用<code>app.content</code>再次選染，但值還是會是第一次被選染的值，因為渲染一次之後就會被當成靜態元素處理。</p><p>參考：<a href="https://cn.vuejs.org/v2/api/#v-once" target="_blank" rel="noopener">API — Vue.js v-once</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js Filters 過濾器</title>
      <link href="/tsuifei.github.io/Vue_11_Filters/"/>
      <url>/tsuifei.github.io/Vue_11_Filters/</url>
      
        <content type="html"><![CDATA[<p>有時我們拿到一包資料，需要透過過濾器來拿到我們想要的資料格式。例如我們可以透過一些外來的函式庫，拿到一些資料，但如果想依照我們想要的格式顯示，就必須過濾我們要的資訊，再依我們用的函式庫規則，寫成想要顯示的格式。</p><p>先來 Codepen 看一下效果 <a href="https://codepen.io/tsuifei/pen/eYNBoLZ" target="_blank" rel="noopener">Vue.Js Filters 過濾器</a></p><h3 id="什麼是過濾器"><a href="#什麼是過濾器" class="headerlink" title="什麼是過濾器"></a>什麼是過濾器</h3><p>過濾器的功能是要對顯示的資料進行特定的格式化後再顯示，且過濾器並不會去改變原本的資料，而是產生一個新的對應的資料格式。</p><a id="more"></a><p>白話一點就是「過濾器」主要的功能是將我們想要的資料，進行格式化。例如我們想要依照我們想要的格式來顯示日期。在程式裡取得的時間是透過從 1970 年 1 月 1 日所開始計算的時間差而來，透過程式拿到的現在時間必須經過一些步驟的運算，才能得到當下點的時間。</p><!-- more --><p>要注意的是過濾器只能在雙花括號的插值和表達式的<code>v-bind</code>時使用。</p><p>因為有時差、時區與冬夏令時間的問題，所以要得到我們想要的時間點變得有些複雜，也因此在處裡時間時，會偏向引入已經把繁複計算包成函式庫的方式來操控時間與日期的部分。</p><p>在這裡我們以<code>moments.js</code>為例，這支函式庫在處理時間的顯示上非常方便，所以許多人引入它來直接使用。</p><p>使用外來的函式庫，可以使用 CDN 的方式，或者透過<code>npm</code>安裝到我們的專案裡，記得如果我們的 Vue 也是以 CDN 的方式引入，要將外來的 CDN 排在 Vue 之後。</p><p>我們可以先創建一個由建構是得來的<code>new Data()</code>，將其存在<code>time</code>裡，試著在頁面上顯示它，會得到「Sun Feb 23 2020 11:26:19 GMT+0100 (中歐標準時間)」，但這並不是我們想顯示的時間格式，我們想顯示的是像「2020-02-23, 13:10:20」的格式。</p><p>可先去 <a href="https://momentjs.com/" target="_blank" rel="noopener">Moment.js</a>的官網查找使用規則。</p><h3 id="過濾器呼叫時候的使用"><a href="#過濾器呼叫時候的使用" class="headerlink" title="過濾器呼叫時候的使用"></a>過濾器呼叫時候的使用</h3><p>當我們在使用大花括號的時候，如果需要特別處理包裹在大花括號裡的文字，可使<code>|</code>分隔，之後寫上過濾器的名稱，Vue 會先使用過濾器處理文字，再把處理過的值給予大花括號裡的變數。</p><h2 id="如何自定義與使用過濾器"><a href="#如何自定義與使用過濾器" class="headerlink" title="如何自定義與使用過濾器"></a>如何自定義與使用過濾器</h2><p>我們先來看一下定義與使用過濾器的公式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用過濾器</span></span><br><span class="line">&lt;div&gt;&#123;&#123; myData | filterName &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;&#123;&#123; myData | filterName(arg) &#125;&#125;&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>使用過濾器的方式是，假設我們已經有個日期<code>myData</code>，後面需指定一個過濾函式<code>filterName</code>，這個函式會接受表達式<code>myData</code>的值，再回傳一個新的值。 新的值則是我們想要的資料格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義過濾器（在vue 實例外定義）</span></span><br><span class="line"> Vue.filter(filterName, <span class="function"><span class="keyword">function</span>(<span class="params">value[,arg1,arg2,...]</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 進行一定的資料處理</span></span><br><span class="line">   <span class="keyword">return</span> newValue</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>引入之後要先做定義過濾器的動作，透過<code>Vue.filter()</code>的函式物件<code>filter(&#39;自定義過濾器名稱&#39;, callback回調函式)</code>指定。回調函式裡的<code>value</code>指的是將要被格式化的值，也就是範例裡到<code>time</code>的值，最後過濾器會回傳一個新的值。這個值就是我們希望的格式。</p><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><p>HTML 部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>顯示格式化的日期和時間<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; time &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>完整格式：&#123;&#123; time | timeString &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>年月日：&#123;&#123; time | timeString('YYYY-MM-DD') &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>時分秒：&#123;&#123; time | timeString('HH:mm:ss') &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>沒有指定：&#123;&#123; time | timeString() &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript 與 Vue 實例部分</p><p>callback 回調函式的參數：參數 1=原本的格式 2= 希望的格式，如果沒給第二個參數就會使用原本的。</p><p>回傳的<code>format</code>:<br>format(ˋ 如果有給值就用 myFormat || 不然就用我們設定的’YYYY-MM-DD, HH:mm:ss’)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義過濾器</span></span><br><span class="line">Vue.filter(<span class="string">'timeString'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value, myFormat</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> moment(value).format(myFormat || <span class="string">'YYYY-MM-DD, HH:mm:ss'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="comment">// 建構式取得現在時間</span></span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="過濾器也可以用正則和帶參數"><a href="#過濾器也可以用正則和帶參數" class="headerlink" title="過濾器也可以用正則和帶參數"></a>過濾器也可以用正則和帶參數</h3><p>替代部分文字</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; msg | changeText('嬰孩') &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.11/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 定義全域過濾器，也可帶參數</span></span></span><br><span class="line"><span class="javascript">  Vue.filter(<span class="string">'changeText'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">text, arg2</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 字串的replace方法只會取代一次，第一個參數除了可寫一個字串外，也可定義一個正則式</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> text.replace(<span class="regexp">/年輕/g</span>, arg2);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      msg: <span class="string">'年輕的人最有活力，年輕是美好的，年輕就是本錢。'</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>今天就先介紹到這邊囉。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.Js Transitioning Single Elements/Component 過渡與動畫效果</title>
      <link href="/tsuifei.github.io/Vue_10_Transitioning_Elements_Components/"/>
      <url>/tsuifei.github.io/Vue_10_Transitioning_Elements_Components/</url>
      
        <content type="html"><![CDATA[<p>原本在一般頁面要製造一些簡單的動畫效果，只要掌控 class 和 Css 就好了，但是如果要在框架內做這些動態效果，如何做？</p><p>在 Vue 裡有它的特殊做法，必須把享有動態效果的元素，以<code>&lt;transition&gt;</code>的標籤包起來，並給予一個<code>name</code>的屬性，然後在 CSS 裡，以這個<code>name</code>來作為 class 的名稱，並加上動畫不同時期的後綴，來達到動態效果。</p><p>先來看一下 Codepen <a href="https://codepen.io/tsuifei/pen/vYOyGeq" target="_blank" rel="noopener">VueJs Transitioning Single Elements/Component 過渡與動畫效果</a></p><a id="more"></a><p>我們先來看一張官方上的示意圖：<br><img src="https://cn.vuejs.org/images/transition.png" alt></p><p>要指定進出場的樣式需要搭配 Vue 指定的後綴詞，進、出場個分三個階段<br>進場：</p><table><thead><tr><th>階段</th><th>進場 Enter</th><th>出場 Leave</th></tr></thead><tbody><tr><td>開始</td><td>v-enter</td><td>v-leave</td></tr><tr><td>結束</td><td>v-enter-to</td><td>v-leave-to</td></tr><tr><td>整個過程</td><td>v-enter-active</td><td>v-leave-active</td></tr></tbody></table><p>再依照每個過程，指定不同的效果。而表中的<code>v</code>是在沒有給<code>&lt;transition&gt;</code>名字的時候，如果有給<code>name</code>，則把<code>v</code>用我們給的<code>name</code>替換就好了。</p><h2 id="淡入淡出的過度效果-Transition"><a href="#淡入淡出的過度效果-Transition" class="headerlink" title="淡入淡出的過度效果 Transition"></a>淡入淡出的過度效果 Transition</h2><p>以淡入淡出的效果來說，在 HTML 需要先將<code>&lt;transition&gt;</code>把我們要做動態效果的元素包住，例如我們希望點一個按鈕，讓文字淡入淡出切換，就可以寫成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app1"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 將字慢慢消失、透明度0 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span>Switch1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;p v-show="show"&gt;Hello Paris&lt;/p&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>Hello Paris<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在文字的<code>&lt;p&gt;</code>標籤內，我們可以給<code>v-if</code>或<code>v-show</code>，這兩個效果是一樣的。</p><p>Vue 實例的部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app1'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">          show: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>然後在 CSS 裡依上述規則指定，在進場時透明度為 0 漸變為 100，而出場則反之。而按鈕則控制進出場的切換。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*指定進場*/</span></span><br><span class="line"><span class="selector-class">.fade-enter-active</span>,</span><br><span class="line"><span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*指定出場*/</span></span><br><span class="line"><span class="selector-class">.fade-enter</span>,</span><br><span class="line"><span class="selector-class">.fade-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="動畫效果的放大縮小-Animation"><a href="#動畫效果的放大縮小-Animation" class="headerlink" title="動畫效果的放大縮小 Animation"></a>動畫效果的放大縮小 Animation</h2><p>我們也可以以動畫的方式來將組件變大變小與出場，也是一樣使用 Enter 和 Leave 的三個階段，分別設定。<br>CSS 的部分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用Animation 動畫 */</span></span><br><span class="line">      <span class="selector-class">.bounce-enter-active</span> &#123;</span><br><span class="line">        <span class="attribute">animation</span>: bounce-in <span class="number">1s</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-class">.bounce-leave-active</span> &#123;</span><br><span class="line">        <span class="attribute">animation</span>: bounce-in <span class="number">1s</span> reverse;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">@keyframes</span> bounce-in &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        100% &#123;</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>HTML 部分<br>因為文字段落<code>&lt;p&gt;</code>標簽是行內元素，所以放大縮小會以整行的大小來算，所以會看不出小果，最好將這段該成<code>display: inline-block</code>就可比較清出的看出變化效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Animation 動畫 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span>Toggle show<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"bounce"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span> <span class="attr">style</span>=<span class="string">"display: inline-block"</span>&gt;</span>Hello Tainan<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Vue 實例的部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm4 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app4'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>發現原本可以簡單在 Css 裡做出的的動畫效果，在框架裡做還是有些綁手綁腳，如果讓這些小果更容易操控，得要先了解 Vue 是怎麼處理這些效果，在官網的解釋算是蠻清楚的，但幫自己要做一些簡單的圖片入場效果，就開始感到有點綁手綁腳，有點可惜。</p><p>如果對此部分有興趣的話，除了可以看看官方解釋，也推薦「Summer。桑莫。夏天」的部落格，至少比較親和。</p><p>Transitioning Single Elements/Components<br>官方文件：<a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">進入/離開 &amp; 列表過渡 — Vue.js</a></p><p><a href="https://cythilya.github.io/2017/05/28/vue-transitions/" target="_blank" rel="noopener">Vue.js: 樣式與漸變 Transitions | Summer。桑莫。夏天</a></p><p><a href="https://cythilya.github.io/2017/06/09/vue-transition-effects/" target="_blank" rel="noopener">Vue.js: 進階過渡效果 | Summer。桑莫。夏天</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueJs Instance Lifecycle Hooks 生命週期鉤子</title>
      <link href="/tsuifei.github.io/Vue_09_Instance_Lifecycle_Hooks/"/>
      <url>/tsuifei.github.io/Vue_09_Instance_Lifecycle_Hooks/</url>
      
        <content type="html"><![CDATA[<p>在 Vue 所使用到的整個生命週期方法，可以想像成是一齣戲要上演，哪一個主角需要在哪個時候上場、哪個配角需要在哪個時刻退場，都需要有邏輯才可以讓故事產生連貫性與流暢。</p><p>Vue 的生命週期方法雖然共有八個，但並不是每個都需要用到，就像在戲裡，有些橋段不出現、配角不出現也不會影響整齣性的故事性。</p><p>把 Vue 的生命週期分為三個大階段會比較容易理解：第一階段的「初始化顯示」、第二階段「更新狀態顯示」、第三階段「死亡、銷毀 Vue 實例」，每個階段都有對應的生命週期 callback 方法，這些生命週期的方法也稱為「生命週期鉤子」掛載在不同時期。 Vue 的生命週期比 React 還要複雜一些。</p><p>為了避免 <code>this</code> 的混淆，這些生命週期的方法都是回調方法(callback)，所以最好一律都寫成箭頭函式，讓 <code>this</code> 直接指向父級，也就是 vue 實例本身。</p><a id="more"></a><h2 id="Vue-的生命週期各階段都做了什麼？"><a href="#Vue-的生命週期各階段都做了什麼？" class="headerlink" title="Vue 的生命週期各階段都做了什麼？"></a>Vue 的生命週期各階段都做了什麼？</h2><h3 id="0-創建-Vue-的實例"><a href="#0-創建-Vue-的實例" class="headerlink" title="0. 創建 Vue 的實例"></a>0. 創建 Vue 的實例</h3><p>當我們創建好一個 Vue 的實例，就會馬上進入下一個階段<code>beforeCreate()</code>。</p><h3 id="1-初始化顯示階段"><a href="#1-初始化顯示階段" class="headerlink" title="1. 初始化顯示階段"></a>1. 初始化顯示階段</h3><ul><li><p><strong>beforeCreate() 實例創建前</strong></p><ul><li>準備工作：觀察初始化(Observe Data)、初始化事件(Init Events)</li><li>這個階段實例的 data、methods 是讀不到的</li></ul></li><li><p><strong>created() 實例創建後</strong></p><ul><li>這個階段已經完成了資料觀察初始化(data observer)，屬性和方法的運算， watch/event 事件回調。mount 掛載階段還沒開始，$el 屬性目前不可見，資料並沒有在 DOM 元素上進行渲染。</li></ul></li><li><p><strong>beforeMount() 在掛載開始之前被調用</strong></p></li><li><p>相關的 render 函數首次被調用。</p></li><li><p><strong>mounted()</strong></p></li><li><p>初始化顯示之後。立即調用。是最常用的 callback，用來「掛載」到頁面上。</p></li><li><p><code>el</code>選項的 DOM 節點 被新創建的 <code>vm.$el</code> 替換，並掛載到實例上去之後調用此生命週期方法。此時實例的資料在 DOM 節點上進行渲染。</p></li></ul><h3 id="2-更新狀態顯示階段"><a href="#2-更新狀態顯示階段" class="headerlink" title="2. 更新狀態顯示階段"></a>2. 更新狀態顯示階段</h3><p><code>this.xxx = value</code></p><ul><li><p><strong>beforeUpdate() 資料更新時調用</strong></p><ul><li>但不進行 DOM 重新渲染，在資料更新時 DOM 沒渲染前可以在這個生命方法裡進行狀態處理。</li></ul></li><li><p><strong>updated() 資料更新並且 DOM 重新渲染</strong></p><ul><li>這個狀態下資料更新並且 DOM 重新渲染，當這個生命週期方法被調用時，組件 DOM 已經更新，所以這時可以執行依賴於 DOM 的操作。當實例每次進行資料更新時 updated 都會執行。</li></ul></li></ul><p>當我們調用 vm.$destroy()時，就會進入下一個銷毀 Vue 實例的階段</p><h3 id="3-死亡、銷毀-Vue-實例階段"><a href="#3-死亡、銷毀-Vue-實例階段" class="headerlink" title="3.死亡、銷毀 Vue 實例階段"></a>3.死亡、銷毀 Vue 實例階段</h3><p>也稱死亡，也就是沒有互動的功能。</p><ul><li><p><strong>beforeDestory() 實例銷毀之前調用</strong></p></li><li><p><strong>destoryed() 實例銷毀後調用</strong></p><ul><li>Vue 實例銷毀後調用。調用後，Vue 實例指示的所有東西都會解綁定，所有的事件監聽器會被移除，所有的子實例也會被銷毀。</li></ul></li></ul><h2 id="查看生命週期方法的順序範例"><a href="#查看生命週期方法的順序範例" class="headerlink" title="查看生命週期方法的順序範例"></a>查看生命週期方法的順序範例</h2><p>範例：一行字，每隔一秒會切換成隱藏。</p><p>在初始化之後，把初始化的值以<code>v-show</code>的方式讓<code>&lt;p&gt;</code>依定時器的規則顯示。<br>再設定一個按鈕，綁定可以銷毀 vm 的函式，當點擊按鈕時這個 vm 會銷毀而停止顯示或隱藏切換，這個定時器掛載到<code>mounted()</code>之後，點擊按鈕雖然會停止文字顯示的切換，卻不會停止我們在定時器裡放的<code>console.log(&#39;++++++&#39;)</code>，也表示「定時器」並沒有被銷毀。</p><p>要把整個定時器銷毀(進入銷毀 Vue 實例)階段，需要在<code>beforeDestroy()</code>這個階段清除定時器，我們可使用<code>clearInterval()</code>來清除定時器，但是如何找到我們要銷毀的定時器？可以在<code>mounted()</code>階段的定時器，指向我們設定的變數<code>this.intervalId = setInterval()</code>來讓清除定時器的函式找到。</p><p>在實例裡加入每個時期的生命週期方法，並用<code>console.log</code>印出來，執行一下頁面就可看到其順序。</p><h2 id="各生命週期執行次數"><a href="#各生命週期執行次數" class="headerlink" title="各生命週期執行次數"></a>各生命週期執行次數</h2><table><thead><tr><th>階段</th><th>生命週期 Hook</th><th>執行次數</th></tr></thead></table><p>| 初始化顯示階段<br>||beforeCreate() 實例創建前 | 1 次<br>| |created() 實例創建後 | 1 次 |<br>| | beforeMount() 在掛載開始之前 | 1 次<br>|| mounted() 掛載 | 1 次<br>| 更新狀態顯示階段<br>| | beforeUpdate() 資料更新時 | 不限次數 |<br>| | updated() 資料更新並 DOM 重新渲染 | 不限次數 |<br>| 死亡、銷毀 Vue 實例階段| | |<br>| | beforeDestory() 實例銷毀之前 | 1 次 |<br>| | destoryed() 實例銷毀後 | 1 次 |</p><h2 id="常用的生命週期方法？"><a href="#常用的生命週期方法？" class="headerlink" title="常用的生命週期方法？"></a>常用的生命週期方法？</h2><ul><li><code>mounted()</code>：主要用來發送<code>ajax</code>請求，啟動定時器等非同步的任務。</li><li><code>beforeDestory()</code>：做收尾的工作，例如清除定時器，否則定時器會一直執行下去（如範例）</li><li><code>created()</code>：進行 ajax 請求異步數據的獲取、初始化數據</li><li><code>mounted()</code>：掛載元素內 dom 節點的獲取</li><li><code>nextTick()</code>：針對單一事件更新數據後立即操作 dom</li><li><code>updated()</code>：任何數據的更新，如果要做統一的業務邏輯處理</li><li><code>watch()</code>：監聽具體數據變化，並做相應的處理</li></ul><h2 id="實際操作"><a href="#實際操作" class="headerlink" title="實際操作"></a>實際操作</h2><p>來 codepen 看看：<a href="https://codepen.io/tsuifei/pen/WNvGJKb?editors=1111" target="_blank" rel="noopener">VueJs Instance Lifecycle Hooks 生命週期鉤子</a>，別忘了觀察 console 的變化。<br>HTML 部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"destroyVm"</span>&gt;</span>Destroy vm<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>&gt;</span>Hello Paris<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Vue 實例的部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    isShow: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 1.初始化顯示階段</span></span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1. beforeCreate'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2. created'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3. beforeMount'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 初始化後的顯示，所以放在mounted(只用一次)</span></span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4. mounted'</span>);</span><br><span class="line">    <span class="comment">// 定時器，每一秒改變一次</span></span><br><span class="line">    <span class="keyword">this</span>.intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'+++++++++'</span>);</span><br><span class="line">      <span class="keyword">this</span>.isShow = !<span class="keyword">this</span>.isShow;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 2.更新狀態顯示階段</span></span><br><span class="line">  beforeUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5. beforeUpdate'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  updated() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6. updated'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 3.死亡、銷毀 Vue 實例階段 / 銷毀之前調用（只用一次）</span></span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    <span class="comment">// 清除定時器</span></span><br><span class="line">    clearInterval(<span class="keyword">this</span>.intervalId);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7. beforeDestroy'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8. destroyed'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 毀掉vm</span></span><br><span class="line">    destroyVm() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$destroy();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js Form Input Bindings 表單輸入綁定</title>
      <link href="/tsuifei.github.io/Vue_08_Form_Input_Bindings/"/>
      <url>/tsuifei.github.io/Vue_08_Form_Input_Bindings/</url>
      
        <content type="html"><![CDATA[<p>使用 Vue 資料雙向綁定的特性，做表單資料的自動收集。</p><p>先去 codepen 看看：<a href="https://codepen.io/tsuifei/pen/qBdaPrL?editors=1111" target="_blank" rel="noopener">Vue.js Form Input Bindings 表單輸入綁定</a></p><p>通常在處理表單的時候，在填完表單時，通常以<code>&lt;from&gt;</code>標籤內的<code>action</code>屬性來傳送，但在 Vue 裡，可以先把<code>&lt;from&gt;</code>的預設<code>submit</code>動作取消，並以監聽的方式(v-on)處理：<code>@submit.prevent(方法)</code>。當我們按下送出表單鍵時，就會去執行<code>handleSubmit</code>這個方法，在方法裡在指定我們希望如何處理表單內的資料就可以了。</p><h3 id="表單裡的標籤綁定"><a href="#表單裡的標籤綁定" class="headerlink" title="表單裡的標籤綁定"></a>表單裡的標籤綁定</h3><p>主要以<code>v-model</code>來做資料的雙向綁定，達到自動收集填入資料的目的。<br>表單裡有單純的輸入(text/textarea)、單選項(radio)、複選項(checkbox)和選單(select)，實例中我們必須先在<code>data</code>裡初始化我們會用到的值，這些初始值則是對應到 HTML 表單標籤裡的<code>value</code>，例如，如果我們希望預設的<code>radio</code>選項是 female，在<code>data</code>裡的<code>sex</code>初始，給<code>female</code>就可以了，以此類推。</p><a id="more"></a><p>需要注意的是，因為複選項(checkbox)是可以複選，所以必須是陣列格式，才能複選。</p><p>另外，在選單(select)的部分，可以在實例的<code>data</code>中先把物件型態的陣列準備好，然後在 HTML 使用<code>v-for</code>迴圈的方式讀取選單裡的選項。需要注意的是，通常在資料庫裡，我們需要的會是這些屬性的<code>id</code>而非文字，所以物件型態的陣列可以給兩個屬性：<code>city.name</code>和<code>city.id</code>，找到<code>id</code>就可找到對應的城市名。<br>而這個選單(select)的初始值，也就是<code>v-model</code>綁定的<code>cityId</code>，在實例的<code>data</code>裡也須先初始化好。</p><p>如果我們希望使用者所輸入的資料是固定的某一資料型別，例如可以計算的<code>number</code>，那麼我們也可以在 HTML 標籤的屬性上指定 v-model 的資料型別，確保同步時使用者更動回來的是數字。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"productPrice"</span> <span class="attr">type</span>=<span class="string">"number"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>商品價格：&#123;&#123; productPrice &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTML 的部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"xxx"</span> @<span class="attr">submit.prevent</span>=<span class="string">"handleSubmit"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Name : <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"name"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>Password : <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pwd"</span> <span class="attr">v-model</span>=<span class="string">"pwd"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>Sex : <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"female"</span> <span class="attr">value</span>=<span class="string">"female"</span> <span class="attr">v-model</span>=<span class="string">"sex"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"female"</span>&gt;</span>Femme<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"male"</span> <span class="attr">value</span>=<span class="string">"male"</span> <span class="attr">v-model</span>=<span class="string">"sex"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"male"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hobby : <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"travel"</span> <span class="attr">id</span>=<span class="string">"travel"</span> <span class="attr">v-model</span>=<span class="string">"hobbys"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"travel"</span>&gt;</span>Travel<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"cinema"</span> <span class="attr">id</span>=<span class="string">"cinema"</span> <span class="attr">v-model</span>=<span class="string">"hobbys"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"cinema"</span>&gt;</span>Cinema<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"food"</span> <span class="attr">id</span>=<span class="string">"food"</span> <span class="attr">v-model</span>=<span class="string">"hobbys"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"food"</span>&gt;</span>Food<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"sport"</span> <span class="attr">id</span>=<span class="string">"sport"</span> <span class="attr">v-model</span>=<span class="string">"hobbys"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"sport"</span>&gt;</span>Sport<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>City : <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 動態顯示 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">v-model</span>=<span class="string">"cityId"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>No selection<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果直接寫value="city.id" 會被當成是字串，需加上冒號 :value="" 成為表達式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">:value</span>=<span class="string">"city.id"</span> <span class="attr">v-for</span>=<span class="string">"(city, index) in citys"</span> <span class="attr">:key</span>=<span class="string">"city.id"</span>&gt;</span></span><br><span class="line">          &#123;&#123;city.name&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">textarea</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">"info"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">cols</span>=<span class="string">"30"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rows</span>=<span class="string">"10"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">placeholder</span>=<span class="string">"Self introduction"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-model</span>=<span class="string">"info"</span></span></span><br><span class="line"><span class="tag">      &gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"register"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Vue 實例的部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: <span class="string">''</span>,</span><br><span class="line">    pwd: <span class="string">''</span>,</span><br><span class="line">    sex: <span class="string">'female'</span>, <span class="comment">// 預設值是從 value 抓來的</span></span><br><span class="line">    hobbys: [<span class="string">'travel'</span>],</span><br><span class="line">    citys: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        name: <span class="string">'Paris'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        name: <span class="string">'Taipei'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">3</span>,</span><br><span class="line">        name: <span class="string">'London'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">4</span>,</span><br><span class="line">        name: <span class="string">'Tainan'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    cityId: <span class="string">'2'</span>,</span><br><span class="line">    info: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSubmit() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="keyword">this</span>.name,</span><br><span class="line">        <span class="keyword">this</span>.pwd,</span><br><span class="line">        <span class="keyword">this</span>.sex,</span><br><span class="line">        <span class="keyword">this</span>.hobbys,</span><br><span class="line">        <span class="keyword">this</span>.cityId,</span><br><span class="line">        <span class="keyword">this</span>.info</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js Event Handling 事件處理</title>
      <link href="/tsuifei.github.io/Vue_07_Event_Handling/"/>
      <url>/tsuifei.github.io/Vue_07_Event_Handling/</url>
      
        <content type="html"><![CDATA[<p>事件處理在網頁上的應用非常廣，無論是我們滑鼠移動、按鍵輸入、或是在網頁上點擊某一個區塊，都可以因為這個互動，讓網頁做些事。但在程式裡，其實就是瀏覽者做了某些事(事件監聽)<br>，然後我們要給出什麼反應(事件觸發)，例如，點一下按鍵，我們要程式去做某些事，例如呼叫某支函式要它做些什麼，或者，我們希望能取到瀏覽者所點擊到的值。</p><p>Codepen : <a href="https://codepen.io/tsuifei/pen/vYOKgOm" target="_blank" rel="noopener">Vue.js Event Handling 事件處理</a></p><a id="more"></a><p>這裡分三個部分來示範在事件處理時， Vue 會用到的一些指令</p><h2 id="1-監聽事件的綁定"><a href="#1-監聽事件的綁定" class="headerlink" title="1. 監聽事件的綁定"></a>1. 監聽事件的綁定</h2><p>我們可以使用 vue 的<code>@click=&quot;觸發事件的方法&quot;</code>來監聽與綁定事件：<br>第一個按鈕<code>test1</code>: 一般的觸發事件，直接取到我們點擊按鈕的值。<br>第二個按鈕<code>test2</code>: 帶參數的觸發事件，可直接取到我們給的參數。<br>第三個按鈕<code>test3</code>: 點擊的事件，可加上 vue 的特殊變數<code>$event</code>來監聽，但事實上如果我們沒有加上<code>$event</code>此參數，vue 也會自動幫我們抓取<code>event</code>監聽的對象。<br>第四個按鈕<code>test4</code>: 希望可以帶參數，同時又可取到監聽對象的值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"test1"</span>&gt;</span>test1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 綁定自己的資料 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"test2('Hello')"</span>&gt;</span>test2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可利用vue的特殊變數$event 來拿到button的值 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同這樣寫： &lt;button @clock="test3"&gt;test3&lt;/button&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"test3($event)"</span>&gt;</span>test3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 想傳自己給的變數，同時想取得點取 event 的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"test4(42,$event )"</span>&gt;</span>test4<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在實例的 methods 準備好觸發的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        test1() &#123;</span><br><span class="line">          alert(<span class="string">'test1'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        test2(msg) &#123;</span><br><span class="line">          alert(msg)</span><br><span class="line">        &#125;,</span><br><span class="line">        test3(event) &#123;</span><br><span class="line">          <span class="comment">// 透過 event裡的target與innerHTML去取得按鈕的內容</span></span><br><span class="line">          alert(event.target.innerHTML)</span><br><span class="line">        &#125;,</span><br><span class="line">        test4(nbr, event) &#123;</span><br><span class="line">          alert(nbr + <span class="string">'---'</span> + event.target.innerHTML)</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件修飾符"><a href="#事件修飾符" class="headerlink" title="事件修飾符"></a>事件修飾符</h2><h3 id="阻止冒泡行為：-click-stop"><a href="#阻止冒泡行為：-click-stop" class="headerlink" title="阻止冒泡行為：@click.stop"></a>阻止冒泡行為：@click.stop</h3><p>在原生的 Javascript 如果要防止冒泡行為或預設行為，需要在 JavaScript 裡的監聽對象加上<code>stopPropagation()</code><br>例如有兩個大小疊在一起、可點擊的 box，如果想點擊小 box，也會同時觸發到在它底部的大 box ，這即是「冒泡事件」。<br>在 vue 裡，只要在希望被點取的那個 div(這裡指小 box) 的<code>@click=&quot;&quot;</code> 加上<code>.stop</code>，如<code>@click.stop=&quot;&quot;</code>即可阻止冒泡事件，非常方便。</p><h3 id="阻止事件默認行為：-click-prevent"><a href="#阻止事件默認行為：-click-prevent" class="headerlink" title="阻止事件默認行為： @click.prevent"></a>阻止事件默認行為： @click.prevent</h3><p>如果有一個連結，我們想阻止事件的默認行為，也就是點擊後不想直接導向到連結網址去該怎麼做？在原生的 JavaScript 我們同樣需要使用<code>event.preventDefault()</code>來阻止 html 裡的預設行為，但是在 vue 裡，只要在 html 使用事件修飾符<code>prevent</code>就可以達到效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 防止(stop)事件冒泡 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span> @<span class="attr">click</span>=<span class="string">"test5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span> @<span class="attr">click.stop</span>=<span class="string">"test6"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 阻止事件默認行為 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://google.com"</span> @<span class="attr">click.prevent</span>=<span class="string">"test7"</span>&gt;</span>去google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在實例的 methods 準備好觸發的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  test5() &#123;</span><br><span class="line">    alert(<span class="string">'out'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  test6() &#123;</span><br><span class="line">    alert(<span class="string">'inner'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  test7(event) &#123;</span><br><span class="line">    alert(<span class="string">'點到了'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按鍵修飾符"><a href="#按鍵修飾符" class="headerlink" title="按鍵修飾符"></a>按鍵修飾符</h2><p>通常我們在 input 填好資料時，需要按一個送出的按鈕來送出，但其實用 enter 鍵會直覺很多，使用 Vue 的按鍵修飾符<code>@keyup</code>來指定監聽的方式是鍵盤輸入，如果想指定某一個鍵，需要知道按下的那個鍵的鍵碼，才能指定，如果不知道我們指定的鍵的鍵碼，可以用<code>alert(event.keyCode)</code>來查詢。</p><p>原生的寫法可用條件式判斷<code>if (event.keyCode === 13)</code>(這裡的 13 是 enter 鍵的鍵值)，確定點到的是指定的鍵。在 Vue 可直接將鍵碼加到 keyup 後面 –&gt; <code>keyup.13</code> 或是直接寫鍵名(只限定特殊鍵)<code>keyup.enter</code> 也可以達到一樣的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 想使用enter鍵輸入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">keyup.13</span>=<span class="string">"test8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">keyup.enter</span>=<span class="string">"test8"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在實例的 methods 準備好觸發的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  test8($event) &#123;</span><br><span class="line">    alert(event.target.value + <span class="string">'--'</span> + event.keyCode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Vue 裡還有許多其他的事件修飾符：stop / prevent / capture / self / once / passive。用法可以參閱官方文件<a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="noopener">事件處理 — Vue.js</a> 來了解各項用法。</p><p>Vue 把以往需要在 JavaScript 裡寫的程式碼，全部改成在 HTML 就可處理的指令，的確方便許多，但也要知道 Javascript 的原生寫法，才不會改天需要寫原生寫不出來，這就是 Vue 的方便會費人 JS 武功的原因了。</p><h3 id="自定義全域按鍵修飾符"><a href="#自定義全域按鍵修飾符" class="headerlink" title="自定義全域按鍵修飾符"></a>自定義全域按鍵修飾符</h3><p>有時需要操控某個按鍵，來達到一些效果，就可以指定某個按鍵為替代<br><code>Vue.config.keyCode.f2 = 113</code>表示以按鍵 F2 來取代原本 113(enter 鍵)keyCode 所做的事。<br>在標籤上就可這樣寫<code>@keyup.f2=&quot;addItem&quot;</code></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js Displaying Filtered/Sorted Results 顯示過濾/排序後的結果</title>
      <link href="/tsuifei.github.io/Vue_06_Displaying_Filtered_Sorted_Results/"/>
      <url>/tsuifei.github.io/Vue_06_Displaying_Filtered_Sorted_Results/</url>
      
        <content type="html"><![CDATA[<p>如何把現有的陣列，在做完過濾後存在另一個新的陣列裡？如何讓頁面即時顯示這個新的陣列列表？要產生新陣列的條件有哪些？原本的陣列、輸入框輸入了什麼資料？只要拿得到這兩個資料，就可產生新的過濾後的陣列。</p><p>我們來看一下，該如何進行？ 或是先來看一下<a href="https://codepen.io/tsuifei/pen/LYVNMBM" target="_blank" rel="noopener">完整的原始碼</a></p><p>輸入框先以<code>v-model</code>綁定資料，這個資料是過濾的條件<code>searchName</code>，需要去實例初始化它。</p><p>過濾條件後所產生的新陣列<code>filterPersons</code>則是透過<code>searchName</code>和<code>persons</code>陣列所計算產生出來的，所以我們需要一個在實例中的計算屬性 computed 的方法，去產生新的陣列<code>filterPersons</code>。這個方法的回傳值即是顯示的結果。</p><p>將原本的陣列<code>persons</code>套用<code>filter()</code>方法，再以<code>indexOf()</code>方法，用<code>searchName !== -1</code>ˋ 這個條件去查找的結果，存入新陣列<code>fPersons</code>中。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fPersons = persons.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.name.indexOf(searchName !== <span class="number">-1</span>));</span><br></pre></td></tr></table></figure><p>在過濾陣列的方法中，要先把需要的資料數據取出來，並將他們放在一個物件中，再開始過濾陣列的動作，把過濾產生的新陣列，用<code>sort()</code>方法來排序。</p><p>如果排序的功能只有兩種，通常會以布林值的方式來做切換，但在我們的排序功能的按鈕，除了升序和降序外，還有恢復原來排列的第三種，所以我們可以以數字來作為排序分類的指標數。<br>代表排序分類的<code>orderType</code>指派為：0 代表原本排序、1 代表升序, 2 代表降序。</p><p>在三個按鈕<br>上使用<code>@click=&quot;setOrderType(2)</code>監聽的方法、在實例的 methods 中增加<code>setOrderType()</code>方法，並將排序的方法寫在實例的計算屬性<code>filterPersons()</code>裡。而<code>setOrderType()</code>要做的事情，就是把這個方法的參數，指向實例中的 OrderType()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filterPersons()裡 排序的部分</span></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="comment">// 確定排序的指標 orderType 不是 0 才繼續排序下去</span></span><br><span class="line"><span class="keyword">if</span> (orderType !== <span class="number">0</span>) &#123;</span><br><span class="line">  fPersons.sort(<span class="function"><span class="keyword">function</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1代表降序, 2代表升序</span></span><br><span class="line">    <span class="keyword">if</span> (orderType === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 降序</span></span><br><span class="line">      <span class="keyword">return</span> p2.age - p1.age;</span><br><span class="line">      <span class="comment">// name 降序</span></span><br><span class="line">      <span class="comment">// return p2.name - p1.name</span></span><br><span class="line">      <span class="comment">// return p2.name.localeCompare(p1.name)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 升序</span></span><br><span class="line">      <span class="keyword">return</span> p1.age - p2.age;</span><br><span class="line">      <span class="comment">// name 升序</span></span><br><span class="line">      <span class="comment">// return p1.name - p2.name</span></span><br><span class="line">      <span class="comment">// return p1.name.localeCompare(p2.name)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例我們是以<code>age</code>來當排序條件，如果想要以<code>name</code>字母順序為排序條件，則可將條件的回傳值更改為<code>return p1.name.localeCompare(p2.name)</code>就會依字母順序排列了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setOrderType()部分</span></span><br><span class="line">methods: &#123;</span><br><span class="line">        setOrderType(orderType) &#123;</span><br><span class="line">          <span class="keyword">this</span>.orderType = orderType</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>有了這些功能，我們就可以讓 Todo List 有過濾的更多功能了。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js List Rendering 列表渲染</title>
      <link href="/tsuifei.github.io/Vue_05_List_Rendering/"/>
      <url>/tsuifei.github.io/Vue_05_List_Rendering/</url>
      
        <content type="html"><![CDATA[<p>如果要把一個陣列或物件渲染到畫面，在原生的 JS 我們可以用迴圈或 forEach 以遍歷的方式將陣列的資料顯示，如果用 ES6 就可用 for…of 循環語句。<br>在 Vue 裡要遍歷陣列的方法並不難，只是遍歷陣列和物件的方式稍有不同。<br><a href="https://codepen.io/tsuifei/pen/QWbNErL" target="_blank" rel="noopener">去 codepen 看看效果</a></p><h2 id="以-v-for-遍歷陣列顯示"><a href="#以-v-for-遍歷陣列顯示" class="headerlink" title="以 v-for 遍歷陣列顯示"></a>以 v-for 遍歷陣列顯示</h2><p>陣列列表顯示的方法是使用<code>v-for</code>指令，在遍歷的時候語法為<code>&lt;li v-for=&quot;(p, index) in persons&quot; :key=&quot;index&quot;&gt;&lt;/li&gt;</code><br>在使用<code>v-for</code>時要記得加上<code>:key</code> 讓單筆的屬性有唯一值，這個陣列的唯一值是 index。<br>在上面的語法範例，可以想成是<code>&lt;li v-for=&quot;(單個陣列, index索引值) in 陣列&quot; :key=&quot;index唯一索引值&quot;&gt;&lt;/li&gt;</code>。</p><a id="more"></a><p>假設我們有個陣列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">persons: [&#123;</span><br><span class="line">            name: <span class="string">'Ayda'</span>,</span><br><span class="line">            age: <span class="number">18</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            name: <span class="string">'Tracy'</span>,</span><br><span class="line">            age: <span class="number">24</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            name: <span class="string">'Philippe'</span>,</span><br><span class="line">            age: <span class="number">42</span></span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>在 HTML 我們可以這樣寫，就可以在頁面渲染出陣列的列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(p, index) in persons"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">    &#123;&#123; index &#125;&#125; --- &#123;&#123;p.name&#125;&#125; --- &#123;&#123;p.age&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="以-v-for-遍歷物件顯示"><a href="#以-v-for-遍歷物件顯示" class="headerlink" title="以 v-for 遍歷物件顯示"></a>以 v-for 遍歷物件顯示</h2><p>遍歷物件的方法也差不多，只是物件並沒有索引值，所以唯一值就會抓取 key 值，如：<br><code>v-for=&quot;(value, key) in persons[1]&quot; :key=&quot;key&quot;</code><br>可以想成：<br><code>v-for=&quot;(value屬性值, key屬性鍵值) in persons物件[1]&quot; :key=&quot;key唯一鍵值&quot;</code><br>每一個 key 值都需不相同。另外，遍歷物件的功能並不常用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 提取單筆 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;li v-for="(value, key) in persons[1]" :key="key"&gt;&#123;&#123;value&#125;&#125; -- &#123;&#123;key&#125;&#125;&lt;/li&gt; --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 提取全部 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(value, key) in persons"</span> <span class="attr">:key</span>=<span class="string">"key"</span>&gt;</span>&#123;&#123;value&#125;&#125; -- &#123;&#123;key&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="是改變了陣列本身還是陣列內部的資料？"><a href="#是改變了陣列本身還是陣列內部的資料？" class="headerlink" title="是改變了陣列本身還是陣列內部的資料？"></a>是改變了陣列本身還是陣列內部的資料？</h2><p>在 Vue 裡要做到刪除、更新、增加陣列並須先了解 Vue 的運作，要先分清楚我們所操作的是否有改變到陣列本身？還是更改到陣列內部的物件。<br>例如，如果我們使用<code>this.persons = []</code>我們把空陣列指向 <code>persons</code>物件，陣列因此成為空陣列，這樣的動作是有更動到陣列「本身」。<br>但是如果只是去改變陣列內物件的屬性、值，這就只有更動到陣列內部結構。這樣的內部結構改變 Vue 無法知道。<br><strong>Vue 只會監視 persons 這個陣列的改變，而不會監視陣列內部資料的改變。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;; <span class="comment">// 改變物件本身</span></span><br><span class="line">obj.t = <span class="number">1</span>; <span class="comment">// 只改變了物件的內部結構資料</span></span><br></pre></td></tr></table></figure><h2 id="變異方法對原生陣列方法進行包裹"><a href="#變異方法對原生陣列方法進行包裹" class="headerlink" title="變異方法對原生陣列方法進行包裹"></a>變異方法對原生陣列方法進行包裹</h2><p>解決的方法是使用 Vue 的「變異方法」 (mutation method)。</p><p>在 Vue 的官網上，列表渲染裡的「陣列更新檢測」有寫到，Vue 會將被偵聽的陣列的變異方法進行包裹，然後才將會觸發頁面的部分更新。</p><p>陣列裡有這些函式可改變陣列的內部結構，在 Vue 裡用這些方法時，如增加、刪除，用這些方法已不是 JS 的原生方法，而是 Vue 有特殊處理包裹過，包裹的過程會經過兩個步驟：呼叫原生方法函式與更新頁面，也就是 <strong>Vue 重寫了一遍這些方法，讓這些方法可以檢測到陣列內部資料的變化</strong>。如果 Vue 沒做這些包裹處理，那麼 Vue 就無法檢測到陣列內部資料的變化。</p><p>在做陣列內部資料的更動更新，一定要使用以下這些方法，才能讓陣列內部資料變化，自動更新到頁面上。</p><p>這些被 Vue 重新包裹過的方法成為「變異方法」有：<code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code>、<code>splice()</code>、<code>sort()</code>、<code>reverse()</code></p><p>其中，<code>splice()</code> 的功能很強大，可以一次辦到增加、刪除、修改。</p><h2 id="刪除、更新、增加的寫法"><a href="#刪除、更新、增加的寫法" class="headerlink" title="刪除、更新、增加的寫法"></a>刪除、更新、增加的寫法</h2><p>以範例來說，我們先在頁面增加三個分別為刪除、更新、增加的按鈕，這個範例只是簡單的介紹其運作的方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(p, index) in persons"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">    &#123;&#123; index &#125;&#125; --- &#123;&#123;p.name&#125;&#125; --- &#123;&#123;p.age&#125;&#125; --<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"deleteP(index)"</span>&gt;</span></span><br><span class="line">      Delete</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    -- <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"updateP(index, &#123;name:'Fanny', age: 25&#125;)"</span>&gt;</span>Update<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再來我們來看在 Vue 裡的刪除、更新、增加這三個方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">        deleteP(index) &#123;</span><br><span class="line">          <span class="keyword">this</span>.persons.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        updateP(index, newP) &#123;</span><br><span class="line">          <span class="comment">// this.persons[index] = newP</span></span><br><span class="line">          <span class="comment">// 這樣的做法因為無原生陣列函式，所以在vue 不會起作用，也不會自動更新頁面</span></span><br><span class="line">          <span class="comment">// console.log(this.persons[index], newP)</span></span><br><span class="line">          <span class="keyword">this</span>.persons.splice(index, <span class="number">1</span>, newP)</span><br><span class="line">        &#125;,</span><br><span class="line">        addP(newP) &#123;</span><br><span class="line">          <span class="keyword">this</span>.persons.push(newP)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>如果熟悉上面的操作，應該就可以試著寫出一個簡單的 todoList 了。<br>接下來就要來介紹排序的部分囉！</p><p>參考：<br><a href="https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95-mutation-method" target="_blank" rel="noopener">列表渲染 — Vue.js</a><br><a href="https://blog.csdn.net/qq_37860930/article/details/78529260" target="_blank" rel="noopener">ES6-遍曆數組 JavaScript</a><br><a href="https://segmentfault.com/a/1190000010203337" target="_blank" rel="noopener">ES5 和 ES6 數組遍歷方法詳解</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js Conditional Rendering 條件渲染語法</title>
      <link href="/tsuifei.github.io/Vue_04_Conditional_Rendering/"/>
      <url>/tsuifei.github.io/Vue_04_Conditional_Rendering/</url>
      
        <content type="html"><![CDATA[<p>既然是條件式，就一定有選擇，在程式裡，最簡單也最常用的選擇是使用布林值： true 或 false 只能擇一。利用這種二擇一的特性，去執行我們希望程式做的事。</p><p><a href="https://codepen.io/tsuifei/pen/KKpzKbV" target="_blank" rel="noopener">去 codepen 看看效果</a></p><p>在 Vue 裡的條件渲染指令有以下兩種：</p><h2 id="v-if-和-v-else-一起用"><a href="#v-if-和-v-else-一起用" class="headerlink" title="v-if 和 v-else 一起用"></a>v-if 和 v-else 一起用</h2><p><code>v-if</code>和<code>v-else</code> 一起用的時候，把條件的屬性放在<code>v-if</code>的標籤屬性裡，如果屬性結果是<code>true</code>就會顯示<code>v-if</code>的內容，如果結果是<code>false</code>就會顯示<code>v-else</code> 的內容，在選染頁面部分，我們會發現，如果是<code>false</code>，就連 HTML 的部分也不會被渲染出。</p><a id="more"></a><p>當我們只有有寫<code>v-else</code>如<code>&lt;p v-else&gt;失敗&lt;/p&gt;</code>等同是<code>v-else=&quot;true&quot;</code>，通常在<code>v-else</code>是不需要給條件的。</p><p>需要做切換時，只要使用運算子<code>!</code>將條件調整為<code>@click=&quot;yes=!yes&quot;</code> 就可達到切換的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"success"</span>&gt;</span>成功<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>失敗<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"success=!success"</span>&gt;</span>Switch<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="v-show-用兩次"><a href="#v-show-用兩次" class="headerlink" title="v-show 用兩次"></a>v-show 用兩次</h2><p><code>v-show</code>通常拿來作為一個切換器，像開關一樣，不是開就是關。如果需要平凡的切換，就使用<code>v-show</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"success"</span>&gt;</span>已完成<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"!success"</span>&gt;</span>未完成<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="v-if-和-v-show-的不同之處"><a href="#v-if-和-v-show-的不同之處" class="headerlink" title="v-if 和 v-show 的不同之處"></a>v-if 和 v-show 的不同之處</h2><p><code>v-if</code>可以搭配<code>v-else-if</code>和<code>v-else</code> 而有多選一的機制，但是<code>v-show</code>通常只能二選一。<br>在渲染的部分，使用<code>v-if</code>只會渲染出達到條件的 HTML，但是<code>v-show</code>會把條件全渲染出來，然後用以<code>style=&quot;display: none;&quot;</code>的方式隱藏。</p><h3 id="需要多選一的時候就用-v-if"><a href="#需要多選一的時候就用-v-if" class="headerlink" title="需要多選一的時候就用 v-if"></a>需要多選一的時候就用 v-if</h3><p>剛剛說過 <code>v-if</code>可以搭配<code>v-else-if</code>和<code>v-else</code> 做出多選一的機制，也很彈性，使用方法也很簡潔，同樣只會炫染出<code>true</code>的部分。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>v-if-else multiple<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"light==='red'"</span>&gt;</span>紅燈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else-if</span>=<span class="string">"light==='green'"</span>&gt;</span>綠燈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else-if</span>=<span class="string">"light==='yellow'"</span>&gt;</span>黃燈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>燈壞了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript Vue 實例的部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    success: <span class="literal">false</span>,</span><br><span class="line">    light: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>值得注意的是在 Vue 的官網上說明：不推薦同時使用<code>v-if</code> 和 <code>v-for</code></p><p>當 <code>v-if</code> 與 <code>v-for</code> 一起使用時，<code>v-for</code>會具有比 v-if 更高的優先級。詳細解釋請查閱 Vue 的<a href="https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7-%E5%BF%85%E8%A6%81" target="_blank" rel="noopener">風格指南 — Vue.js</a>和列表渲染指南：<br><a href="https://cn.vuejs.org/v2/guide/list.html#v-for-object" target="_blank" rel="noopener">列表渲染 — Vue.js</a></p><p><a href="https://cn.vuejs.org/v2/guide/conditional.html" target="_blank" rel="noopener">條件渲染 — Vue.js</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js Class &amp; Style Bindings 樣式的綁定</title>
      <link href="/tsuifei.github.io/Vue_03_class_style/"/>
      <url>/tsuifei.github.io/Vue_03_class_style/</url>
      
        <content type="html"><![CDATA[<p>當我們在瀏覽網頁時，透過使用者的輸入或互動，最容易會有變動的就是資料（透過輸入或修改）和樣式（透過互動或事件）的更動，而 VueJs 的樣式部分用 class 和 style 的綁定，就是專門用來與互動產生動態的樣式而來的。</p><p><a href="https://codepen.io/tsuifei/pen/yLNewLm" target="_blank" rel="noopener">去 codepen 看看效果</a></p><h2 id="Binding-HTML-Classes-綁定-HTML-裡-Class-的方法"><a href="#Binding-HTML-Classes-綁定-HTML-裡-Class-的方法" class="headerlink" title="Binding HTML Classes / 綁定 HTML 裡 Class 的方法"></a>Binding HTML Classes / 綁定 HTML 裡 Class 的方法</h2><p>在 DOM 的節點上使用<code>:class=&#39;xxx&#39;</code> xxx 可以是字串、物件或者是陣列型態。<br>這裡我們先設置了三個樣式分別為<code>ClassA</code>、<code>ClassB</code>、<code>ClassC</code>，我們在「xxx 是字元串」這個段落先給它一個基礎樣式<code>ClassC</code>，再綁定<code>myClass</code>，這會對應到 vm 實例裡<code>data</code>的<code>ClassA</code>，所以在這一段會有兩個樣式分別是<code>ClassA</code>＋<code>ClassC</code>。</p><a id="more"></a><p>CSS 的部分：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ClassA</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ClassB</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ClassC</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在「xxx 是物件」這個段落，我們以物件的方式綁定樣式，<code>:class=&quot;{classA:isActive, classB:!isActive}&quot;</code>，記得以物件綁定的話可以給多組樣式，但是一定要是以<code>key:value</code>的方式寫，這裏我們以<code>classB:!isActive</code>把<code>classB</code>設為非 isActive，這個樣式就不會被顯示。</p><p>另一段「xxx 是陣列」的段落是以陣列的方式綁定，既然是陣列就可以給多個值，但這種方式比較不常用，以物件的方式還是比較靈活。</p><h2 id="Binding-Inline-Styles-綁定行內-style-的方法"><a href="#Binding-Inline-Styles-綁定行內-style-的方法" class="headerlink" title="Binding Inline Styles / 綁定行內 style 的方法"></a>Binding Inline Styles / 綁定行內 style 的方法</h2><p>使用 Style 綁定的方法也很方便，我們先創建一個叫<code>Update</code>的按鍵，使用<code>v-on:click</code>等同<code>@click=&quot;Update&quot;</code>去呼叫實例中<code>methods</code>的<code>Update</code>的方法，並指定這個事件被觸發時，某些屬性的值會跟著改變。<br>我們在這個段落初始的樣式以物件型態給值，初始化的顏色為<code>{activeColor: &#39;gray&#39;,fontSize:20px}</code>，按下按鍵時呼叫<code>Update</code>的方法後<code>activeColor</code>和<code>fontSize</code>的值會被變更為<code>Update</code>方法裡的設定：<code>pink</code>和<code>30px</code>。</p><p>HTML 的部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>class綁定: :class='xxx'<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"classC"</span> <span class="attr">:class</span>=<span class="string">"myClass"</span>&gt;</span>xxx是字元串<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"&#123;classA:isActive, classB:!isActive&#125;"</span>&gt;</span>xxx是物件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"[myClass,hasClass ]"</span>&gt;</span>xxx是陣列<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 比較少用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"Update"</span>&gt;</span>Update<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>style綁定<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">"&#123;color: activeColor, fontSize: fontSize + 'px'&#125;"</span>&gt;</span></span><br><span class="line">    color: activeColor, fontSize: fontSize + 'px'</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- activeColor 和 fontSize 需要去 data 初始化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>VueJs 的部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    myClass: <span class="string">'classA'</span>,</span><br><span class="line">    hasClass: <span class="string">'classB'</span>,</span><br><span class="line">    isActive: <span class="literal">false</span>,</span><br><span class="line">    activeColor: <span class="string">'gray'</span>,</span><br><span class="line">    fontSize: <span class="number">20</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    Update() &#123;</span><br><span class="line">      <span class="keyword">this</span>.myClass = <span class="keyword">this</span>.hasClass;</span><br><span class="line">      <span class="keyword">this</span>.isActive = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">this</span>.activeColor = <span class="string">'pink'</span>;</span><br><span class="line">      <span class="keyword">this</span>.fontSize = <span class="number">30</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Class 和 Style 的綁定對於控制樣式或狀態切換來說是很方便的，在處理許多互動狀態的設計上應該會蠻常用到的。</p><p>今天是情人節，無論有沒有情人，我們都要愛自己，才會有能力愛人或是吸引其他人來愛你。<br>十幾年前曾經聽過一句頗浪漫的情人節話語：「如果我的生活是 HTML，你(妳)就是我的 CSS。」當時 JavaScript 還沒那麼重要，不過以現在的發展狀況而言，JavaScript，它是我的精神伴侶。<br>情人節快樂！</p><p>補充：<br>另一個 Vue Master 的課程裡有看到樣式綁定的方法，補充當時做的筆記：</p><h2 id="Class-Bindings-樣式類別綁定"><a href="#Class-Bindings-樣式類別綁定" class="headerlink" title="Class Bindings 樣式類別綁定"></a>Class Bindings 樣式類別綁定</h2><p>綁定 style 的方式有以下幾種</p><h3 id="第一種，以語法糖的方式在-html-裡做-data-和樣式的繫結"><a href="#第一種，以語法糖的方式在-html-裡做-data-和樣式的繫結" class="headerlink" title="第一種，以語法糖的方式在 html 裡做 data 和樣式的繫結"></a>第一種，以語法糖的方式在 html 裡做 data 和樣式的繫結</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">"&#123;color:color&#125;"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">"&#123;fontSize:fontSize&#125;"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    color: <span class="string">'reg'</span>;</span></span><br><span class="line"><span class="javascript">    fontSize: <span class="string">'13px'</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="第二種，以物件的方式"><a href="#第二種，以物件的方式" class="headerlink" title="第二種，以物件的方式"></a>第二種，以物件的方式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">:style</span>=<span class="string">"styleObject"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    styleObject: &#123;</span><br><span class="line"><span class="javascript">      color: <span class="string">'reg'</span>;</span></span><br><span class="line"><span class="javascript">      fontSize: <span class="string">'13px'</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="第三種，以陣列的方式"><a href="#第三種，以陣列的方式" class="headerlink" title="第三種，以陣列的方式"></a>第三種，以陣列的方式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">"[styleObject,styleObject2]"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  data:&#123;</span><br><span class="line">    styleObject: &#123;</span><br><span class="line"><span class="javascript">          color: <span class="string">'reg'</span>,</span></span><br><span class="line"><span class="javascript">          fontSize: <span class="string">'13px'</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        styleObject2: &#123;</span><br><span class="line"><span class="javascript">          margin: <span class="string">'5px'</span>,</span></span><br><span class="line"><span class="javascript">          padding: <span class="string">'20px'</span></span></span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="以布林值決定是否繫結與顯示樣式"><a href="#以布林值決定是否繫結與顯示樣式" class="headerlink" title="以布林值決定是否繫結與顯示樣式"></a>以布林值決定是否繫結與顯示樣式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"color-box"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:class</span>=<span class="string">"&#123;active: activeClass, 'text-danger': errorClass&#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  data:&#123;</span><br><span class="line"><span class="javascript">    activeClass:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">    errorClass:<span class="literal">false</span>,</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="物件-布林值方式"><a href="#物件-布林值方式" class="headerlink" title="物件 + 布林值方式"></a>物件 + 布林值方式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"classObject"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  data:&#123;</span><br><span class="line">    classObject:&#123;</span><br><span class="line"><span class="javascript">      active:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      danger:<span class="literal">false</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="陣列方式"><a href="#陣列方式" class="headerlink" title="陣列方式"></a>陣列方式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"[classObject, errorClass]"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  data:&#123;</span><br><span class="line"><span class="javascript">    activeClass:<span class="string">'active'</span>,</span></span><br><span class="line"><span class="javascript">    errorClass: <span class="string">'text-danger'</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="條件式"><a href="#條件式" class="headerlink" title="條件式"></a>條件式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"[isActive ? activeClass : '']"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  data:&#123;</span><br><span class="line"><span class="javascript">    isActive:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">    activeClass:<span class="string">'active'</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js computed &amp; watch 計算屬性與監視器</title>
      <link href="/tsuifei.github.io/Vue_02_computed_watch/"/>
      <url>/tsuifei.github.io/Vue_02_computed_watch/</url>
      
        <content type="html"><![CDATA[<p>昨天介紹了 VueJs 裡常用的模板語法，今天就來介紹在我們 <code>new Vue({ })</code>裡面會用到到的 computed(計算屬性)和 watch(監視器)</p><p>我們可以先來看一下範例：<a href="https://codepen.io/tsuifei/pen/qBZQWqE?editors=1010" target="_blank" rel="noopener">去 codepen 看看效果</a></p><p>同樣的以 cdn 的方式先引入<code>vue.js</code>。</p><p>前兩個是「姓」和「名」的輸入框<code>input</code>First Name 和 Last Name，先在實例裡的<code>data</code>初始化他們的值之後，就可以在各別的<code>input</code>和<code>p</code>標籤看到它們顯示出來，現在要來進行將「姓」和「名」合併，且可以透過這些<code>input</code>去直接更改已經初始化的值。</p><a id="more"></a><p>合併「姓」和「名」的三個輸入框<code>fullName</code>則是想做到讓姓和名可綁定，並顯示在輸入框裡。<br>前兩個是單向改變，也就是說在「姓」和「名」的輸入會影響 Full Name1 和 Full Name2，但改變 Full Name1 和 Full Name2 時「姓」和「名」的內容不會更動。<br>最後一個是雙向的，也就是說無論是「姓」和「名」的輸入或是 Full Name3 裡的更動，兩邊的內容都會一起變動。<br>這幾個輸入框都是用<code>v-model</code>來綁定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app2"</span>&gt;</span></span><br><span class="line">  First Name :</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"FirstName"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  Last Name :</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"LastName"</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--fullName1是根據fistName和lastName計算產生出來的--&gt;</span></span><br><span class="line">  Full Name1 (computed, sens unique ) :</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"full Name1"</span> <span class="attr">v-model</span>=<span class="string">"fullName1"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--fullName2是根據watch監看產生出來的--&gt;</span></span><br><span class="line">  Full Name2 (watch, deux sens) :</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"full Name"</span> <span class="attr">v-model</span>=<span class="string">"fullName2"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  Full Name3 (computed, deux sens) :</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"full Name2"</span> <span class="attr">v-model</span>=<span class="string">"fullName3"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 顯示觀察用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>firstName : &#123;&#123; firstName &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>lastName : &#123;&#123; lastName &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>fullName1 : &#123;&#123; fullName1 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>fullName2 : &#123;&#123; fullName2 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>fullName3 : &#123;&#123; fullName3 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先來說明這幾個在實例裡的屬性，這些屬性都是物件。</p><h3 id="computed-計算屬性"><a href="#computed-計算屬性" class="headerlink" title="computed: { } 計算屬性"></a>computed: { } 計算屬性</h3><p>computed 是實例裡的一個屬性，而它的值是個物件，在物件裡可能會有：</p><ol><li>多個方法的物件，對狀態屬性進行計算後，回傳一個新的資料, 供頁面獲取顯示。</li><li>自定義方法，一般情況下，相當是一個只能讀取的屬性，可利用 set/get 方法來實現屬性資料的計算讀取, 同時監視屬性資料的變化</li></ol><p>如何給物件定義 <code>get/set</code> 屬性 ?<br>在建立物件時指定:<code>·get name () {return xxx} / set name (value) {}</code><br>物件建立之後指定: <code>Object.defineProperty(obj, age, {get(){}, set(value){}})</code></p><p>在頁面中使用雙大括號，將「方法名」包起來顯示計算的結果。</p><h3 id="使用-computed-計算屬性的-get-set-方法雙向顯示和監視"><a href="#使用-computed-計算屬性的-get-set-方法雙向顯示和監視" class="headerlink" title="使用 computed 計算屬性的 get / set 方法雙向顯示和監視"></a>使用 computed 計算屬性的 get / set 方法雙向顯示和監視</h3><p>剛剛說的 Full Name3 可達到互相牽動的效果，就是用 computed 計算屬性裡的兩個 callback 函式 getter/setter 來做到。<br><code>get()</code>我們需要讀取當前屬性時呼叫。然後根據相關的資料計算並傳回當前屬性的值。<br><code>set(value)</code> 並不像字面上的意思，比較像是「監視」，而是當屬性值發生變化呼叫 set callback 函式，然後去更新相關的屬性資料。在這裏<code>value</code>即代表 Full Name3 最新的屬性值。</p><p>如果是以 computed 來計算屬性產生值，就不需要在<code>data</code>裡初始化值。所以我們也不需要在<code>data</code>裡初始化 Full Name3 的值。<br>計算屬性 computed 有個特性，它會在第一次計算時就將結果存在快取裡, 多次讀取也只執行一次 getter 計算，以節省效能。</p><h3 id="watch-監視器"><a href="#watch-監視器" class="headerlink" title="watch 監視器"></a>watch 監視器</h3><p>監視器的寫法有兩種：</p><ol><li>直接寫成實例的<code>watch</code>屬性物件，屬性的值為監聽的對象，值則 callback 函式，在函數內部進行計算。這個監聽屬性可包含多個屬性監視的物件，並分為一般監視和深度<code>deep</code>監視。</li><li>透過實例本身(vm)有的方法<code>$watch()</code>來監聽 <code>$watch</code>有兩個參數，第一個為要監聽的對象，第二參數為 callback 函式，在函數內部進行計算。<br>有沒覺得這兩種寫法大同小異？</li></ol><p>這兩種寫法的語法分別為：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line">xxx: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;&#125;</span><br><span class="line">xxx : &#123;</span><br><span class="line">deep : <span class="literal">true</span>,</span><br><span class="line">handler : fun(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line">vm.$watch(<span class="string">'xxx'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>所有 Vue 實例的方法，如 watch ，都可以在前面加個<code>$</code>字號，而在實例外取得，如上面<code>vm.$watch()</code>的用法。</p><p>我們再來看一下完整的程式碼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'A'</span>,</span><br><span class="line">    lastName: <span class="string">'B'</span>,</span><br><span class="line">    fullName2: <span class="string">'A-B'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 計算屬性配置：值為物件</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 什麼時候執行：初始化顯示/ 相關的data屬性資料發生變化</span></span><br><span class="line">    <span class="comment">// 計算並回傳目前屬性的值</span></span><br><span class="line">    fullName1() &#123;</span><br><span class="line">      <span class="comment">// 計算屬性中的一個方法，方法的回傳值作為屬性值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">'-'</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    fullName3: &#123;</span><br><span class="line">      <span class="comment">// 自定義物件，有兩個callback 函式 get, set(value)</span></span><br><span class="line">      <span class="comment">// 什麼時候用？ 當需要讀取當前屬性時呼叫。</span></span><br><span class="line">      <span class="comment">// 用來做什麼？ 根據相關的資料計算並傳回當前屬性的值</span></span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">'-'</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 什麼時候用？ 監視當前屬性的變化，當屬性值發生變化時呼叫。更新相關的資料屬性</span></span><br><span class="line">      <span class="comment">// 用來做什麼？ 根據相關的資料計算並傳回當前屬性的值</span></span><br><span class="line">      <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        <span class="comment">// value 是 fullName3 輸入的最新屬性值</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fullName3 set()'</span>, value);</span><br><span class="line">        <span class="comment">// 更新firstName和lastName</span></span><br><span class="line">        <span class="keyword">const</span> names = value.split(<span class="string">'-'</span>);</span><br><span class="line">        <span class="keyword">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.lastName = names[<span class="number">1</span>];</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 寫在vm 實例的監聽，叫配置監聽，另一種監聽方法使用vm的方法</span></span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// 要監聽哪個屬性？ 監聽變動時通知我們，使用callback 給我們最新的值</span></span><br><span class="line">    <span class="comment">// 也可以同時監聽未變化的與變化後的值，以參數帶入 callback</span></span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// firstName 發生了變化</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'watch firstName'</span>, value);</span><br><span class="line">      <span class="comment">// 更新 fullName2</span></span><br><span class="line">      <span class="keyword">this</span>.fullName2 = value + <span class="string">'-'</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 這段和下面用 vm.$watch() 寫的效果是一樣的。</span></span><br><span class="line">    <span class="comment">// lastName: function (value) &#123;</span></span><br><span class="line">    <span class="comment">//   this.fullName2 = this.firstName + '-' + value</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 實例的方法都是以 $ 開頭 第一參數監聽對象 第二參數callback函式</span></span><br><span class="line">vm.$watch(<span class="string">'lastName'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'watch lastName'</span>, value);</span><br><span class="line">  <span class="comment">// 更新 fullName2</span></span><br><span class="line">  <span class="keyword">this</span>.fullName2 = <span class="keyword">this</span>.firstName + <span class="string">' '</span> + value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="有趣的-callback-解釋"><a href="#有趣的-callback-解釋" class="headerlink" title="有趣的 callback 解釋"></a>有趣的 callback 解釋</h4><p>callback 函式需滿足三個條件： 1.你定義的 2.你沒有呼叫 3.但最終它執行了<br>callback 什麼時候用？ 呼叫函式的時候<br>用來做什麼？ 計算並回傳當前屬性的值</p><p>再接再厲～</p><p>參考：<br><a href="https://cn.vuejs.org/v2/api/#computed" target="_blank" rel="noopener">API — Vue.js</a><br><a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener">API — Vue.js</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js Template Syntax 模板語法</title>
      <link href="/tsuifei.github.io/Vue_01_Template_Syntax/"/>
      <url>/tsuifei.github.io/Vue_01_Template_Syntax/</url>
      
        <content type="html"><![CDATA[<p>VusJs 是個便利的框架，它的便利在於幫我們把一些較複雜的事情都先做好了，據說 Vue 的入門較簡單，單是也是會讓我們將 JS 武功廢掉的框架，還記得有位朋友說，他寫了一陣子 Vue 之後，幾乎 JS 的武功都廢了，聽起來蠻聳動的。所以一定要記住，時不常回來寫原生還是必要的。</p><p>這裡記錄一些學習上的筆記和用法，以便將來腦殘可回來補腦。</p><p>我們先以 CDN 的方式將 Vue.js 引入就可以用了，記得也要先創建一個 Vue 的實例來用，裡面會有所有控制與資料的部分。<br>接著，在 HTML 裡將要控制的部分以一個<code>&lt;div&gt;</code>包住，並給予 ID <code>&lt;div id=&quot;app&quot;&gt;</code>這個 <code>#app</code>就可以以標籤綁定資料的方式，和 Vue 的實例裡的資料做溝通。</p><a id="more"></a><h3 id="資料綁定"><a href="#資料綁定" class="headerlink" title="資料綁定 "></a>資料綁定 </h3><p>資料綁定最常用的是雙大括號，裡面的變數就是聯繫實例裡面<code>Data</code>物件裡的屬性資料。<br>我們如何使用它：</p><p>可以以 HTML 的形式來綁定如<code>&lt;p v-html=&quot;msg&quot;&gt;&lt;/p&gt;</code> (顯示 html 格式)<br>用 text 的形式來綁定如<code>&lt;p v-text=&quot;msg&quot;&gt;&lt;/p&gt;</code>(顯示純文字)<br>雙花括號不可直接用在 html 的屬性上，在需要用的情況下，可以用<code>v-bind</code>的方式如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:disabled</span>=<span class="string">"isDisabled"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接使用 JS 表達式，在雙大括號裡可以直接些三元運算子，甚至是直接用 JS 的內建函式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; isName ? Yes : No; &#125;&#125; or &#123;&#123; name .split('') .reverse() .join(''); &#125;&#125;</span><br></pre></td></tr></table></figure><p>必須寫在 Html 的屬性裡：<code>&lt;div v-bind:id=&quot;&#39;list-&#39; + id&quot;&gt;&lt;/div&gt;</code></p><p>我們想要在一個 input 裡即使顯示我們輸入的內容，在實例的<code>data</code>先準備好初始化的資料，在<code>input</code>裡，用指令<code>v-model</code>(資料)去綁住，然後再到要顯示的 html 裡，以雙花括號包住在<code>data</code>裡的某一屬性，就可以達到即使顯示的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>my name is &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"name"</span> <span class="attr">placeholder</span>=<span class="string">"Write your name"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在監聽事件的部分，可使用<code>v-on:click=&quot;方法名&quot;</code>去觸發想要做的事情或資料&gt;<br>&lt;button @click=”showHi(say)”&gt;click</p><p><a href="https://codepen.io/tsuifei/pen/oNXjGBY" target="_blank" rel="noopener">去 codepen 看看效果</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>my name is &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; name.toUpperCase() &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; isName ? `Your Name is $&#123;name&#125;` : `Name not good ou null`&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; name.split('').reverse().join('') &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind:name</span>=<span class="string">"'list-' + name + ' ' + say"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"name"</span> <span class="attr">placeholder</span>=<span class="string">"Write your name"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"imgUrl"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"showHi(say)"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在-Vue-的實例裡會有什麼？"><a href="#在-Vue-的實例裡會有什麼？" class="headerlink" title="在 Vue 的實例裡會有什麼？"></a>在 Vue 的實例裡會有什麼？</h2><p>在 vm 的實例裡，我們需要準備我們想對組件操控的方法和顯示的資料，當然不只這些，實例有點像是控制中心，在這裏控制 V:viem 和 M:model ，我們也成實例為 VM: viewModel。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>, <span class="comment">//  指定 DOM 標籤容器的選擇器，Vue 就會針對這個容器做管理</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="comment">// 物件，所有這個容器（組件）的資料來源，是初始化資料狀態的物件，vm 會自動擁有data 中所有屬性，在頁面中也可直接調用這些屬性。</span></span><br><span class="line">    name: <span class="string">'Tracy'</span>,</span><br><span class="line">    isName: <span class="literal">true</span>,</span><br><span class="line">    msg: <span class="string">'&lt;h2&gt;Today is good day&lt;/h2&gt;'</span>,</span><br><span class="line">    imgUrl: <span class="string">'https://cn.vuejs.org/images/logo.png'</span>,</span><br><span class="line">    say: <span class="string">'Hi Paris'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 這個組件會用到的方法，供頁面中的事件指令來綁定 callback</span></span><br><span class="line">    showHi(sayHi) &#123;</span><br><span class="line">      alert(sayHi);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="data"><a href="#data" class="headerlink" title="data: { }"></a>data: { }</h3><p>data 物件的屬性大多為初始化的屬性字面值。</p><h3 id="methods"><a href="#methods" class="headerlink" title="methods: { }"></a>methods: { }</h3><p>methods 裡面包含多個方法的物件，來提供給頁面中的<code>v-on</code>事件指令來綁定 callback 回調函式<br>callback 函式預設有 event 參數, 但也可以指定自己的參數<br>所有的方法由 vue 物件來呼叫, 調用 data 中的屬性直接使用 this.xxx</p><p>今天先寫到這裡，一定要堅持下去喔！</p><p>題外話，近日武漢肺肺炎的關係，開始關注一些中國的現狀，和中國朋友閒聊時，才知道真的是水深火熱的環境。<br>另如，我不解為何中國朋友都不太敢對自己的國家有所批評，台灣說的「批評求進步」簡直是讓自己陷入危險。上次看法國報導，記者試著採訪中國遊客，關於看到法輪功的感想，一團幾十個，沒有一個願意開口。後來朋友跟我說，如果從中國第一次出國，就要參加一種叫行前教育的活動，需要政府部門批准他們出去，那時工作人員會告誡他們不要把外面的信息帶回來。這可能也是很多海外華人不像多評論政治的原因。他去台灣的第一次是這麼要求，他的父母也是。</p><p>想想，生活在台灣真的還是件蠻幸福的事。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 基礎 物件篇</title>
      <link href="/tsuifei.github.io/JS_Basic_Object/"/>
      <url>/tsuifei.github.io/JS_Basic_Object/</url>
      
        <content type="html"><![CDATA[<blockquote><p>什麼是物件 Object？ 物件可以包山包海。</p></blockquote><p>物件是 JavaScript 中的參考資料型別，它擁有複合的值，可以儲存不同類型的值(value)，然後透過 Key 來取值。<br>Object 也可以看成是屬性的無序列集合，每個屬性都是一對 Key:value。物件除了可以擁有自己的屬性，還可以透過原型物件來繼承屬性。</p><p>在 JavaScript 的資料型別裡，除了<code>string</code>、<code>number</code>、<code>boolean</code>、<code>null</code>和<code>undefined</code>之外，其他都是物件型別。<br>物件以外的型別資料的值是無法修改與不可變的，我們稱為這類的資料型別為「基本型別」，「基本型別」的比較，是以「值」來比較，如果兩個變數的值相等，就會被視為這兩個變數是相等的。</p><a id="more"></a><p>物件是「參考資料型別」，它的值是被保存在記憶體裡的物件，當一個變數是物件（參考型別）時，實際上變數中保存的並不是這個物件本身，而是記憶體的位址。<br>當我們複製一個物件給另一變數時，這個變數會依照這個變數的參考值（記憶體的位址）給另一個變數參考，而不是複製物件，也就是說複製物件的值，會同時指向被複製的物件記憶體位址。也因此如果更動其中一個物件變數的內容，另一個物件變數內容也會一起更動。</p><p>在讀一些中文簡體的資料時，我們會看到類似：「简单来说栈内存用来保存变量和基本类型。堆内存用来保存对象」，用繁體的解釋是：基本型別是依照記憶體所存的值當依據，參考型別則是會先以記憶體位址為參考，才將裡面的值取出，但因為會參考同一個記憶體位址，所以找到的值也ㄧ樣。</p><h3 id="如何創建一個物件"><a href="#如何創建一個物件" class="headerlink" title="如何創建一個物件"></a>如何創建一個物件</h3><p>有兩種方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一種使用建構式：</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">"Tracy"</span>;</span><br><span class="line">obj.age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">// 第二種方法，也是我們較常用的方法，以 &#123;&#125; 表示物件。</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name = <span class="string">"Tracy"</span>;</span><br><span class="line">  age = <span class="number">18</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="物件取值與賦值的方法"><a href="#物件取值與賦值的方法" class="headerlink" title="物件取值與賦值的方法"></a>物件取值與賦值的方法</h2><ol><li>以物件名.屬性名 ex.<code>obj.name</code>，使用「點」</li><li>使用[] ex.<code>obj[&#39;屬性名&#39;]</code>，使用[中括號]</li></ol><p>和 Array 不同的是，Array 是以索引<code>index</code>和值<code>value</code>做配對，但 objet 是以鍵<code>Key</code>和值<code>Valur</code>配對使用。</p><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p><code>let arr = [&quot;Tracy&quot;, 42, &quot;Paris&quot;, &quot;Taiwan&quot; ];</code></p><table><thead><tr><th>index</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>value</td><td>Tracy</td><td>42</td><td>Paris</td><td>Taiwan</td></tr></tbody></table><p>取值的方法：<code>arr[0]</code></p><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p><code>let obj= { name : &quot;Tracy&quot;, age: 42, city: &quot;Paris&quot;, pays: &quot;Taiwan&quot; }</code></p><table><thead><tr><th>Key</th><th>name</th><th>age</th><th>city</th><th>pays</th></tr></thead><tbody><tr><td>value</td><td>Tracy</td><td>42</td><td>Paris</td><td>Taiwan</td></tr></tbody></table><p>取值的方法：<code>obj.name</code></p><p>Array 和 Object 最大的不同是 Array 是有順序的，會隨著索引值的順序，而 Object 的值是跟著 Key，所以即使變換順序也不會受影響。</p><p>Object 取值的 ==.== <code>obj.name</code>如同中文的「的」，我們在其他地方也常用的這個點。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id=&quot;alink&quot; href=&quot;https://google.com&quot; target=&quot;_blank&quot;&gt; c&apos;est un lien &lt;/a&gt;</span><br></pre></td></tr></table></figure><p>想要抓取 DOM 的值也可利用此一方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> attr = <span class="built_in">document</span>.getElementById(<span class="string">'alink'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(attr.href); <span class="comment">// 會抓到 &lt;a&gt; 裡的 href 這個屬性的值</span></span><br><span class="line"><span class="comment">// 修改的方法</span></span><br><span class="line">attr.href = <span class="string">'www.tsuifei.com'</span>;</span><br></pre></td></tr></table></figure><p>如果把上述的 HTML<code>&lt;a&gt;</code>改為物件，即是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  id: <span class="string">'alink'</span>,</span><br><span class="line">  href: <span class="string">'https://google.com'</span>,</span><br><span class="line">  target: <span class="string">'_blank'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改物件裡的某一值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Tracy'</span>,</span><br><span class="line">  age: <span class="number">42</span>,</span><br><span class="line">  city: <span class="string">'Paris'</span>,</span><br><span class="line">  pays: <span class="string">'Taiwan'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.age = <span class="number">50</span>; <span class="comment">// 重新給值</span></span><br></pre></td></tr></table></figure><h2 id="常見的物件使用方式"><a href="#常見的物件使用方式" class="headerlink" title="常見的物件使用方式"></a>常見的物件使用方式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacBook Pro 入手安裝紀錄</title>
      <link href="/tsuifei.github.io/Mac_for_my_new_MacBookPro/"/>
      <url>/tsuifei.github.io/Mac_for_my_new_MacBookPro/</url>
      
        <content type="html"><![CDATA[<blockquote><p>衣服和褲子總要穿穿才會合身，何況是電腦這麼神聖的東西。</p></blockquote><p>這篇是很久以前紀錄的，如果 2019 年八月買的，到現在也已經七個月了，但是很神奇的是，從舊電腦換到新電腦，幾乎是有種無痛轉移的狀態，雖然是新電腦，但其實頗懷念舊的。</p><p>上一台舊的 MacBook Pro 是已經停產的 17 吋筆電，很重但很好用，我用她做所有的事情，且從 2001 年入手到換新電腦，她都很良善的陪著我，隨然中後期她的一邊喇吧不再動了，但是除此之外一切都很完美，直到近一兩年，安裝新的系統，對她而言開始覺得很吃力，負荷不過來，所以才有想要換新電腦的念頭。</p><p>原本以為寫程式是不太需要記憶體或空間的，但是學了才知道，要安裝一大堆的編譯器和套件，也頗重的。尤其套件從網站上下載下來，有時會達到幾百 M ，這時她就會氣喘如牛了。但是一台筆電陪了我近九年，也真的是算辛苦了，希望新的 MacBook Pro 也可以陪我長長久久，而我也會很珍惜與保護她的。</p><a id="more"></a><p>由於在法國買的鍵盤超難打 code ，所以就決定回來台灣買。入手的時候在好想工作室 trining，所以也就得到許多人的幫助與建議，且還把部落格給架了起來。以前架站都是用 Wordpress，這次安裝在 github 上倍感新鮮。</p><h2 id="安裝-Hexo-紀錄"><a href="#安裝-Hexo-紀錄" class="headerlink" title="安裝 Hexo 紀錄"></a>安裝 Hexo 紀錄</h2><p>而在本機安裝 hexo 使<code>npm install -g hexo-cli</code>卻發現權限不足的問題，記得 Chris 說過，盡量不要用<code>sudo</code>這個最高權限安裝，所以來找一下其他方式，找到這篇：<a href="https://stackoverflow.com/questions/33725639/npm-install-g-less-does-not-work" target="_blank" rel="noopener">npm install -g less does not work</a> 裡面也說盡量不要用<code>sudo</code>安裝，所以想來仔細了解一下。</p><p>此篇寫著： Using sudo is not recommended. It may give you permission issue later. While the above works, I am not a fan of changing folders owned by root to be writable for users, although it may only be an issue with multiple users. To work around that, you could use a group, with ‘npm users’ but that is also more administrative overhead. See here for the options to deal with permissions from the documentation: <a href="https://docs.npmjs.com/getting-started/fixing-npm-permissions" target="_blank" rel="noopener">https://docs.npmjs.com/getting-started/fixing-npm-permissions</a></p><p>所以他用以下的方法：<br>I would go for option 2:</p><p>To minimize the chance of permissions errors, you can configure npm to use a different directory. In this example, it will be a hidden directory on your home folder. 要最小化權限錯誤的可能性，可以將 npm 配置為使用其他目錄。在此示例中，它將是主文件夾中的隱藏目錄。</p><p>Make a directory for global installations:<br>為全局安裝創建一個目錄：<br><code>mkdir ~/.npm-global</code></p><p>Configure npm to use the new directory path:<br>配置 npm 以使用新的目錄路徑：<br><code>npm config set prefix &#39;~/.npm-global&#39;</code></p><p>Open or create a <del>/.profile file and add this line:<br>打開或創建一個〜/ .profile 文件並添加以下行：<br>`export PATH=</del>/.npm-global/bin:$PATH`<br>Ps.發現自己有一個.bash_profile 所以就把以上這行存在.bash_profile，就解決了。</p><p>Back on the command line, update your system variables:<br>返回命令行，更新系統變量：<br><code>source ~/.profile</code></p><p>Test: Download a package globally without using sudo.<br>測試：在不使用 sudo 的情況下全局下載軟件包。<br><code>npm install -g jshint</code><br>==有試成功 安裝 hexo OK 但要用 hexo 時又不行==</p><p>If still show permission error run (mac os):<br>如果仍顯示權限錯誤運行（mac os）：<br><code>sudo chown -R $USER ~/.npm-global</code></p><p>This works with the default ubuntu install of:<br>這適用於默認的 ubuntu 安裝：==(oz:表示還是用 sodu 吧…)==<br><code>sudo apt-get install nodejs npm</code></p><p>I recommend nvm if you want more flexibility in managing versions: <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">https://github.com/creationix/nvm</a><br>如果您想要更靈活地管理版本，我建議使用 nvm：</p><p>On MacOS use brew, it should work without sudo out of the box if you’re on a recent npm version. Enjoy :)<br>在 MacOS 上使用 brew，如果您使用的是最近的 npm 版本，它應該可以在沒有開箱即用的情況下使用。請享用 ：）</p><h2 id="幾個開發工具介紹"><a href="#幾個開發工具介紹" class="headerlink" title="幾個開發工具介紹"></a>幾個開發工具介紹</h2><p><strong>brew</strong> : MacOs 主要的套件管理工具 (The missing package manager for macOS)。用來補足 macOS 所欠缺的套件管理工具。<br><a href="https://brew.sh/index_zh-tw.html" target="_blank" rel="noopener">官網</a> | <a href="https://mt116.blogspot.com/2017/11/homebrew.html" target="_blank" rel="noopener">介紹</a></p><p><strong>NPM</strong> 是隨同 NodeJS 一起安裝的包管理工具，能解決 NodeJS 程式碼部署上的很多問題。<br><a href="https://www.npmjs.com/" target="_blank" rel="noopener">官網</a> | <a href="https://www.slideshare.net/wantingj/npm-46801372" target="_blank" rel="noopener">套件管理 &amp; 常用開發工具介紹</a></p><p><strong>Node Version Manager</strong> 是 Node.js 版本管理的工具。<br>照官網安裝後，仍要去 .bash_profile 改路徑與環境變數。<br><a href="https://github.com/nvm-sh/nvm/blob/master/README.md" target="_blank" rel="noopener">官網</a>｜ <a href="https://ithelp.ithome.com.tw/articles/10184980" target="_blank" rel="noopener">教學</a></p><p>Mac 的環境變數相關文章<br><a href="https://codertw.com/ios/96761/" target="_blank" rel="noopener">Mac 環境變數小記</a></p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 VSCode 裡使用 ESLint, Prettier &amp; Airbnb Style Guide</title>
      <link href="/tsuifei.github.io/VSCode_ESLint_Setup/"/>
      <url>/tsuifei.github.io/VSCode_ESLint_Setup/</url>
      
        <content type="html"><![CDATA[<blockquote><p>想要矯正儀容端正，看來也沒那麼簡單。</p></blockquote><p>前陣子面試時，有被問到有沒有用 ESLint 來讓自己的寫碼風格統一些，被問了才想到，在舊電腦時還有用這個在 VSCode 裡的外掛，換了電腦就幾乎忘記它了，再加上將來開發專案時，也希望自己在寫碼的統一風格上做改善，所以想說也應該再來重新部署一次，可以以 Airbnb 的寫作風格為榜樣的規則，訓練自己養成專業開發人員應有的寫作習慣。</p><p>這次的部署主要參考很喜歡的老師 Traversy 所放在 Youtube 的影片，再參考其他大神的文章當輔助，試著了解每一個步驟或指令背後的意義，這樣應該比較可以理解原理，將來遇到問題比較有可能解決。</p><a id="more"></a><p><a href="https://www.youtube.com/watch?v=SydnKbGc7W8" target="_blank" rel="noopener">VSCode ESLint, Prettier &amp; Airbnb Style Guide Setup</a></p><p>使用 ESLint 主要目的是確保將來自己寫的程式能夠較為統一風格與簡潔，請跟著以下的步驟來設定，需要注意的是，這次的設定並沒有考慮到實用其他框架時所需要的套件，如果到時候以框架開發，也應該把需要的套件安裝好。</p><h3 id="第一部，先去暸解要安裝的套件以及規則"><a href="#第一部，先去暸解要安裝的套件以及規則" class="headerlink" title="第一部，先去暸解要安裝的套件以及規則"></a>第一部，先去暸解要安裝的套件以及規則</h3><p>ESLint 官網：<a href="https://eslint.org/" target="_blank" rel="noopener">ESLint - Pluggable JavaScript linter</a><br>ESLint 中文：<a href="https://cn.eslint.org/docs/user-guide/configuring" target="_blank" rel="noopener">Configuring ESLint - ESLint 中文</a><br>ESLint 規則：<a href="https://eslint.org/docs/rules/" target="_blank" rel="noopener">List of available rules - ESLint - Pluggable JavaScript linter</a></p><p>Airbnb 的寫作規範：<a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">airbnb/javascript: JavaScript Style Guide</a></p><p>安裝 npm 的 Airbnb 設置套件：<a href="https://www.npmjs.com/package/eslint-config-airbnb" target="_blank" rel="noopener">eslint-config-airbnb - npm</a>將遵循 Airbnb 這個套件的規則，再依自定義配置文件調整。</p><p>在 VSCode 安裝 prettier 外掛<br><a href="https://prettier.io/" target="_blank" rel="noopener">Prettier · Opinionated Code Formatter</a></p><h4 id="如何查找資料？"><a href="#如何查找資料？" class="headerlink" title="如何查找資料？"></a>如何查找資料？</h4><p>例如看 no-empty 這條<a href="https://eslint.org/docs/rules/no-empty" target="_blank" rel="noopener">no-empty - Rules - ESLint - Pluggable JavaScript linter</a><br>會告訴我們如何修正不當的寫法，在這裡可找得到每條規則的範例，可看出什麼寫法是允許的，什麼是不允許的。如果要練習，也可以在部署完成之後，直接把錯誤的範例貼到自己的檔案上來一一修正，相信會更清楚寫作的規則。</p><h3 id="第二步去-VSCODE-設置"><a href="#第二步去-VSCODE-設置" class="headerlink" title="第二步去 VSCODE 設置"></a>第二步去 VSCODE 設置</h3><ol><li>先確定是否有安裝這兩個套件</li></ol><ul><li>ESLint (by Dirk Baeumer)</li><li>Prettier - Code formatter (by Esben Petersen)</li></ul><ol start="2"><li><p>接下來是全局的設置，以<code>command + ,</code>叫出 VSCode 的設定，輸入<code>format on save</code> 並將這項打勾。也就是說如果我儲存檔案時，如果忘記打分號，VSCode 會自動幫我補上去。</p></li><li><p>在 VSCode 的設定尋找<code>Prettier</code>再找到<code>Prettier: Single Quote</code>打勾，表示如果我設定單引號，VSCode 在儲存時會幫我們自動更正; 尋找<code>Prettier: Semi</code> 打勾。</p></li></ol><h3 id="第三步-安裝相關套件-4-23"><a href="#第三步-安裝相關套件-4-23" class="headerlink" title="第三步 安裝相關套件(4:23)"></a>第三步 安裝相關套件(4:23)</h3><p>1.<code>npm init -y</code> 會自動增加一個<code>package.json</code>配置檔案。</p><p>2.把需要的套件都先安裝好，指令：<code>npm i -D eslint prettier eslint-plugin-prettier eslint-config-prettier eslint-plugin-node eslint-config-node</code>執行後等待這些套件安裝完畢。</p><p>在安裝這些套件時，最好也可以試著了解每個指令的意義，請參閱：<a href="http://dreamerslab.com/blog/tw/npm-basic-commands/" target="_blank" rel="noopener">npm 基本指令</a></p><h3 id="第四步-安裝-Airbnb-風格指南"><a href="#第四步-安裝-Airbnb-風格指南" class="headerlink" title="第四步 安裝 Airbnb 風格指南"></a>第四步 安裝 Airbnb 風格指南</h3><p>Airbnb 的寫作風格一直是大家推崇的，就連命名規則據說也很清楚，應該是值得來好好看看。我們先至 Airbnb 的 <a href="https://www.npmjs.com/package/eslint-config-airbnb" target="_blank" rel="noopener">eslint-config-airbnb - npm</a> 上面找到安裝指令：<code>npx install-peerdeps --dev eslint-config-airbnb</code>，再到終端機去執行安裝它。</p><h3 id="第五步-手動創建並設置-Prettier、eslint"><a href="#第五步-手動創建並設置-Prettier、eslint" class="headerlink" title="第五步 手動創建並設置 Prettier、eslint"></a>第五步 手動創建並設置 Prettier、eslint</h3><p>手動建立兩個文件<code>.eslintrc</code> 與 <code>.prettierrc</code> 的設定檔到專案的根目錄。內容如下，最好是先建立好，之後每個專案直接拷貝即可。如果不用手動設置，也可以用自動的方式生成（在第六步）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .prettierrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"singleQuote"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"trailingComma"</span>: <span class="string">"es5"</span>,</span><br><span class="line">  <span class="string">"semi"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ”字串使用單引號”、“物件字面定義統一加上最後逗號”、“不使用分號作為語句結尾”</span></span><br></pre></td></tr></table></figure><p>可以去<a href="https://prettier.io/docs/en/options.html" target="_blank" rel="noopener">Options · Prettier</a>找更多的設置，並依自己的需求去<code>.prettierrc</code>訂定規則。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.eslintrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"env"</span>: &#123;</span><br><span class="line">    <span class="string">"node"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"es6"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"jest"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"extends"</span>: <span class="string">"react-app"</span>,</span><br><span class="line">  <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"prettier"</span>],</span><br><span class="line">  <span class="string">"rules"</span>: &#123;</span><br><span class="line">    <span class="string">"prettier/prettier"</span>: <span class="string">"error"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第六步-安裝-eslint-與初始化配置"><a href="#第六步-安裝-eslint-與初始化配置" class="headerlink" title="第六步 安裝 eslint 與初始化配置"></a>第六步 安裝 eslint 與初始化配置</h3><p><strong>安裝套件的方式自動生成設定檔</strong>如果用這方式就會需要全局 Global 最高權限去設定它（不建議）。指令：<code>sudo npm i -g eslint</code>。如果是安裝到<strong>Global</strong>，完成就可以直接以初始化的方式去自動產生設定檔。<br>指令：<code>eslint --init</code>。輸入後回答一連串的設定問題後，就會自動產生一個<code>eslintrc.json</code>的設定檔了。</p><p>如果只想要安裝在開發的專案中就選擇<code>npm install eslint --save-dev</code><br>如果是在<strong>專案</strong>裡，可以執行 <code>./node_modules/.bin/eslint --init</code>去初始化專案的 ESLint。</p><h4 id="初始化的選項"><a href="#初始化的選項" class="headerlink" title="初始化的選項"></a>初始化的選項</h4><p>在初始化時，ESLint 會以詢問方式請我們選擇，再將這些我們選擇的設定彙整到<code>eslintrc.json</code>去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">How would you like to use ESLint? <span class="comment">// 你想使用 ESLint 來做什麼？</span></span><br><span class="line">- To check syntax, find problems, and enforce code style <span class="comment">//檢查語法、找出問題和強制執行編碼風格。</span></span><br><span class="line"></span><br><span class="line">What type <span class="keyword">of</span> modules does your project use? <span class="comment">// 該專案是用什麼方式導入模組？</span></span><br><span class="line">- JavaScript modules (<span class="keyword">import</span>/<span class="keyword">export</span>) <span class="comment">// 使用 import/export</span></span><br><span class="line"></span><br><span class="line">Which framework does your project use? <span class="comment">// 在專案裡用了哪個框架？</span></span><br><span class="line">- React <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">Does your project use TypeScript? No <span class="comment">// 該專案有使用 TypeScript 嗎？</span></span><br><span class="line">- No</span><br><span class="line"></span><br><span class="line">Where does your code run? <span class="comment">// 想在哪個執行環境下使用？</span></span><br><span class="line">- Browser</span><br><span class="line"></span><br><span class="line">How would you like to define a style <span class="keyword">for</span> your project? <span class="comment">// 該如何定義專案中的編碼風格？</span></span><br><span class="line">- Use a popular style guide</span><br><span class="line">- Airbnb: https:<span class="comment">//github.com/airbnb/javascript</span></span><br><span class="line"></span><br><span class="line">What format <span class="keyword">do</span> you want your config file to be <span class="keyword">in</span>? <span class="comment">// 用什麼檔案格式設置？</span></span><br><span class="line">- <span class="built_in">JSON</span> <span class="comment">// 下次可選 Javascript 格式</span></span><br><span class="line"></span><br><span class="line">What style <span class="keyword">of</span> indentation <span class="keyword">do</span> you use? <span class="comment">// 使用哪種縮進樣式？</span></span><br><span class="line">- Tabs</span><br><span class="line"></span><br><span class="line">What quotes <span class="keyword">do</span> you use <span class="keyword">for</span> strings? <span class="comment">// 字符串使用什麼引號？</span></span><br><span class="line">- Double <span class="comment">//雙</span></span><br><span class="line"></span><br><span class="line">What line endings <span class="keyword">do</span> you use? <span class="comment">// 使用什麼行尾？</span></span><br><span class="line">- Unix</span><br><span class="line"></span><br><span class="line">Do you <span class="built_in">require</span> semicolons? <span class="comment">// 結尾使用分號嗎？</span></span><br><span class="line">- No</span><br><span class="line"></span><br><span class="line">Checking peerDependencies <span class="keyword">of</span> eslint-config-airbnb@latest <span class="comment">// 確認是否有這幾個設定檔</span></span><br><span class="line">Would you like to install them now <span class="keyword">with</span> npm? <span class="comment">// 要立即使用npm安裝它們嗎？</span></span><br><span class="line">- Y</span><br></pre></td></tr></table></figure><p>設定完成後，會自動生成剛剛選的設置格式<code>json</code>而產生<code>.eslintrc.json</code></p><h3 id="第七步-配置完成使用方式"><a href="#第七步-配置完成使用方式" class="headerlink" title="第七步 配置完成使用方式"></a>第七步 配置完成使用方式</h3><p>配置完成後，在終端機旁的分頁會多一個<code>PROBLEMS 問題</code>，在所有這個檔案夾裡的文件就會依循 ESLint 給的規則而來給予提示，顯示在問題分頁裡了。<br>如果有看不懂的錯誤訊息，可以再回頭去<a href="https://eslint.org/docs/rules/" target="_blank" rel="noopener">ESLint</a>以關鍵字搜尋方式，搜尋到說明、參照範例，會比較清楚需要修正的部分。</p><h3 id="不想使用-Airbnb-的風格該如何設置？（10-22）"><a href="#不想使用-Airbnb-的風格該如何設置？（10-22）" class="headerlink" title="不想使用 Airbnb 的風格該如何設置？（10:22）"></a>不想使用 Airbnb 的風格該如何設置？（10:22）</h3><p>如果不想以 Airbnb 的風格修正功能，可以打開第六步自動部署 ESLint 所自動產生<code>eslintrc.json</code>來調整設置。<br>將<code>eslintrc.json</code>的內容改成大概是這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"extends"</span>: [</span><br><span class="line">        <span class="string">"airbnb"</span>,</span><br><span class="line">        <span class="string">"prettier"</span></span><br><span class="line">    ],</span><br><span class="line">   <span class="string">"plugins"</span>: [</span><br><span class="line">        <span class="string">"prettier"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"rules"</span>: &#123;</span><br><span class="line">        <span class="string">"prettier/prettier"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="string">"No-unused-vars"</span>: <span class="string">"warn"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引入-express-套件"><a href="#引入-express-套件" class="headerlink" title="引入 express 套件"></a>引入 express 套件</h3><p>在開發如 React 或 Node 專案時，常需要引入不同的函式庫，就需要 Express 套件。<br>指令<code>npm i express</code></p><h3 id="可針客製化調整規則-12-37"><a href="#可針客製化調整規則-12-37" class="headerlink" title="可針客製化調整規則(12:37)"></a>可針客製化調整規則(12:37)</h3><p>如果不希望 ESLint 一直是顯示錯誤，也可以針對某個錯誤標籤設定顯示的方式，在這裏我們把原本沒有宣告變數的「錯誤」提示改成「警告」級別。<br>可在<code>eslintrc.json</code>將 rules 修改為</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"rules"</span>: &#123;</span><br><span class="line">        <span class="string">"No-unused-vars"</span>: <span class="string">"warn"</span> <span class="comment">// 不使用的變數</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我們在程式裡使用<code>console.log()</code>通常是來除錯，但是 ESLint 卻會警告我們不要用它，我們也可以在<code>eslintrc.json</code>修改規則，在<code>rules</code>增加<code>&quot;no-console&quot;:&quot;off&quot;</code>即可使用<code>console.log()</code>而不出現警告提示。</p><p>如果希望 ESLint 提醒我們，使用我們想要的字串用單括號包覆，也可在<code>eslintrc.json</code>的<code>rules</code>增加<code>&quot;prettier/prettier&quot;: &quot;error&quot;,</code>這樣如果我們用雙括號包字串就會出現[錯誤]提示。</p><p>ESLint 會提示我們要給函式命名，但當我們使用箭頭函式，沒有函式名時，ESLint 就會提示，所以可以在<code>rules</code>加上增加<code>&quot;func-names&quot;:&quot;off&quot;</code>就可使用箭頭函式了。</p><p>還有許多可調整的部分，在此不一一說明，可依 ESLint 出現的提示做更細部的修改，如<code>&quot;no-process&quot;:&quot;off&quot;</code>、<code>&quot;object-shorthand&quot;:&quot;off&quot;</code>、<code>&quot;class-methods-use-this&quot;:&quot;off&quot;</code>，可以修正到自己滿意的狀態，開發會變得更順暢些。</p><p>剛開始使用時勢必會出現義大堆的錯誤或警告提示，但只要慢慢修正、慢慢將好習慣養成，相信將來寫作起來也會越來越簡潔有風格呢～</p><p>在安裝時難免產生疑惑，參考了以下這幾篇文章<br>參考：<br><a href="https://wcc723.github.io/tool/2017/11/09/coding-style/" target="_blank" rel="noopener">在 VSCode 啟用程式碼規範工具 (ESLint)</a><br><a href="https://eddychang.me/react-native-eslint-prettier/" target="_blank" rel="noopener">在 VSCode 中的 React Native 專案設定 ESLint 與 Prettier</a><br><a href="https://ithelp.ithome.com.tw/articles/10215259" target="_blank" rel="noopener">整齊的程式，讓看的人長命百歲，給我用 ESLint</a></p>]]></content>
      
      
      <categories>
          
          <category> VSCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
            <tag> ESLint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuejs 線上問答題</title>
      <link href="/tsuifei.github.io/Vue_Test_QA/"/>
      <url>/tsuifei.github.io/Vue_Test_QA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>只要你的考試成績好，就可以得到入門票一張</p></blockquote><p>在法國，應徵前端工程師的職位通常需要下列幾個程序：<br>第一關：人資的電話面試，在電話裡需要大約介紹一下自己的背景，以及自己的工作經歷，接著就是對方的發問，為什麼想應徵這份工作，或是對公司有疑惑也可提問等等。<br>第二關：技術執行長的電話面試，會詢問較多細節，對技術的看法，與團隊合作的細節，介紹公司負責部門的規模和人員、工作分配，當然我們也可以發問。<br>第二關：技術測驗，這有可能是面對面的測驗，寫白板、寫函式、線上測驗都有，但有時也很有可能寄給你連結，請線上直接作答。<br>第四關：直接來公司，最後一次面試，有可能是將來的主管和同事一起面試你。</p><a id="more"></a><p>以下是網路上的一些技術問題，平常多做做，也可測驗自己對某一主題的熟悉度。<br>自己翻譯了一下這些題目，用法文讀起來有時還是卡卡的，翻譯成中文希望還算順暢，感謝 Chris 的中文題目修正。<br>我會先把正確答案放在最底下，可以先試著作答在看答案喔。</p><h2 id="Quiz-Vue-js-基礎"><a href="#Quiz-Vue-js-基礎" class="headerlink" title="Quiz Vue.js 基礎"></a>Quiz Vue.js 基礎</h2><p><strong>是誰創造了VueJs ?</strong></p><ul><li><input disabled type="checkbox"> Robert Vue</li><li><input disabled type="checkbox"> Evan You</li><li><input disabled type="checkbox"> Mark Zuckerberg</li><li><input disabled type="checkbox"> Nicolas Cage</li></ul><hr><p><strong>定義 Vue Component 的3個部分是什麼？</strong></p><ul><li><input disabled type="checkbox"> script, template, methods</li><li><input disabled type="checkbox"> template, style, script</li><li><input disabled type="checkbox"> script, template, css</li></ul><hr><p><strong>我們如何將資料從父層 Component 傳遞到子層 Component ？</strong></p><ul><li><input disabled type="checkbox"> 透過 鏈接屬性</li><li><input disabled type="checkbox"> 透過 callback</li><li><input disabled type="checkbox"> 透過 屬性 data-</li><li><input disabled type="checkbox"> 透過 prop</li></ul><hr><p><strong>我們能否不靠 Babel 編譯的情況，單獨使用 Vue (script src)？</strong></p><ul><li><input disabled type="checkbox"> 可</li><li><input disabled type="checkbox"> 不可</li><li><input disabled type="checkbox"> 使用 jQuery 的情況下</li></ul><hr><p><strong>用動態傳值語法，將<code>kiwi</code>給<code>prop</code>的寫法？</strong></p><ul><li><input disabled type="checkbox"> v-bind:kiwi=”kiwi”</li><li><input disabled type="checkbox"> v-key:kiwi=”kiwi”</li><li><input disabled type="checkbox"> v-model=”kiwi”</li></ul><hr><p><strong>Vue 的哪個套件可以在所有 component 之間共享資料？</strong></p><ul><li><input disabled type="checkbox"> ShareData</li><li><input disabled type="checkbox"> Vuex</li><li><input disabled type="checkbox"> DataLoader</li><li><input disabled type="checkbox"> DataStore</li></ul><hr><p><strong>使用<code>v-for</code> 建立 loop 時，必要的屬性是什麼？</strong></p><ul><li><input disabled type="checkbox"> v-id</li><li><input disabled type="checkbox"> v-key</li><li><input disabled type="checkbox"> v-loop</li><li><input disabled type="checkbox"> v-while</li></ul><hr><p><strong>哪一個語法可以 route 到另一個 vue component？</strong></p><ul><li><input disabled type="checkbox"> this.$router.push(url)</li><li><input disabled type="checkbox"> this.$router.go(url)</li><li><input disabled type="checkbox"> this.$router.change(url)</li></ul><hr><p><strong>我們如何在資料的變化的同時觸發一個動作？</strong></p><ul><li><input disabled type="checkbox"> 使用 MutationObserver</li><li><input disabled type="checkbox"> 在 methods 使用 setInterval</li><li><input disabled type="checkbox"> 使用 watch</li></ul><hr><p><strong>哪一個 directive (vue 的指令，ex: <code>v-for</code>, <code>v-model</code>) 將輸入欄位和 component 的 data 關聯在一起？</strong></p><ul><li><input disabled type="checkbox"> v-model</li><li><input disabled type="checkbox"> v-bind</li><li><input disabled type="checkbox"> v-store</li><li><input disabled type="checkbox"> v-input</li></ul><hr><h2 id="Quiz-Vue-js-中等程度"><a href="#Quiz-Vue-js-中等程度" class="headerlink" title="Quiz Vue.js 中等程度"></a>Quiz Vue.js 中等程度</h2><p><strong>哪個 method 可以確保 dom 已完成更新才執行？</strong></p><ul><li><input disabled type="checkbox"> Vue.sync</li><li><input disabled type="checkbox"> Vue.nextTick</li><li><input disabled type="checkbox"> Vue.refresh</li><li><input disabled type="checkbox"> Vue.await</li></ul><hr><p><strong>如何使用<code>Vue</code>方法（ component 的功能）訪問本機DOM的元素？</strong></p><ul><li><input disabled type="checkbox"> 透過 v-node et un callback</li><li><input disabled type="checkbox"> 透過 id 屬性與 document.getElementById</li><li><input disabled type="checkbox"> 透過 v-ref</li></ul><hr><p><strong>我們如何從由<code>“document /：id”</code>路由解釋的URL獲取<code>“id”</code>參數？</strong></p><ul><li><input disabled type="checkbox"> this.$route.params.id</li><li><input disabled type="checkbox"> this.$route.vars[‘id’]</li><li><input disabled type="checkbox"> this.$route.query.id</li><li><input disabled type="checkbox"> this.$route.document.id</li></ul><hr><p><strong>哪些指令不應混在同一元素或 component 上？</strong></p><ul><li><input disabled type="checkbox"> v-if et v-bind</li><li><input disabled type="checkbox"> v-text et v-on</li><li><input disabled type="checkbox"> v-show et v-model</li><li><input disabled type="checkbox"> v-for et v-if</li></ul><hr><p><strong>將事件發送到不相關 Component 的技術是什麼？</strong></p><ul><li><input disabled type="checkbox"> Event Dispatch</li><li><input disabled type="checkbox"> Event Bus</li><li><input disabled type="checkbox"> Global Events</li><li><input disabled type="checkbox"> 透過 store</li></ul><hr><p><strong>哪個特殊變量包含<code>v-on</code>捕獲的本機事件？</strong></p><ul><li><input disabled type="checkbox"> $event</li><li><input disabled type="checkbox"> nativeEvent</li><li><input disabled type="checkbox"> e</li><li><input disabled type="checkbox"> e.native</li></ul><hr><p><strong><code>Vuex</code>存儲上的哪些操作是異步的？</strong></p><ul><li><input disabled type="checkbox"> getter</li><li><input disabled type="checkbox"> mutation</li><li><input disabled type="checkbox"> action</li></ul><hr><p><strong>這些 component 掛鉤的正確執行順序是什麼？</strong></p><ul><li><input disabled type="checkbox"> created, beforeMount, mounted, updated</li><li><input disabled type="checkbox"> mounted, beforeCreate, created, destroyed</li><li><input disabled type="checkbox"> created, beforeUpdate, update, mounted</li></ul><hr><p><strong>為什麼 component 的<code>data</code>屬性應該是返回新對象的函數？</strong></p><ul><li><input disabled type="checkbox"> 在處理大型表格時，為了讓效能更好 </li><li><input disabled type="checkbox"> 強制複製並避免 component 之間資料衝突</li><li><input disabled type="checkbox"> 為避免內存洩漏</li></ul><hr><p><strong>通過<code>v-show</code>“隱藏”圖像時，瀏覽器是否會加載圖像？</strong></p><ul><li><input disabled type="checkbox"> 是</li><li><input disabled type="checkbox"> 不是</li><li><input disabled type="checkbox"> Seulement si c’est un gif animé de Jean-Claude Van Damme</li></ul><hr><h2 id="Quiz-Vue-js-深度問題"><a href="#Quiz-Vue-js-深度問題" class="headerlink" title="Quiz Vue.js 深度問題"></a>Quiz Vue.js 深度問題</h2><p><strong>我們如何將事件廣播到不相關的多個 component ？</strong></p><ul><li><input disabled type="checkbox"> Vue.broadcast</li><li><input disabled type="checkbox"> 使用 Event Bus</li><li><input disabled type="checkbox"> Vue.$globalEmit</li></ul><hr><p><strong>使<code>&quot;computed&quot;</code>可修改的技術是什麼？</strong></p><ul><li><input disabled type="checkbox"> 切成兩個方法集並使用 set 和 get</li><li><input disabled type="checkbox"> 將其與<code>v-sync</code>指令做關聯</li><li><input disabled type="checkbox"> 必須將其放置在 component 的”data”屬性中</li></ul><hr><p><strong>哪條指令允許您將樣式範圍限制為 component 本身</strong></p><ul><li><input disabled type="checkbox"> 將<code>scoped</code>屬性放在<code>styles</code>中</li><li><input disabled type="checkbox"> 指令 <code>v-scope</code></li><li><input disabled type="checkbox"> 將屬性設定為<code>scoping:true</code></li></ul><hr><p><strong>如果事件來自 component 本身，我們可以在<code>v-on</code>指令上使用什麼修飾符來觸發？</strong></p><ul><li><input disabled type="checkbox"> v-on:click.once</li><li><input disabled type="checkbox"> v-on:click.self</li><li><input disabled type="checkbox"> v-on:click.this</li></ul><hr><p><strong>哪條語句使 component 及其不活動的資料保持高速緩存？</strong></p><ul><li><input disabled type="checkbox"> <code>&lt;keep-alive&gt;</code></li><li><input disabled type="checkbox"> <code>&lt;template cache&gt;</code></li><li><input disabled type="checkbox"> <code>&lt;slot&gt;</code></li></ul><hr><p><strong>哪條指令可用於創建內容位置，以用一個或多個其他 component 甚至HTML代碼填充 component ？</strong></p><ul><li><input disabled type="checkbox"> v-inject</li><li><input disabled type="checkbox"> v-slot</li><li><input disabled type="checkbox"> v-inside</li><li><input disabled type="checkbox"> v-html</li></ul><hr><p><strong>哪條指令可以使“反應性”的 component 資料成為可能，而不是事先沒有？</strong></p><ul><li><input disabled type="checkbox"> Vue.react</li><li><input disabled type="checkbox"> Vue.initData</li><li><input disabled type="checkbox"> Vue.mount</li><li><input disabled type="checkbox"> Vue.set</li></ul><hr><p><strong>我們如何按需生成名稱為<code>“component”</code>的 component 存儲在變量中？</strong></p><ul><li><input disabled type="checkbox"> <code>&lt;render template=&quot;composant&quot;&gt;</code></li><li><input disabled type="checkbox"> <code>&lt;component render=&quot;composant()&quot;&gt;</code></li><li><input disabled type="checkbox"> <code>&lt;component :is=&quot;composant&quot;&gt;</code></li></ul><hr><p><strong>如何在 component 之間共享通用代碼段？（資料，掛鉤，方法）</strong></p><ul><li><input disabled type="checkbox"> 透過繼承</li><li><input disabled type="checkbox"> 透過 extends</li><li><input disabled type="checkbox"> 透過 mixin</li></ul><hr><p><strong>如何強制刷新 component ？</strong></p><ul><li><input disabled type="checkbox"> 透過 this.$update();</li><li><input checked disabled type="checkbox"> 透過 :key 指示變數的變化</li><li><input disabled type="checkbox"> 透過 this.$router.push(‘#’) juste après un appel à this.nextTick</li></ul><p>出處：<a href="https://www.alsacreations.com/" target="_blank" rel="noopener">https://www.alsacreations.com/</a></p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.</p><h3 id="Quiz-Vue-js-基礎-1"><a href="#Quiz-Vue-js-基礎-1" class="headerlink" title="Quiz Vue.js 基礎"></a>Quiz Vue.js 基礎</h3><p><strong>是誰創造了VueJs ?</strong></p><ul><li><input checked disabled type="checkbox"> Evan You</li></ul><p><strong>定義 Vue Component 的3個部分是什麼？</strong></p><ul><li><input checked disabled type="checkbox"> template, style, script</li></ul><p><strong>我們如何將資料從父層 Component 傳遞到子層 Component ？</strong></p><ul><li><input checked disabled type="checkbox"> 透過 prop</li></ul><p><strong>我們能否不靠 Babel 編譯的情況，單獨使用 Vue (script src)？</strong></p><ul><li><input checked disabled type="checkbox"> 可</li></ul><p><strong>用動態傳值語法，將<code>kiwi</code>給<code>prop</code>的寫法？</strong></p><ul><li><input checked disabled type="checkbox"> v-bind:kiwi=”kiwi”</li></ul><p><strong>Vue 的哪個套件可以在所有 component 之間共享資料？</strong></p><ul><li><input checked disabled type="checkbox"> Vuex</li></ul><p><strong>使用<code>v-for</code> 建立 loop 時，必要的屬性是什麼？</strong></p><ul><li><input checked disabled type="checkbox"> v-key</li></ul><p><strong>哪一個語法可以 route 到另一個 vue component？</strong></p><ul><li><input checked disabled type="checkbox"> this.$router.push(url)</li></ul><p><strong>我們如何在資料的變化的同時觸發一個動作？</strong></p><ul><li><input checked disabled type="checkbox"> 使用 watch</li></ul><p><strong>哪一個 directive (vue 的指令，ex: <code>v-for</code>, <code>v-model</code>) 將輸入欄位和 component 的 data 關聯在一起？</strong></p><ul><li><input checked disabled type="checkbox"> v-model</li></ul><h3 id="Quiz-Vue-js-中等程度-1"><a href="#Quiz-Vue-js-中等程度-1" class="headerlink" title="Quiz Vue.js 中等程度"></a>Quiz Vue.js 中等程度</h3><p><strong>哪個 method 可以確保 dom 已完成更新才執行？</strong></p><ul><li><input checked disabled type="checkbox"> Vue.nextTick</li></ul><p><strong>如何使用<code>Vue</code>方法（ component 的功能）訪問本機DOM的元素？</strong></p><ul><li><input checked disabled type="checkbox"> 透過 v-ref</li></ul><p><strong>我們如何從由<code>“document /：id”</code>路由解釋的URL獲取<code>“id”</code>參數？</strong></p><ul><li><input checked disabled type="checkbox"> this.$route.params.id</li></ul><p><strong>哪些指令不應混在同一元素或 component 上？</strong></p><ul><li><input checked disabled type="checkbox"> v-for et v-if</li></ul><p><strong>將事件發送到不相關 Component 的技術是什麼？</strong></p><ul><li><input checked disabled type="checkbox"> Event Bus</li></ul><p><strong>哪個特殊變量包含<code>v-on</code>捕獲的本機事件？</strong></p><ul><li><input checked disabled type="checkbox"> $event</li></ul><p><strong><code>Vuex</code>存儲上的哪些操作是異步的？</strong></p><ul><li><input checked disabled type="checkbox"> action</li></ul><p><strong>這些 component 掛鉤的正確執行順序是什麼？</strong></p><ul><li><input checked disabled type="checkbox"> created, beforeMount, mounted, updated</li></ul><p><strong>為什麼 component 的<code>data</code>屬性應該是返回新對象的函數？</strong></p><ul><li><input checked disabled type="checkbox"> 強制複製並避免 component 之間資料衝突</li></ul><p><strong>通過<code>v-show</code>“隱藏”圖像時，瀏覽器是否會加載圖像？</strong></p><ul><li><input checked disabled type="checkbox"> 是</li></ul><h3 id="Quiz-Vue-js-深度問題-1"><a href="#Quiz-Vue-js-深度問題-1" class="headerlink" title="Quiz Vue.js 深度問題"></a>Quiz Vue.js 深度問題</h3><p><strong>我們如何將事件廣播到不相關的多個 component ？</strong></p><ul><li><input checked disabled type="checkbox"> 使用 Event Bus</li></ul><p><strong>使<code>&quot;computed&quot;</code>可修改的技術是什麼？</strong></p><ul><li><input checked disabled type="checkbox"> 切成兩個方法集並使用 set 和 get</li></ul><p><strong>哪條指令允許您將樣式範圍限制為 component 本身</strong></p><ul><li><input checked disabled type="checkbox"> 將<code>scoped</code>屬性放在<code>styles</code>中</li></ul><p><strong>如果事件來自 component 本身，我們可以在<code>v-on</code>指令上使用什麼修飾符來觸發？</strong></p><ul><li><input checked disabled type="checkbox"> v-on:click.self</li></ul><p><strong>哪條語句使 component 及其不活動的資料保持高速緩存？</strong></p><ul><li><input checked disabled type="checkbox"> <code>&lt;keep-alive&gt;</code></li></ul><p><strong>哪條指令可用於創建內容位置，以用一個或多個其他 component 甚至HTML代碼填充 component ？</strong></p><ul><li><input checked disabled type="checkbox"> v-slot</li></ul><p><strong>哪條指令可以使“反應性”的 component 資料成為可能，而不是事先沒有？</strong></p><ul><li><input checked disabled type="checkbox"> Vue.set</li></ul><p><strong>我們如何按需生成名稱為<code>“component”</code>的 component 存儲在變量中？</strong></p><ul><li><input checked disabled type="checkbox"> <component :is="composant"></component></li></ul><p><strong>如何在 component 之間共享通用代碼段？（資料，掛鉤，方法）</strong></p><ul><li><input checked disabled type="checkbox"> 透過 mixin</li></ul><p><strong>如何強制刷新 component ？</strong></p><ul><li><input checked disabled type="checkbox"> 透過 <code>:key</code> 指示變數的變化</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 的 模塊 Module 與組件 component</title>
      <link href="/tsuifei.github.io/React_module_component/"/>
      <url>/tsuifei.github.io/React_module_component/</url>
      
        <content type="html"><![CDATA[<blockquote><p>模塊與組件 模塊化與組件化 好繞舌</p></blockquote><h2 id="模塊與組件的關係"><a href="#模塊與組件的關係" class="headerlink" title="模塊與組件的關係"></a>模塊與組件的關係</h2><h3 id="模塊-Module"><a href="#模塊-Module" class="headerlink" title="模塊 Module"></a>模塊 Module</h3><p>理解：向外提供特定功能的 JS 應用，一般就是以<code>.js</code>的檔案為單位。<br>為什麼：因為 JS 程式碼會越多，會越來越複雜。<br>作用：可重複使用、簡化 JS 的編寫、提高 JS 的執行效率。</p><a id="more"></a><h3 id="組件-Component"><a href="#組件-Component" class="headerlink" title="組件 Component"></a>組件 Component</h3><p>一個局部的介面功能模塊，介面所需元素的集合包含 HTML,CSS,JS,image。可用來做資料、變數與函式操作與儲存資料的操作。</p><p>理解：用來實現特定（局部）功能效果的程式碼集合(HTML, CSS)。<br>為什麼：一個介面的功能很複雜，所以最好能拆分成多個組件會較清楚。<br>作用： 可重複使用、簡化 JS 的編寫、提高 JS 的執行效率。</p><h3 id="模塊化-Modular"><a href="#模塊化-Modular" class="headerlink" title="模塊化 Modular"></a>模塊化 Modular</h3><p>當應用程式的 JS 都是以模塊的方式書寫，這個程式就是一個模塊化的應用程式。</p><h3 id="組件化-Componentization"><a href="#組件化-Componentization" class="headerlink" title="組件化 Componentization"></a>組件化 Componentization</h3><p>當應用程式的 JS 都是以多個組件的方式編寫，這個應用程式就是一個組件化的應用程式。</p><h2 id="物件導向的組件構成"><a href="#物件導向的組件構成" class="headerlink" title="物件導向的組件構成"></a>物件導向的組件構成</h2><h3 id="基本的理解和使用"><a href="#基本的理解和使用" class="headerlink" title="基本的理解和使用"></a>基本的理解和使用</h3><p>物件導向的物件 -&gt; 物件導向的模塊 -&gt; 物件導向的組件。</p><p><code>&lt;MyComponent/&gt;</code>稱為組件標籤，組件名可任意，但第一個字母需大寫，且標籤需關閉<code>&lt;組件名/&gt;</code>。</p><p>新增組件的步驟：</p><ol><li>定義組件有兩種方式：工廠模式組件(簡單組件)、ES6 類別組件(複雜組件)</li><li>渲染組件標籤</li></ol><h3 id="工廠模式組件-簡單組件：沒有狀態的組件"><a href="#工廠模式組件-簡單組件：沒有狀態的組件" class="headerlink" title="工廠模式組件(簡單組件：沒有狀態的組件)"></a>工廠模式組件(簡單組件：沒有狀態的組件)</h3><p>工廠模式組件的效率會比類別組件好，但是只能在組件沒有「狀態」的情況下使用它，也就是說如果只是靜態顯示資料，就可考慮用工廠模式。</p><p>工廠模式的寫法很像一般函式的寫法，且一定要有回傳，而回傳內容通常就包含了 HTML 標籤。</p><p>重點：一定要有回傳<code>return</code>，只要組件有<code>state</code>狀態，就不能用工廠模式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>工廠模式組件(簡單組件) <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 渲染組件標籤</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'example1'</span>));</span><br></pre></td></tr></table></figure><p>組件標籤的另一種寫法，如果需要內容物在組件標籤之間，就可用這種寫法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;</span><br><span class="line">  &lt;h2&gt;工廠模式組件(簡單組件) &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>MyComponent&gt;</span><br></pre></td></tr></table></figure><h3 id="ES6-類別組件-複雜組件"><a href="#ES6-類別組件-複雜組件" class="headerlink" title="ES6 類別組件(複雜組件)"></a>ES6 類別組件(複雜組件)</h3><p>ES6 類別組件寫法是以物件導向的類別方式來攥寫，包在裡面的會有建構式、綁定自定義函式、狀態和渲染或者是事件監聽。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. ES6 類別組件(複雜組件)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>ES6 類別組件(複雜組件)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent2</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'example2'</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 裡的虛擬 DOM</title>
      <link href="/tsuifei.github.io/React_virtual_DOM/"/>
      <url>/tsuifei.github.io/React_virtual_DOM/</url>
      
        <content type="html"><![CDATA[<blockquote><p>這世界上有很多虛擬的東東，這些欺騙感情的虛擬物，有時也可以拿來療癒。</p></blockquote><p>先來理解一下什麼是虛擬 DOM : 為什麼我們需要用它?<br>這篇文章解釋得頗清楚的：<a href="https://segmentfault.com/a/1190000018891454" target="_blank" rel="noopener">虛擬 DOM 的渲染原理和特性</a></p><p>但是還是來整理一下重點：<br>原本我們寫原生的 JavaScript 時，我們會直接對 DOM 進行監聽和修改，然後這個 DOM 元素也會透過我們的監聽的事件所執行的，讓頁面產生互動。</p><a id="more"></a><p>React 則是會把我們寫的監聽這部份，轉成一個<strong>物件</strong>，再將這個物件轉換成真實的 DOM，這個由 React 轉成的物件就是所謂的虛擬 DOM。</p><p>假如說我們有一個用 HTML 寫成的樹狀 DOM 結構：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Mes amies<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Ayda<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Tracy<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React 可能會用這樣的物件格式來儲存這個 DOM:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const VitrualDom = &#123;</span><br><span class="line">  type: &apos;div&apos;,</span><br><span class="line">  props: &#123; class: &apos;title&apos; &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      type: &apos;span&apos;,</span><br><span class="line">      children: &apos;Mes amies&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      type: &apos;ul&apos;,</span><br><span class="line">      children: [</span><br><span class="line">        &#123; type: &apos;li&apos;, children: &apos;Ayda&apos; &#125;,</span><br><span class="line">        &#123; type: &apos;li&apos;, children: &apos;Tracy&apos; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="虛擬-DOM-物件最終都會被-React-轉化成真實的-DOM"><a href="#虛擬-DOM-物件最終都會被-React-轉化成真實的-DOM" class="headerlink" title="虛擬 DOM 物件最終都會被 React 轉化成真實的 DOM"></a>虛擬 DOM 物件最終都會被 React 轉化成真實的 DOM</h3><p>在我們需要新增或更新元素時，React 會先將這個 <code>VitrualDom</code> 物件進行新增和更改，然後再將這個虛擬的 DOM 物件渲染成一個真實的 DOM。</p><p>同樣的，如果我們需要對 DOM 進行監聽事件時，也會先對 <code>VitrualDom</code> 物件進行事件監聽，虛擬的 DOM 物件會代替原生的 DOM 事件做出反應與互動。</p><p>當我們需要對 DOM 進行事件監聽時，首先對 <code>VitrualDom</code> 進行事件監聽， <code>VitrualDom</code> 會代理原生的 DOM 事件從而做出反應。</p><h3 id="虛擬-DOM-和-JSX-語法"><a href="#虛擬-DOM-和-JSX-語法" class="headerlink" title="虛擬 DOM 和 JSX 語法"></a>虛擬 DOM 和 JSX 語法</h3><ol><li>React 提供了一些 API 來新增特別的 JS 物件。一個簡單的虛擬 DOM 物件：<code>const elememt = React.createElement(&#39;h1標籤名&#39;,{id:&#39;myTitle&#39;標籤屬性}, &#39;hello變數&#39;)</code></li><li>虛擬 DOM 物件最終都會被 React 轉化成真實的 DOM</li><li>基本上只需要操作 React 的虛擬 DOM 的相關資料, React 會轉換為真實的 DOM 變化，而更新介面。</li></ol><h2 id="新增虛擬-DOM-的兩種方式"><a href="#新增虛擬-DOM-的兩種方式" class="headerlink" title="新增虛擬 DOM 的兩種方式"></a>新增虛擬 DOM 的兩種方式</h2><ol><li>原生 JS(一般不用)：<code>React.createElement(&#39;h2&#39;,{id:myId},msg)</code></li><li>JSX 語法：<code>&lt;h3 id={myId}&gt; {msg} &lt;/h3&gt;</code></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"test1"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">"test2"</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第一種原生 JS 方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = <span class="string">'I like you'</span>;</span><br><span class="line"><span class="keyword">const</span> myId = <span class="string">'Tracy'</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 1.新增虛擬 DOM</span></span><br><span class="line"><span class="keyword">const</span> vDom1 = React.createElement(</span><br><span class="line">  <span class="string">'h2'</span>,</span><br><span class="line">  &#123; <span class="attr">id</span>: myId.toLowerCase() &#125;,</span><br><span class="line">  msg.toUpperCase()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.渲染虛擬 DOM</span></span><br><span class="line">ReactDom.render(vDom1, <span class="built_in">document</span>.getElementById(<span class="string">'test1'</span>));</span><br></pre></td></tr></table></figure><p>第二種方式，使用 babel： <code>&lt;script type=&quot;text/babel&quot;&gt;&lt;/script&gt;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.新增虛擬 DOM 直接寫入 html 結構</span></span><br><span class="line"><span class="keyword">const</span> vDom2 = <span class="xml"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&#123;myId.toUpperCase()&#125;</span>&gt;</span> &#123;msg.toUpperCase()&#125; <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.渲染虛擬 DOM</span></span><br><span class="line">ReactDom.render(vDom2, <span class="built_in">document</span>.getElementById(<span class="string">'test2'</span>));</span><br></pre></td></tr></table></figure><h2 id="渲染虛擬-DOM-元素-的語法"><a href="#渲染虛擬-DOM-元素-的語法" class="headerlink" title="渲染虛擬 DOM (元素)的語法"></a>渲染虛擬 DOM (元素)的語法</h2><ol><li>語法：<code>ReactDom.render(virtualDOM, containerDOM)</code></li><li>作用：將虛擬 DOM 元素渲染到頁面中真實的 DOM 元素中顯示。</li><li>參數說明：</li></ol><ul><li>參數一：純 JS 或 JSX 新增的虛擬 DOM 物件</li><li>參數二：用來包含虛擬 DOM 元素的真實 DOM 元素物件(通常是個<code>&lt;div&gt;</code>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 基礎 型別篇</title>
      <link href="/tsuifei.github.io/JS_Basic_type/"/>
      <url>/tsuifei.github.io/JS_Basic_type/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我們很容易忘記，我們曾學過的東西裡，仍有許多細微的小細節。</p></blockquote><p>知道自己是個健忘的人，所以偶爾會翻些基礎的知識來看看，才發現其實有許多自己忘，或根本沒有去注意到的小細節。<br>這次來記錄一下自己之前學的時候沒注意到的點。</p><a id="more"></a><h2 id="JavaScript-的資料類型"><a href="#JavaScript-的資料類型" class="headerlink" title="JavaScript 的資料類型"></a>JavaScript 的資料類型</h2><p>JavaScript 的資料類型分為兩種：</p><ol><li>基本(值)類型</li></ol><ul><li>String</li><li>number</li><li>boolean</li><li>undefined</li><li>null</li></ul><ol start="2"><li>物件(引用)類型 Object</li></ol><ul><li>Array：有索引/有序</li><li>function：可執行</li><li>object ：任意物件</li></ul><h3 id="判斷資料類型的方式"><a href="#判斷資料類型的方式" class="headerlink" title="判斷資料類型的方式"></a>判斷資料類型的方式</h3><ol><li><p>typeof : 可判斷 undefined/數值/字串/布林/function; 不能判斷 null 和 Object / Object 和 Array<br>typeof 回傳時的資料類型是以字串表達，所以會有雙引號’number’，且都以小寫表示。</p></li><li><p>Instanceof : 判斷物件具體的類型<br>ex.物件是陣列還是函式等，instance of 的意思是實例。<br>所以（a Instanceof b）即為 a 是不是 b 的實例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  b: [<span class="number">1</span>, <span class="string">'hi'</span>, <span class="built_in">console</span>.log],</span><br><span class="line">  c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Object</span>, a <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true false 型別以第一字母為大寫。</span></span><br><span class="line"><span class="built_in">console</span>.log(a.b <span class="keyword">instanceof</span> <span class="built_in">Object</span>, a.b <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.c <span class="keyword">instanceof</span> <span class="built_in">Object</span>, a.c <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true true 是物件也是函式的物件</span></span><br><span class="line"></span><br><span class="line">consol.log(<span class="keyword">typeof</span> a.b); <span class="comment">// object 無法知道是array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用typeof時，比較時應該用字串型態</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a.c === <span class="string">'function'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log 是什麼資料型態？</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a.b[<span class="number">2</span>] === <span class="string">'function'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">a.b[<span class="number">2</span>](<span class="number">4</span>); <span class="comment">//4 ,a.b[2] 在這裏等同console.log()</span></span><br><span class="line">a.c(); <span class="comment">// 等同 a 物件裡的 function() &#123; return 'Hello';&#125;</span></span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. === 全等：比較運算子，可判斷 undefine 和 null</span><br><span class="line"></span><br><span class="line">## 為什麼 null 是資料型態是 &apos;object&apos; ?</span><br><span class="line"></span><br><span class="line">覺得這樣的解釋還蠻有道理的，也就是說，當我們宣告一個物件或是字串形態的變數，他原本是個物件或陣列，型別皆為物件，但是如果我想要把這個變數整個在記憶體清掉，那麼我們就可以將`null`指向這個變數，這樣這個物件也會被清空。以這個方向來想，就不難理解為什麼 `null`的資料型態是`&apos;object&apos;`了。</span><br><span class="line"></span><br><span class="line">## undefined 和 null 的區別？</span><br><span class="line"></span><br><span class="line">undefined 為宣告(定義)了變數，但還沒賦值。</span><br><span class="line">null 宣告了，並已賦值，只是值是 null。</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">let a;</span><br><span class="line">console.log(a); // undefined 宣告(定義)了但還沒賦值</span><br><span class="line">a = null;</span><br><span class="line">console.log(a); // null</span><br><span class="line"></span><br><span class="line">let b = null; // 初始賦值為 null，表示將要賦值的物件 object</span><br><span class="line">b = [1, 2, 3]; // 確定對物件 object 賦值</span><br><span class="line">b = null; // 這個 object 被清空</span><br></pre></td></tr></table></figure></li></ol><h2 id="何時會需要將-null-指向變數？"><a href="#何時會需要將-null-指向變數？" class="headerlink" title="何時會需要將 null 指向變數？"></a>何時會需要將 null 指向變數？</h2><p>在初始變數時，將要賦值給變數的資料是物件 Object，但還沒有資料。<br>還有就是在結束前希望指向變數能成為回收物件。<br>簡單來說，回收就是釋放記憶體的意思，且在瀏覽器的環境下。<br>想知道更多的「回收物件」可看<a href="https://zhuanlan.zhihu.com/p/23992332" target="_blank" rel="noopener">JavaScript 中的垃圾回收 - 知乎</a></p><h2 id="嚴格區別變數型別與資料型別"><a href="#嚴格區別變數型別與資料型別" class="headerlink" title="嚴格區別變數型別與資料型別"></a>嚴格區別變數型別與資料型別</h2><p>資料類型：基本型別和物件型別</p><ul><li>基本型別</li><li>物件型別 -&gt; 參考()型別</li></ul><p>變數型別：基本型別和參考型別</p><ul><li>基本型別 : 保存的是基本型別的資料(值)</li><li>參考型別 : 保存的是資料的記憶體位址</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = &#123;&#125;; <span class="comment">// c 指向的是記憶體位置</span></span><br></pre></td></tr></table></figure><p>(待續…)</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 組件 Component 和 JSX 語法</title>
      <link href="/tsuifei.github.io/React-component-JSX/"/>
      <url>/tsuifei.github.io/React-component-JSX/</url>
      
        <content type="html"><![CDATA[<blockquote><p>要從哪裡開始學，或許先看看 React 的組件結構比較容易懂？</p></blockquote><p>在開始學習 React 的時候，或許先從觀察開始，看看應有的組件檔案裡，需要有什麼塊狀結構，就像學 HTML ㄧ樣，也會有<code>&lt;html&gt;&lt;head&gt;</code>和<code>&lt;body&gt;</code> 。<br>除了我們認識的 HTML、CSS 和 JavaScript 外，React 也有屬於自己的語言標記，但嚴格說起來不能說是語言，而應該說是語法糖，什麼是語法糖？算是介於 HTML 和 JavaScript 之間的一種標籤語法，主要是要讓 JSX 來描述使用者界面的外觀，如官網<a href="https://zh-hant.reactjs.org/docs/introducing-jsx.html" target="_blank" rel="noopener">JSX – React</a>的介紹。</p><a id="more"></a><h2 id="JSX-與-HTML-不同的地方"><a href="#JSX-與-HTML-不同的地方" class="headerlink" title="JSX 與 HTML 不同的地方"></a>JSX 與 HTML 不同的地方</h2><ol><li>JSX 標籤語法一定要有 close tag。ex.<code>&lt;a&gt; &lt;/a&gt;</code></li><li>所有的 JSX 標籤語法一定可以自動閉合 self close tag。ex.<code>&lt;input /&gt;</code></li><li>tag 內的 class 屬性需改為<code>className</code> ; <code>label</code> 內的 <code>for</code> 則改為<code>htmlFor</code>，其他 CSS 屬性為兩個字的如 <code>font-size</code>也要改成<code>fontSize</code>也就是轉換成駝峰式命名法的方式。</li><li>原本事件監聽觸發的事件名稱<code>onclick</code>也需要改成是駝峰式命名的<code>onClick</code>。</li><li>使用大括號<code>{}</code>括著一個值或表達式<code>{this.onClick}</code> 表示是這個組件的<code>onClick()</code>函式。</li></ol><h2 id="新增一個新組件"><a href="#新增一個新組件" class="headerlink" title="新增一個新組件"></a>新增一個新組件</h2><p>所有我們設計的組件，都要繼承於<code>Component</code>，而組件內必須要有一個 <code>render ()</code>函式會回傳<code>return</code> 一個<code>JSX</code>的物件。<br>在書寫新組件(Component)的檔案時，需要至少有三個結構：</p><ol><li>引入所需。ex. <code>import</code> - <code>from</code></li><li>組件本身。ex. <code>class [組件名] extends [組件名]</code></li><li>輸出組件。ex. <code>export default</code></li></ol><h3 id="引入所需文件-1"><a href="#引入所需文件-1" class="headerlink" title="引入所需文件:(1.)"></a>引入所需文件:(1.)</h3><p>先引進必須要有的 React 的 Component，引入有兩種寫法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或是 此種比較常用</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="定義render-方法：-2"><a href="#定義render-方法：-2" class="headerlink" title="定義render ()方法：(2.)"></a>定義<code>render ()</code>方法：(2.)</h3><p><code>render()</code>方法是渲染頁面最重要的函式，利用<code>render()</code>將顯示內容以回傳<code>return()</code>物件的方式回傳，<code>return(JSX動態 or HTML靜態)</code>需用()包起來。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;il&gt;Hello Paris !<span class="xml"><span class="tag">&lt;<span class="name">il</span>/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="輸出組件-3"><a href="#輸出組件-3" class="headerlink" title="輸出組件(3.)"></a>輸出組件(3.)</h3><p>將組件以<code>export default [組件名];</code>形式輸出，以供其他組件使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Item;</span><br></pre></td></tr></table></figure><h2 id="實作組件"><a href="#實作組件" class="headerlink" title="實作組件"></a>實作組件</h2><p>兩個組件實作，在 List(ol)組件裡引入幾個 Item(li)組件。<br><strong>檔案名：Item.JS</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;il&gt;Hello Paris !<span class="xml"><span class="tag">&lt;<span class="name">il</span>/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Item;</span><br></pre></td></tr></table></figure><p>在另一個組件裡把 Item 這個組件安插進來。<br><strong>檔案名：List.js</strong><br>記得需引入<code>Item.js</code>，置入組件時須以 self close tag 的型態插入，如<code>&lt;Item /&gt;&gt;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Item <span class="keyword">from</span> <span class="string">'Item'</span>; <span class="comment">// 引入檔名可以不寫.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ol&gt;</span><br><span class="line">        &lt;Item/&gt;</span><br><span class="line">        &lt;Item/&gt;</span><br><span class="line">        &lt;Item/&gt;</span><br><span class="line">      &lt;ol/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> List;</span><br></pre></td></tr></table></figure><h2 id="如何渲染到畫面"><a href="#如何渲染到畫面" class="headerlink" title="如何渲染到畫面"></a>如何渲染到畫面</h2><p>組件都完成後，就可以在引入主要頁面的<code>index.js</code>並且告知要放在哪一個 DOM 元素的位置。</p><ul><li>在專案裡<code>src/index.js</code>，是 react 預設的程式進入點。</li><li><code>react</code>是核心。<code>react-dom</code>是把 react 掛載到 dom 上面的必需組件。</li><li><code>src/index.js</code>裡面宣告的<code>ReactDom.render(&lt;List /&gt;,documentgetElementById(&#39;root&#39;));</code>元件，會自動 bind 綁定到<code>public/index.html裡面的</code>&lt;div id=”root&gt;`位置。</li></ul><p><strong>檔名：index.js</strong><br><code>render()</code>函式有兩參數:</p><ol><li><code>react element</code> 元素,型態是物件。ex.<code>&lt;List/&gt;</code></li><li><code>DOM contener</code> 裝 DOM 的容器。ex.<code>document.getElementById(&#39;root&#39;)</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span>; <span class="comment">// 引入組件</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">List</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line"><span class="comment">// 把 list 放到 root 裡面</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactJS 環境佈署</title>
      <link href="/tsuifei.github.io/React-deploy_01/"/>
      <url>/tsuifei.github.io/React-deploy_01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有完善的開發環境，開發起來才順手之起手式</p></blockquote><h2 id="ReactJS-部署開發環境"><a href="#ReactJS-部署開發環境" class="headerlink" title="ReactJS 部署開發環境"></a>ReactJS 部署開發環境</h2><h3 id="安裝開發套件懶人法"><a href="#安裝開發套件懶人法" class="headerlink" title="安裝開發套件懶人法"></a>安裝開發套件懶人法</h3><p>可先安裝<code>create-react-app</code>套件在 global 環境中，使用終端機指令：<code>sudo npm install -g create-react-app</code>，可以先試試把<code>sudo</code>拿掉，看是否有權限安裝，不行再加。</p><p>安裝了這個套件，在要開新專案時使用，會自動佈署所需要的檔案與套件，整個檔案約 296MB。先以<code>cd</code>前往要安裝的位置。<br><code>create-react-app [專案檔案夾名稱ex.test]</code>即會在所在的路徑增加一個名為 [專案檔案夾名稱 ex.test] 的 test 檔案夾。</p><a id="more"></a><p>顯示以下訊息表示安裝完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[fsevents] Success: &quot;/Users/tsuifei/Apprendre/JS/ReactJS/test/node_modules/fsevents/lib/binding/Release/node-v64-darwin-x64/fse.node&quot; already installed</span><br><span class="line">Pass --update-binary to reinstall or --build-from-source to recompile</span><br><span class="line">+ react@16.5.2</span><br><span class="line">+ react-scripts@2.0.5</span><br><span class="line">+ react-dom@16.5.2</span><br><span class="line">added 1746 packages from 670 contributors and audited 31992 packages in 147.652s</span><br><span class="line">found 0 vulnerabilities</span><br><span class="line"></span><br><span class="line">Initialized a git repository.</span><br><span class="line"></span><br><span class="line">Success! Created test at /Users/tsuifei/Apprendre/JS/ReactJS/test</span><br><span class="line">Inside that directory, you can run several commands:</span><br><span class="line"></span><br><span class="line">  npm start // 開啟開發伺服器，並會自動啟動預設瀏覽器，並以port 3000開啟顯示結果。</span><br><span class="line">    Starts the development server. 由port 3000開啟至瀏覽器</span><br><span class="line"></span><br><span class="line">  npm run build // 生成可用的網頁</span><br><span class="line">    Bundles the app into static files for production.</span><br><span class="line"></span><br><span class="line">  npm test</span><br><span class="line">    Starts the test runner.</span><br><span class="line"></span><br><span class="line">  npm run eject</span><br><span class="line">    Removes this tool and copies build dependencies, configuration files</span><br><span class="line">    and scripts into the app directory. If you do this, you can’t go back!</span><br><span class="line"></span><br><span class="line">We suggest that you begin by typing:</span><br></pre></td></tr></table></figure><h2 id="進入專案檔案夾"><a href="#進入專案檔案夾" class="headerlink" title="進入專案檔案夾"></a>進入專案檔案夾</h2><p>安裝完後先進去專案，以範例來說專案名稱為<code>test</code>：<br><code>cd test</code><br>啟動並開始開發<br><code>npm start</code></p><p>Happy hacking!</p><h2 id="create-react-app-所自動產生的檔案說明"><a href="#create-react-app-所自動產生的檔案說明" class="headerlink" title="create-react-app 所自動產生的檔案說明"></a>create-react-app 所自動產生的檔案說明</h2><p>.<br>├── README.md<br>├── package.json<br>├── public –&gt; 編譯後產生的前端檔<br>│ ├── favicon.ico<br>│ ├── index.html<br>│ └── manifest.json<br>├── src –&gt; 開發檔案<br>│ ├── App.css<br>│ ├── App.js 組件<br>│ ├── App.test.js<br>│ ├── index.css<br>│ ├── index.js 入口<br>│ ├── logo.svg<br>│ └── registerServiceWorker.js<br>└── yarn.lock</p><p>安裝完畢後執行 <code>npm start</code> 指令，可直接在瀏覽器上看編譯結果，<br>跳出編譯器則是<code>control + c</code></p><p>==指令==<br>利用 create-react-app 套件, 快速產生 webpack 的設定檔<br><code>npm install --global create-react-app</code></p><p>重點[使用方法]：</p><ol><li><p>新增 react 開發模板<br><code>create-react-app [YOUR_APP_NAME]</code></p></li><li><p>啟動 server<br><code>npm start</code> 會自動在瀏覽器開啟 localhost:3000</p></li><li><p>src 資料夾即 react 的模板</p></li><li><p>用 webpack build 你的網頁，執行之後在<code>build</code>裡的檔案即是可發佈的檔案。<br><code>npm run build</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法國前端初級測驗</title>
      <link href="/tsuifei.github.io/JS_front_test01/"/>
      <url>/tsuifei.github.io/JS_front_test01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>人總是在某種方式的評估下，才能清楚地知道自己的能耐。</p></blockquote><p>法國有不少人力派遣公司，因為法國聘人程序繁瑣，徵人又需投入大量資源人力，所以越來越多公司採用人力派遣所派遣過來的工程師，來開發公司的專案。</p><p>此測驗是法國某大人力派遣公司，對應徵者所做的線上測驗，進入測驗網頁後，須依規定的時間作答，時間到會自動前往下一題，無法回頭修改答案。</p><p>以下是本人測驗之後，重新再花時間整理出來的，包含整理時「自己認為」的正確答案，如對答案有意見，歡迎提示給予修正建議，感謝先。</p><a id="more"></a><p>這個測驗總共給約 55 分鐘。</p><h3 id="1-21"><a href="#1-21" class="headerlink" title="1/21"></a>1/21</h3><p><strong>需要在<code>&lt;a&gt;</code>標籤加上什麼屬性讓連結可以另開分頁？</strong></p><ul><li><input disabled type="checkbox"> target=”_self”</li><li><input disabled type="checkbox"> href=”#”</li><li><input disabled type="checkbox"> target=”_parent”</li><li><input checked disabled type="checkbox"> target=”_blank”</li></ul><h3 id="2-21"><a href="#2-21" class="headerlink" title="2/21"></a>2/21</h3><p><strong>實做<code>findLargest（numbers）</code>函式。</strong><br><strong>將回傳<code>findLargest（numbers）</code>numbers 陣列中的最大整數。 <code>numbers</code>是一個整數陣列，至少包含一個元素。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLargest</span>（<span class="title">numbers</span>）</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; arr.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(max &lt; arr[i])&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findLargest（[<span class="number">1</span>, <span class="number">-28</span>, <span class="number">88</span>, <span class="number">200</span>, <span class="number">7</span>]）</span><br></pre></td></tr></table></figure><p><strong>範例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 實作 arr.max()</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.max = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> max = <span class="keyword">this</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">this</span>.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ele &gt; max) &#123;</span><br><span class="line">      max = ele;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">234</span>, <span class="number">56</span>];</span><br><span class="line">arr.max(); <span class="comment">// 234</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************/</span></span><br><span class="line"><span class="comment">// 取最大值函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> max = arr[<span class="number">0</span>];</span><br><span class="line">  arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ele &gt; max) &#123;</span><br><span class="line">      max = ele;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">234</span>, <span class="number">56</span>];</span><br><span class="line">max(arr); <span class="comment">// 234</span></span><br><span class="line"><span class="comment">/*******************************/</span></span><br><span class="line"><span class="comment">// 取最小值函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> min = arr[<span class="number">0</span>];</span><br><span class="line">  arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ele &lt; min) &#123;</span><br><span class="line">      min = ele;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">234</span>, <span class="number">56</span>];</span><br><span class="line">min(arr); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>參考出處：<a href="https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/268893/" target="_blank" rel="noopener">JavaScript 學習筆記之取陣列中最大值和最小值 | 程式前沿</a></p><h3 id="3-21"><a href="#3-21" class="headerlink" title="3/21"></a>3/21</h3><p><strong>JavaScript <code>&quot;2&quot; === 2;</code> 會回傳以下哪個？</strong></p><ul><li><input disabled type="checkbox"> null</li><li><input disabled type="checkbox"> true</li><li><input checked disabled type="checkbox"> false</li><li><input disabled type="checkbox"> undefined</li></ul><h3 id="4-21"><a href="#4-21" class="headerlink" title="4/21"></a>4/21</h3><p><strong>Javascript 頁面加載完成後，可以使用哪個事件執行操作?</strong></p><ul><li><input disabled type="checkbox"> oncomplete</li><li><input disabled type="checkbox"> onfinished</li><li><input checked disabled type="checkbox"> onload</li><li><input disabled type="checkbox"> onupload</li><li><input disabled type="checkbox"> oninit</li></ul><h3 id="5-21"><a href="#5-21" class="headerlink" title="5/21"></a>5/21</h3><p><strong>哪個 HTML 標記用於定義<code>&lt;table&gt;</code>表格標題單元格?</strong></p><ul><li><input checked disabled type="checkbox"> th</li><li><input disabled type="checkbox"> tr</li><li><input disabled type="checkbox"> tt</li><li><input disabled type="checkbox"> td</li></ul><h3 id="6-21"><a href="#6-21" class="headerlink" title="6/21"></a>6/21</h3><p><strong>在 JavaScript 中，以下哪些語句可以退出循環？</strong></p><ul><li><input disabled type="checkbox"> quit();</li><li><input checked disabled type="checkbox"> break;</li><li><input disabled type="checkbox"> exit;</li><li><input disabled type="checkbox"> i = 99999999;</li></ul><h3 id="7-21"><a href="#7-21" class="headerlink" title="7/21"></a>7/21</h3><p><strong>在 JavaScript 中，如何聲明一個變數？</strong></p><ul><li><input checked disabled type="checkbox"> var x = 7;</li><li><input disabled type="checkbox"> x := 7;</li><li><input disabled type="checkbox"> int x = 7;</li><li><input disabled type="checkbox"> def x = 7;</li></ul><h3 id="8-21"><a href="#8-21" class="headerlink" title="8/21"></a>8/21</h3><p><strong>在 HTML 中，應如何編寫字符&lt;（小於）以防止將其視為打開標籤&lt; &gt;？</strong></p><ul><li><input checked disabled type="checkbox"> <code>&amp;lt</code>;</li><li><input disabled type="checkbox"> <code>%60</code></li><li><input disabled type="checkbox"> <code>\&lt;</code></li></ul><h3 id="9-21"><a href="#9-21" class="headerlink" title="9/21"></a>9/21</h3><p><strong>在 CSS 中，選擇 ID 前綴是使用哪個符號？</strong><br><code>#</code></p><h3 id="10-21"><a href="#10-21" class="headerlink" title="10/21"></a>10/21</h3><p><strong>哪一個是<code>foo.length</code>的值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [];</span><br><span class="line">foo.push(<span class="number">1</span>);</span><br><span class="line">foo.push(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li><input disabled type="checkbox"> 3</li><li><input checked disabled type="checkbox"> 2</li><li><input disabled type="checkbox"> 1</li><li><input disabled type="checkbox"> 0</li><li><input disabled type="checkbox"> null</li></ul><h3 id="11-21"><a href="#11-21" class="headerlink" title="11/21"></a>11/21</h3><p><strong>寫出<code>average(table)</code>函式，該函式必須回傳作為參數給的<code>table</code>的平均值。<code>table</code>是已定義的陣列，並且僅包含數字。</strong><br><strong>如果<code>table</code>為空，則<code>averge</code>必須回傳<code>0</code>。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span>(<span class="params">table</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (table.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">    sum += table[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum / table.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-21"><a href="#12-21" class="headerlink" title="12/21"></a>12/21</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myJson = &#123;</span><br><span class="line">  cities: [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'Paris'</span>, <span class="attr">pop</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'London'</span>, <span class="attr">pop</span>: <span class="number">8</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'New York'</span>, <span class="attr">pop</span>: <span class="number">9</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>以下哪一個的結果是<code>2</code></strong></p><ul><li><input disabled type="checkbox"> <code>myJson -&gt; cities -&gt; Laos -&gt; pop</code></li><li><input disabled type="checkbox"> <code>myJson.cities.[&#39;Paris&#39;].[pop]</code></li><li><input checked disabled type="checkbox"> <code>myJson.cities[0].pop</code></li><li><input disabled type="checkbox"> <code>myJson.cities.Paris.pop</code></li></ul><h3 id="13-21"><a href="#13-21" class="headerlink" title="13/21"></a>13/21</h3><p><strong>在 JavaScript 中，您使用什麼函式在控制台中顯示錯誤？</strong></p><p><code>consol.log();</code> ??? 不確定對不對</p><h3 id="14-21"><a href="#14-21" class="headerlink" title="14/21"></a>14/21</h3><p><strong>在 CSS 中，如何選擇在<code>&lt;p&gt;</code>的元素中所有的<code>&lt;span&gt;</code>元素？</strong></p><ul><li><input disabled type="checkbox"> <code>p.span</code></li><li><input disabled type="checkbox"> <code>span p</code></li><li><input disabled type="checkbox"> <code>p span</code></li><li><input checked disabled type="checkbox"> <code>p &gt; span</code></li><li><input disabled type="checkbox"> <code>span &lt; p</code></li></ul><h3 id="15-21"><a href="#15-21" class="headerlink" title="15/21"></a>15/21</h3><p><strong>HTML <code>&lt;p&gt;</code>在 CSS 默認下屬於什麼元素？</strong></p><ul><li><input disabled type="checkbox"> true</li><li><input checked disabled type="checkbox"> inline</li><li><input disabled type="checkbox"> inline-block</li><li><input disabled type="checkbox"> none</li><li><input disabled type="checkbox"> block</li></ul><h3 id="16-21"><a href="#16-21" class="headerlink" title="16/21"></a>16/21</h3><p><strong>請寫出此函式，如果<code>a（i，j）</code>函式的參數至少一個等於 1 或<code>i,j</code>的總和等於 1，回傳<code>true</code>。</strong><br><strong>兩個參數皆為數字。</strong><br>Par exemple:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`a(1,5)`</span> <span class="keyword">return</span> <span class="string">`true`</span></span><br><span class="line"><span class="string">`a(2,3)`</span> <span class="keyword">return</span> <span class="string">`false`</span></span><br><span class="line"><span class="string">`a(-3,4)`</span> <span class="keyword">return</span> <span class="string">`true`</span></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">function a(i,j)&#123;</span></span><br><span class="line"><span class="string">  if(typeof i !== 'number' &amp;&amp; typeof j !== 'number') return false;</span></span><br><span class="line"><span class="string">  if(i == 1 || j == 1 || i+j == 1) return true</span></span><br><span class="line"><span class="string">  return false</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="17-21"><a href="#17-21" class="headerlink" title="17/21"></a>17/21</h3><p><strong>在以下範例，哪一個是 JQuer 的最佳選擇器？</strong><br><strong>答案只有一個</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box"</span> id=<span class="string">"content"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><ul><li><input disabled type="checkbox"> <code>$(&#39;.content&#39;);</code></li><li><input checked disabled type="checkbox"> <code>$(&#39;#content&#39;);</code></li><li><input disabled type="checkbox"> <code>$(&#39;box&#39;);</code></li><li><input disabled type="checkbox"> <code>$(&#39;#box&#39;);</code></li><li><input disabled type="checkbox"> <code>$(&#39;content&#39;);</code></li><li><input disabled type="checkbox"> <code>$(&#39;.box&#39;);</code></li></ul><h3 id="18-21"><a href="#18-21" class="headerlink" title="18/21"></a>18/21</h3><p><strong>在 HTML 中，以下哪個答案對應於正確的元素層級結構？</strong></p><ul><li><input disabled type="checkbox"> <code>&lt;div&gt; &lt;p&gt; &lt;section&gt; &lt;span&gt;</code></li><li><input checked disabled type="checkbox"> <code>&lt;section&gt; &lt;div&gt; &lt;p&gt; &lt;span&gt;</code></li><li><input disabled type="checkbox"> <code>&lt;div&gt; &lt;p&gt; &lt;section&gt; &lt;span&gt;</code></li><li><input disabled type="checkbox"> <code>&lt;div&gt; &lt;section&gt; &lt;span&gt; &lt;p&gt;</code></li></ul><h3 id="19-21"><a href="#19-21" class="headerlink" title="19/21"></a>19/21</h3><p><strong>你的同事把階乘<code>factorial</code>這個函式寫壞了，請把它修好。</strong></p><p>Rappel : <code>factorial(n) = 1 * 2 * 3 *... * n</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">1</span> ? n * factorial(n - <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本寫法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorialBase</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorialBase(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(factorialBase(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(factorialBase(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>參考：<a href="https://javascript.info/task/factorial" target="_blank" rel="noopener">Calculate factorial</a></p><h3 id="20-21"><a href="#20-21" class="headerlink" title="20/21"></a>20/21</h3><p><strong>JavaScript 是多序列語言嗎？</strong></p><ul><li><input checked disabled type="checkbox"> Faux 錯</li><li><input disabled type="checkbox"> Vrai 對</li></ul><h3 id="21-21"><a href="#21-21" class="headerlink" title="21/21"></a>21/21</h3><p><strong>超市越來越配備自動收款機。 儘管大部分國家的消費者仍使用現金（包括鈔票和硬幣），但大多數收銀機僅接受銀行卡付款。</strong><br><strong>現金支付遇到的問題之一是貨幣兌換：如何以最佳方式製作給定的金額，也就是說，使用最少數量的硬幣和紙幣？ 這是我們每個人每天都會遇到的問題，更不用說在自動付款站了。</strong><br><strong>在本練習中，請嘗試找到在特定情況下進行更改的最佳解決方案：當自動提款機僅包含==2 歐元硬幣==，==5 歐元紙鈔== 和 ==10 歐元紙鈔==。</strong><br><strong>為了簡化問題，我們將考慮所有這些硬幣和紙幣以==無限數量==提供。</strong><br><strong>以下是一些示範：</strong></p><table><thead><tr><th>要退回的貨幣</th><th>可能的解決方式</th><th>優化後的解決方式</th></tr></thead><tbody><tr><td>1</td><td>無解</td><td>無解</td></tr><tr><td>6</td><td>2 + 2 + 2</td><td>2 + 2 + 2</td></tr><tr><td>10</td><td>2 + 2 + 2 + 2 +</td><td>10</td></tr><tr><td></td><td>5 + 5</td><td></td></tr><tr><td></td><td>10</td><td></td></tr><tr><td>9007199254740991</td><td>…</td><td>10 *</td></tr><tr><td></td><td></td><td>900719925474098 +</td></tr><tr><td></td><td></td><td>5 + 2 * 3</td></tr></tbody></table><p><strong>金額由具有 3 個屬性的物件表示。<br>分別存儲 2 歐元硬幣，5 歐元鈔票和 10 歐元的鈔票數量，以<code>two</code>,<code>five</code>,<code>ten</code>為屬性。</strong></p><p><strong>例如第二個例子，如果我們從表中獲取 6 歐元，則應獲取物件：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  two: <span class="number">3</span>,   <span class="comment">// 3 pièces de 2 euros</span></span><br><span class="line">  five: <span class="number">0</span>,  <span class="comment">// 0 pièces de 5 euros</span></span><br><span class="line">  ten: <span class="number">0</span>    <span class="comment">// 0 pièces de 10 euros</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>寫出<code>change（cash）</code>函式，該函式需回傳一個物件，其中包含總和為<code>s</code>。 如果不可能進行更改（例如第一個例子），則回傳<code>null</code>。</strong><br><strong>為了獲得最高分，您的解決方案必須盡可能使用「最小面額的硬幣和紙幣」</strong>。<br><strong>數據：<code>0 &lt;</code>cash<code>&lt; 9007199254740991</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">cash</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    two: <span class="number">0</span>,</span><br><span class="line">    five: <span class="number">0</span>,</span><br><span class="line">    ten: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(change(<span class="number">1</span>)); <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(change(<span class="number">42</span>).ten); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(change(<span class="number">42</span>).five); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(change(<span class="number">42</span>).two); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>回答：<a href="https://jsbin.com/duzefon/edit?js,console" target="_blank" rel="noopener">20/20 找錢 - JS Bin</a><br>後記：最後ㄧ題似乎還有些問題，如果把範例中最後一個拿來測試，會有問題，且無法做到優化，也就是說如果尾數是 11，就可變成（5<em>1）+(2</em>3)。這部分得再好好想想才行。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> JavaScript </tag>
            
            <tag> CSS </tag>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 30 - 01. Drum Kit 鍵盤音樂</title>
      <link href="/tsuifei.github.io/JS30_01_Drum-Kit%20copy/"/>
      <url>/tsuifei.github.io/JS30_01_Drum-Kit%20copy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有開頭總是好事，沒開頭就什麼事也不會發生。</p></blockquote><p>這個練習是在畫面上顯示好幾個鍵盤上面的鍵，讓使用者在按下鍵盤，依鍵盤不同而發出不同的聲響，原本的練習是以英文字母為發音鍵，但自己愛好自然就把它們換成了數字鍵，並搭配各種不同動物的叫聲也頗有趣的。</p><p>如果依照「功能」和「畫面」來拆解這個練習，那麼也表示「功能的部分」需要用 DOM 和 JavaScript 來操控，而「畫面」部分則需要先用 HTML + CSS 來刻好，以 JS 來等待觸發事件，來播放音效與變換元件（鍵）的狀態。</p><a id="more"></a><p><strong>功能：</strong> 按下鍵時，觸發相對應的聲音。離開鍵時聲音消失。<br><strong>畫面：</strong> 按下實際鍵時，畫面上對應的鍵會有反應，搭配動畫效果。離開自下去的鍵時會恢復原狀。</p><ul><li>如何監聽到按到哪個鍵： -&gt; 監聽 keydown 事件</li><li>鍵在按下去的時候播放音效： -&gt; 呼叫播放音效的函式 -&gt; playSound()</li><li>鍵在按下去的同時，播放動畫效果 CSS： -&gt; <code>key.classList.add(&#39;playing&#39;);</code></li><li>鍵在按下去之後恢復原狀： -&gt; 呼叫<code>removeTransition(event)</code> 執行<code>event.target.classList.remove(&#39;playing&#39;);</code>作切換。</li></ul><h3 id="HTML-的部分"><a href="#HTML-的部分" class="headerlink" title="HTML 的部分"></a>HTML 的部分</h3><ul><li>依序將需要的鍵顯示出來：<code>&lt;kbd&gt;7&lt;/kbd&gt;</code>表示鍵入數字 7</li><li>使用<code>data-</code>這個屬性來放入自定義的資料，這裡我們用<code>data-key</code>來定義。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-key</span>=<span class="string">"55"</span> <span class="attr">class</span>=<span class="string">"key"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>7<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sound"</span>&gt;</span>Loup<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再以<code>data-key</code>將我們會使用到的<code>audio</code>音效關聯起來。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">data-key</span>=<span class="string">"55"</span> <span class="attr">src</span>=<span class="string">"sounds/loup.wav"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="關於-data-屬性"><a href="#關於-data-屬性" class="headerlink" title="關於 data- 屬性"></a>關於 <code>data-</code> 屬性</h5><ul><li><code>data-</code>屬性可以讓我們自定義資料，它可以讓我們在任意的<code>html</code>標籤上放入我們自定義的資料屬性，<br>要注意的是，屬性名不可以是大寫字母，前面需要加上前綴詞<code>data-</code>緊接至少一個小寫字符，如我們用的<code>key</code>成了我們自定義的<code>data-key</code>標籤，例如<code>&lt;audio data-key=&quot;55&quot;&gt;</code></li></ul><h3 id="CSS-的部分"><a href="#CSS-的部分" class="headerlink" title="CSS 的部分"></a>CSS 的部分</h3><ul><li>我們先把要出現的效果寫好，命名為<code>.key</code>樣式。</li><li>當我們按下按鍵時，加上<code>.playing</code>樣式 讓畫面上的按鍵有些效果。這個<code>.playing</code> 樣式會在離開這個鍵時被拿掉。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.key</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.2rem</span> solid <span class="built_in">rgb</span>(<span class="number">11</span>, <span class="number">89</span>, <span class="number">37</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.5rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1rem</span> <span class="number">0.5rem</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.07s</span> ease;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">21</span>, <span class="number">168</span>, <span class="number">40</span>);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">254</span>, <span class="number">254</span>, <span class="number">0.6</span>);</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0.5rem</span> <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.playing</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="built_in">rgb</span>(<span class="number">21</span>, <span class="number">168</span>, <span class="number">40</span>);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1rem</span> <span class="built_in">rgb</span>(<span class="number">21</span>, <span class="number">168</span>, <span class="number">40</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JavaScript-的部分"><a href="#JavaScript-的部分" class="headerlink" title="JavaScript 的部分"></a>JavaScript 的部分</h3><p>前面有提到，當我們按下按鍵，程式會去呼叫發出音效的<code>playSound()</code>函式，做到這一點，我們得先監聽這些按鍵，何時被按下繼而觸發事件。</p><p>我們先將所有的按鍵放在一個陣列型別的變數<code>keys</code>裡，然後利用<code>forEach()</code>走訪陣列裡的元素（鍵），並監聽所會發生的事件，給予事件一個名稱：<code>transitionend</code>，並在觸發時，執行<code>removeTransition</code>函式去清除按下去被觸發的行為。也就是使鍵盤的 Key 恢復還沒被按下去的原狀。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'.key'</span>));</span><br><span class="line">keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> key.addEventListener(<span class="string">'transitionend'</span>, removeTransition));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 監聽頁面的鍵 keydown事件，觸發 playAudio 函式。</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'keydown'</span>, playSound);</span><br></pre></td></tr></table></figure><p>接著我們來看看發出音效的函式<code>playSound(event)</code>:</p><ul><li>利用<code>querySelector</code>先找出「音效」和「鍵」的 DOM 元素。</li><li>如果沒有找到<code>audio</code>就什麼也不做。</li><li>在<code>key</code>上面加上動畫效果的<code>playing</code>樣式。</li><li>讓播放音效的時間歸零。</li><li>再開始播放。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playSound</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> audio = <span class="built_in">document</span>.querySelector(<span class="string">`audio[data-key="<span class="subst">$&#123;event.keyCode&#125;</span>"]`</span>);</span><br><span class="line">  <span class="keyword">const</span> key = <span class="built_in">document</span>.querySelector(<span class="string">`div[data-key="<span class="subst">$&#123;event.keyCode&#125;</span>"]`</span>);</span><br><span class="line">  <span class="keyword">if</span> (!audio) <span class="keyword">return</span>; <span class="comment">// arreter le fonction de jouer</span></span><br><span class="line"></span><br><span class="line">  key.classList.add(<span class="string">'playing'</span>);</span><br><span class="line">  audio.currentTime = <span class="number">0</span>; <span class="comment">// revenir au debut</span></span><br><span class="line">  <span class="comment">// key.currentTime = 0; // revenir au debut</span></span><br><span class="line">  audio.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按鍵的監聽＋音效的播放＋按下鍵的動畫效果"><a href="#按鍵的監聽＋音效的播放＋按下鍵的動畫效果" class="headerlink" title="按鍵的監聽＋音效的播放＋按下鍵的動畫效果"></a>按鍵的監聽＋音效的播放＋按下鍵的動畫效果</h3><p>還有，在按下按鍵發出聲效後，使鍵盤的 Key 恢復原狀，移除這個動畫效果的<code>removeTransition(event)</code>函式：</p><ul><li>先檢查這個要監聽的事件元素，如果沒有 CSS 的動畫屬性<code>transform</code>就什麼都不做。</li><li>否則，就在這個元素上移除這個<code>.playing</code> CSS 樣式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeTransition</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.propertyName !== <span class="string">'transform'</span>) <span class="keyword">return</span>;</span><br><span class="line">  event.target.classList.remove(<span class="string">'playing'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，我們必須把寫好的函式放在 JS 程式碼的最前面，因為程式是一行行讀的，如果沒有先放前面，在讀到呼叫這些函式時，程式會因為還沒記憶這些函式而出現錯誤。</p><h2 id="相關語法"><a href="#相關語法" class="headerlink" title="相關語法"></a>相關語法</h2><p>在這個練習裡的<code>JavaScript</code>，我們用到了一些 ES6 的語法：</p><ul><li>使用了<code>const</code>的變數宣告，表示常數只能賦值一次。也就是說，賦值給這個變數後，值就不能再更改了。</li><li>使用了字串模板(Template literals)，語法為：<code>字串 ${變數、屬性名}</code>，<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">樣板字面值 MDN</a></li><li><code>forEach</code>和箭頭函式：因為在這個練習裡使用的是<code>document.querySelector</code>來得到一組 NodeList(DOM)，使用<code>forEach</code>方法來走訪這些 DOM 元素。</li></ul><h2 id="基礎語法"><a href="#基礎語法" class="headerlink" title="基礎語法"></a>基礎語法</h2><ul><li>使用<a href="https://developer.mozilla.org/zh-TW/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">EventTarget.addEventListener()</a>來增加監聽事件。</li><li>使用 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Document/querySelector" target="_blank" rel="noopener">document.querySelector</a> 來抓去我們所要監聽的 DOM 元素。</li></ul><h2 id="解決問題"><a href="#解決問題" class="headerlink" title="解決問題"></a>解決問題</h2><p><strong>如何可以讓我們按下鍵盤某個鍵時，和音效連結起來？</strong> 可以連結的原因是在<code>keydown</code>的事件中的<code>keyCode</code>屬性，<code>keyCode</code>的屬性值和 ASCII<br>的編碼相同，我們可以在 <a href="http://keycode.info/" target="_blank" rel="noopener">JavaScript Event KeyCodes</a> 查找對應的鍵碼。<br>我們在按鍵的<code>div</code>和音效的<code>audio</code>標籤中，都增加了一個我們自定義的屬性<code>data-key</code>，這樣我們在按下按鍵的同時，也可依循找到對應的音效。</p><p><strong>如何讓按鍵即使按著不放，也可以馬上有連續的音效？</strong> 我們把每次要播放音效之前，將播放的時間點歸零。</p><p><strong>如何讓每次按完鍵後，恢復成原狀？</strong> 在監聽按鍵時，我們使用<code>transitionend</code>這個事件，讓它在動畫效果結束後被觸發，動畫效果完成之後，就去除這個樣式。但是因為按鍵按下時，不只只有動畫效果<code>transform</code>所以需要增加一個<code>if</code>的判斷式，讓每發生一次按鍵事件，只去除一次樣式。</p><h6 id="碎碎唸：其實如果沒有這個判斷式，如果按住按鈕不放，也不會有一直是有動畫效果停滯，反而效果較好。"><a href="#碎碎唸：其實如果沒有這個判斷式，如果按住按鈕不放，也不會有一直是有動畫效果停滯，反而效果較好。" class="headerlink" title="碎碎唸：其實如果沒有這個判斷式，如果按住按鈕不放，也不會有一直是有動畫效果停滯，反而效果較好。"></a>碎碎唸：其實如果沒有這個判斷式，如果按住按鈕不放，也不會有一直是有動畫效果停滯，反而效果較好。</h6><h3 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h3><p>雖然看似步驟不複雜的按鍵與音效，要注意的部分也不少，希望在這樣的詳細拆解之下，可以多了解不同語法的應用與使用的原因，以實務的方式了解程式面，的確比較類比多了。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JavaScript 30 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 30 - 00. 為什麼開始？因為希望完成</title>
      <link href="/tsuifei.github.io/JS30_00_start/"/>
      <url>/tsuifei.github.io/JS30_00_start/</url>
      
        <content type="html"><![CDATA[<blockquote><p>當我們每天早上醒來，都是一切的開始。</p></blockquote><p>原始出處：<a href="https://javascript30.com/" target="_blank" rel="noopener">Javascript30.com</a><br>原始檔案：<a href="https://github.com/wesbos/JavaScript30" target="_blank" rel="noopener">[github]</a></p><p>這是個很有名的免費線上課程，由 Wes Bos 推出的 30 個以原生 JavaScript 寫出來的挑戰，這 30 道題目也有 Wes Bos 所提供的免費教學影片可看，可說是佛心來的。而網路上也有許多前輩，挑戰之後將心得分享出來，我們可以在原始檔案<a href="https://github.com/wesbos/JavaScript30" target="_blank" rel="noopener">[github]</a>上的 README 上看到列表，其中有好幾位來自台灣的前輩，因此增加了中文的分享筆記，是英文不夠好的救星啊！而這一兩年這 30 題也成為許多人入手學習 JS 必做的練習，在框架盛行的年代，能夠以原生的 JavaScript 來寫練習真的是越來越珍貴。</p><a id="more"></a><h3 id="寫在前頭"><a href="#寫在前頭" class="headerlink" title="寫在前頭"></a>寫在前頭</h3><p>開始寫這些題目是在 2018 年還在 42 的時候，那是很焦急的時期，一直等待的 Piscine JavaScript 確定落空後，只有自己找課程來學，聽聞這個挑戰主題，當然也想試一下，且野心勃勃的改掉全部的視覺，加上自己根本對 JS 不熟，導致進度非常緩慢，且懞懞懂懂的參考著其他人寫的，搭配當時的「Alex 宅幹嘛」教學影片，竟也完成了四篇，現在看來覺得有點不可思議。</p><p>一年後的現在，再次想要把它慢慢理解完，並試著記錄在每一個練習上所學到的，希望自己可以因此更熟悉 JavaScript。</p><p>之前有聽到人家的進度是一天一題，很白痴的以為自己真的是動作慢到不行（也的確慢），後來才知道原來是把整個檔案從 Github clone 下來後，直接寫而不要管視覺的部分，不過儘管如此，還是希望至少要讓畫面不太ㄧ樣，即使顏色也好。</p><p>看到前輩先把功能和畫面效果分析出來是有道理的，分析後，再來把要執行的思路想一想，而不要馬上進行或許可以比較有條理地想清楚需要什麼函式、用什麼方法或是抓到的 DOM 要如何操控，一步步記錄下來，應該會對學習有幫助的，也要提醒自己常回來看看自己所記錄的才有用有印象啊！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JavaScript 30 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 測試陣列是否有符合條件的元素好用方法 every() &amp; some()</title>
      <link href="/tsuifei.github.io/JS_ironMan34_Determines-whether-an-array-includes-a-certain-value-among-its-entries/"/>
      <url>/tsuifei.github.io/JS_ironMan34_Determines-whether-an-array-includes-a-certain-value-among-its-entries/</url>
      
        <content type="html"><![CDATA[<h6 id="Array-34"><a href="#Array-34" class="headerlink" title="Array 34"></a>Array 34</h6><blockquote><p>一顆小螺絲釘立大功 ，一粒屎壞一鍋粥猜兩個迭代函式。</p></blockquote><p>在 ECMAScript 5 的迭代方法中有兩個好用的迭代方法，這兩個方法主要拿來檢查陣列裡的元素值是否符我們給的條件：<code>some()</code>與<code>every</code>。而這兩個方法的回傳值皆為布林值。</p><p>如果用字面上來解釋，就很容易分辨兩個的不同：<br>some() -&gt; some 某一個：<strong>有一個</strong>元素符合條件就回傳<code>true</code>。<br>every() -&gt; every 每一個：要<strong>全部</strong>符合條件才會回傳<code>true</code>。</p><a id="more"></a><p><code>some()</code>可以用來檢查陣列中是否有「某一個」元素符合條件。如果「其中一個」元素符合條件就回傳 true。</p><p><code>every</code>剛好和<code>some()</code><strong>相反</strong>，我們拿它來檢查陣列中是否「全部」都符合條件，如果「每一個」都符合條件，才會回傳 true ，否則會回傳 false。</p><p><code>every</code>和<code>some()</code>也很像邏輯運算子的 OR <code>||</code>和 AND <code>&amp;&amp;</code>的關係， <code>||</code>只要一邊有符合條件就是 true ，而<code>&amp;&amp;</code>則是相反，需要兩邊都符合才會得到 true。</p><p>我們先來看一下這兩個方法的基本資料：</p><h2 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank" rel="noopener">Array.prototype.every() - JavaScript | MDN</a><br><strong>原型：</strong> Array.prototype.every()<br><strong>功能：</strong> 測試陣列中的所有元素是否都通過了所給的條件。<br><strong>改變：</strong> 不會改變原陣列<br><strong>語法：</strong> arr.every(callback[, thisArg])<br><strong>回傳值：</strong> 傳回布林值，若回呼函式在處理每一個陣列元素時皆得到 truthy 值，則回傳 true。否則，回傳值為 false。<br><strong>參數：</strong> callback 函式與 thisArg</p><p>例如，我們想要知道陣列中的字串是否都有兩個字母以上，希望得到的值是 true，所以使用<code>every()</code>，但因為其中一個字串<code>su</code>只有兩個字母，所以回傳 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'jack'</span>, <span class="string">'john'</span>, <span class="string">'may'</span>, <span class="string">'su'</span>, <span class="string">'Ada'</span>];</span><br><span class="line"><span class="keyword">let</span> friendName = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value.length &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">friendName; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>另外一個例子，我們想檢查陣列裡的元素值是否「都」大於 10，我們也可以換個方式這樣寫較為清楚：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先把條件寫好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要一個不符合，就回傳 false</span></span><br><span class="line"><span class="keyword">var</span> passed = [<span class="number">15</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">168</span>, <span class="number">42</span>].every(isBigEnough);</span><br><span class="line">passed; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果條件都符合，就回傳 true</span></span><br><span class="line">passed = [<span class="number">15</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">168</span>, <span class="number">42</span>].every(isBigEnough);</span><br><span class="line">passed; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="noopener">Array.prototype.some() - JavaScript | MDN</a><br><strong>原型：</strong> Array.prototype.some()<br><strong>功能：</strong> 測試陣列中是否至少有一個元素通過了所給的條件。<br><strong>改變：</strong> 不會改變原陣列<br><strong>語法：</strong> arr.every(callback[, thisArg])<br><strong>回傳值：</strong> 傳回布林值，若回呼函式在處理陣列元素時有一個元素得到 truthy 值，則回傳 true。否則，回傳值為 false。<br><strong>參數：</strong> callback 函式與 thisArg</p><p>我們可以拿它來測試陣列元素的數值是否存在，用以下的方法可以達到和 ECMAScript 7 的<code>include（)</code>方法的效果。<br>如果元素存在於陣列中，這個自定義函數就會返回 true：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> friends = [<span class="string">'Ayda'</span>, <span class="string">'Chris'</span>, <span class="string">'Kira'</span>, <span class="string">'Philippe'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAvailability</span>(<span class="params">arr, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">arrVal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val === arrVal;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkAvailability(friends, <span class="string">'Kira'</span>); <span class="comment">// true</span></span><br><span class="line">checkAvailability(friends, <span class="string">'Tracy'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>因缺乏實際應用的經驗，和朋友討論後，朋友提供了一個使用<code>some()</code>的情境：<br>例如，用<code>some()</code>來檢查使用者上傳的檔案格式是否符合條件，只要符合 checkTypeArray 中的任一格式時，就可以往下繼續執行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可自訂檢查的檔案格式</span></span><br><span class="line"><span class="keyword">const</span> checkTypeArray = [<span class="string">'xls'</span>, <span class="string">'xlsx'</span>, <span class="string">'pdf'</span>, <span class="string">'csv'</span>];</span><br><span class="line"><span class="comment">// fileType 為使用者選取得到的檔案格式</span></span><br><span class="line"><span class="keyword">const</span> checkType = checkTypeArray.some(<span class="function"><span class="params">file</span> =&gt;</span> fileType === file);</span><br><span class="line"><span class="keyword">if</span>(checkType)</span><br><span class="line"><span class="comment">// do anything you want to do.</span></span><br></pre></td></tr></table></figure><p>ECMAScript 5 的迭代方法就剩<code>reduce()</code>和<code>reduceRight()</code>還沒介紹，雖然還沒有辦法很多實際的情境，但相信多詳細了解這些方法的細節，總是會多一些印象，對於有著金魚腦的我，以後多少都有印象吧！</p><blockquote><p>如有需要改進的地方，拜託懇請告知，我會盡快修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 迴圈升級的陣列 Array 方法 forEach()</title>
      <link href="/tsuifei.github.io/JS_book-club-note-array/"/>
      <url>/tsuifei.github.io/JS_book-club-note-array/</url>
      
        <content type="html"><![CDATA[<p>參加讀書會是個可以讓自己和一群喜歡同一個技術領域的夥伴一起學習的方法，透過讀書會，去了解與深入書中所要表達的內容。<br>目前進行與參與的讀書會有「Javascript 大全」和「Javascript 忍者」兩本數，雖然「Javascript 大全」不包含很重要的 ES6 部分，但是能夠更全面了解 JS 的演變與歷史，將來在看不同版本的程式碼時，應該可以較為清楚的理解。而「Javascript 忍者」這本是許多前輩推崇的一本好書，雖然以目前的階段來說頗硬，但多了解 JS 深度也是將來會去面對的，將來也勢必會再重讀這一本書，所以就提早了解概況吧。</p><a id="more"></a><p>本篇是主講「Javascript 大全」 裡第七章「陣列」的筆記，僅作為紀錄。</p><h2 id="陣列是什麼"><a href="#陣列是什麼" class="headerlink" title="陣列是什麼"></a>陣列是什麼</h2><p>陣列：是一組有序群集，由中括號[ ]包圍，裡面的元素為「值」(value)，值得位置為「索引」(index)。<br>陣列元素可是任何型別的資料。<br>索引值從 0 開始、最高可是 4294967294、最大陣列元素數 4,294,967,295。<br>陣列繼承自<code>Array.prototype</code>。</p><h2 id="創建陣列"><a href="#創建陣列" class="headerlink" title="創建陣列"></a>創建陣列</h2><h3 id="使用字面值-array-literal"><a href="#使用字面值-array-literal" class="headerlink" title="使用字面值(array literal)"></a>使用字面值(array literal)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> empty = []; </span><br><span class="line"><span class="keyword">let</span> primes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>,<span class="number">7</span>, <span class="number">11</span>]</span><br><span class="line"><span class="keyword">let</span> misc = [<span class="number">1.1</span>, <span class="literal">true</span>, <span class="string">"a"</span>, ] <span class="comment">// misc.length -&gt; 3</span></span><br></pre></td></tr></table></figure><ul><li><p>自面值可以是任意運算式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> kilo = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">let</span> demiKilos = [kilo * <span class="number">0.5</span>, kilo * <span class="number">1.5</span>, kilo * <span class="number">2.5</span>]</span><br></pre></td></tr></table></figure></li><li><p>自面值可包含物件、陣列本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, &#123; <span class="attr">name</span>: <span class="string">"Ayda"</span>, <span class="attr">city</span>: <span class="string">"Paris"</span>, <span class="attr">luckyNumbers</span> :[<span class="number">24</span>,<span class="number">42</span>,<span class="number">15</span>]&#125;]</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用-Array-建構式"><a href="#使用-Array-建構式" class="headerlink" title="使用 Array()建構式"></a>使用 Array()建構式</h3><ul><li><p>不帶引數</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br></pre></td></tr></table></figure></li><li><p>帶引數，引數為陣列長度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">8</span>)</span><br><span class="line"><span class="comment">// 注意：陣列中未有值</span></span><br></pre></td></tr></table></figure></li><li><p>指定陣列值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"Hello"</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="讀取與寫入陣列元素"><a href="#讀取與寫入陣列元素" class="headerlink" title="讀取與寫入陣列元素"></a>讀取與寫入陣列元素</h2><h3 id="運算子"><a href="#運算子" class="headerlink" title="[ ] 運算子"></a>[ ] 運算子</h3><ul><li><p>陣列是特化物件，可用來存取陣列元素的中括號。 -&gt; <code>arr[索引值位置]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"Hello"</span>]</span><br><span class="line"><span class="keyword">let</span> value = arr[<span class="number">0</span>]</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">168</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">3</span> <span class="comment">// index</span></span><br><span class="line">arr[i] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">arr[i+<span class="number">1</span>] = <span class="string">"Hi"</span> <span class="comment">// 索引值為四</span></span><br><span class="line">arr[arr[i]] = arr[<span class="number">0</span>] <span class="comment">// 把arr[0]的值，賦值給等同索引值的4</span></span><br><span class="line">arr <span class="comment">//  ["Hello", 168, empty, 4, "Hello"]</span></span><br></pre></td></tr></table></figure></li><li><p>與存取物件相同，JS 會將指定的陣列索引轉成字串，再將此字串當成特性名稱。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj[<span class="number">1</span>] = <span class="string">"one"</span></span><br><span class="line">obj <span class="comment">// &#123;1: "one"&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>== 陣列裡的「特色名稱」-&gt; index ？ == 其實不一樣</p><ul><li>特色名稱小於 2 的 32 次方（非負數）都會計算入<code>length</code>屬性內，其餘都成為「物件特性名稱」</li><li>陣列索引（array index） !== 物件特性名稱(object property name)</li><li>依索引查找的元素不存在時為<code>undefined</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">arr[<span class="number">2</span>] <span class="comment">// undefined</span></span><br><span class="line">arr[<span class="number">-1</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="稀疏陣列"><a href="#稀疏陣列" class="headerlink" title="稀疏陣列"></a>稀疏陣列</h2><ul><li>不具有從 0 開始的索引</li><li>即使是稀疏陣列，也會被計算至<code>length</code>屬性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [,] <span class="comment">// 沒元素，但 length 為 1</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="literal">undefined</span>] <span class="comment">// undefined 為元素、length 為 1</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> arr1 <span class="comment">// false </span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> arr2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="陣列長度"><a href="#陣列長度" class="headerlink" title="陣列長度"></a>陣列長度</h2><ul><li><p>只要在我們想知道的陣列變數，以方法的方式加上<code>.length</code>。回傳回來的就是這個陣列的長度。</p></li><li><p>不管是密集或稀疏陣列，長度(length)永遠大於索引值(index)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"hi"</span>,<span class="string">"ho"</span>,<span class="string">"woops"</span>,<span class="string">"ciao"</span>];</span><br><span class="line">arr.length <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li><li><p>如果重新指定長度，<code>.length</code>，原本有的會被刪除，沒有的會以空的補上而成為稀疏陣列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">arr.length = <span class="number">10</span></span><br><span class="line">arr <span class="comment">// [1, 2, 3, empty × 7]</span></span><br><span class="line">arr.length = <span class="number">3</span></span><br><span class="line">arr <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>可指定長度為「唯讀」：object.defineProperty()，改變後不可刪元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(arr, <span class="string">'length'</span> ,&#123;</span><br><span class="line">writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line">arr.length = <span class="number">0</span></span><br><span class="line">arr <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="新增或刪除陣列元素"><a href="#新增或刪除陣列元素" class="headerlink" title="新增或刪除陣列元素"></a>新增或刪除陣列元素</h2><h3 id="新增陣列元素"><a href="#新增陣列元素" class="headerlink" title="新增陣列元素"></a>新增陣列元素</h3><ul><li><p>把值指定給新索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = []</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">'Hi'</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">'Hello'</span></span><br></pre></td></tr></table></figure></li><li><p>使用push() 從尾端新增</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.push(<span class="string">'ciao'</span>)</span><br><span class="line">arr <span class="comment">// ["Hi", "Hello", "ciao"]</span></span><br></pre></td></tr></table></figure></li><li><p>使用unshift() 從前端新增</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.unshift(<span class="string">"你好"</span>)</span><br><span class="line">arr <span class="comment">// ["你好", "Hi", "Hello", "ciao"]</span></span><br></pre></td></tr></table></figure></li></ul><p></p><h3 id="刪除陣列元素"><a href="#刪除陣列元素" class="headerlink" title="刪除陣列元素"></a>刪除陣列元素</h3><ul><li><p>使用 delete 運算子，長度不變</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">1</span>] <span class="comment">// true</span></span><br><span class="line">arr <span class="comment">// [1, empty, 3, 4, 5]</span></span><br><span class="line">arr.length <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li><li><p>使用 length 重新指定長度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.length = <span class="number">4</span></span><br><span class="line">arr <span class="comment">// [1, empty, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 pop() 刪除，長度減 1 回傳刪除值 長度改變</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.pop()</span><br><span class="line">arr <span class="comment">// [1, empty, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 shift() 從開頭刪除 1個元素 長度改變</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.shift()</span><br><span class="line">arr <span class="comment">// [empty, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 splice() 插入、刪除、取代 會改變長度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 從index 1 切下 2 個元素 [2, 3]</span></span><br><span class="line">arr <span class="comment">// [1, 4, 5]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="遍歷陣列之迭代"><a href="#遍歷陣列之迭代" class="headerlink" title="遍歷陣列之迭代"></a>遍歷陣列之迭代</h2><ul><li><p>使用 for 迴圈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用 for/in 迴圈，稀疏陣列元素不會被迭代</p></li><li><p>如果迭代順序對演算法很重要，請使用 for 迴圈</p></li><li><p>使用 forEach():將每個元素傳給指定的函式處理</p></li></ul><h2 id="多維陣列"><a href="#多維陣列" class="headerlink" title="多維陣列"></a>多維陣列</h2><p>javascript 並不支持真正的二維陣列，但可使用陣列中的陣列來模擬。</p><h2 id="陣列方法"><a href="#陣列方法" class="headerlink" title="陣列方法"></a>陣列方法</h2><table><thead><tr><th>方法</th><th>功能</th><th>回傳</th><th>原陣列</th></tr></thead><tbody><tr><td>join()</td><td>將陣列的所有元素轉成字串並串接起來</td><td>回傳結果字串</td><td>原陣列不改變</td></tr><tr><td>reverse()</td><td>倒轉陣列的順序</td><td>回傳到轉後的陣列</td><td>原陣列改變</td></tr><tr><td>sort()</td><td>在原陣列上將元素排序</td><td>回傳排序後的陣列</td><td>原陣列改變</td></tr><tr><td>concat()</td><td>將調用此方法的陣列連同引數回傳回來</td><td>創建並回傳一個新陣列</td><td>原陣列不改變</td></tr><tr><td>slice()</td><td>回傳指定陣列的切片</td><td>回傳切片下來的陣列</td><td>原陣列不改變</td></tr><tr><td>splice()</td><td>插入或移除陣列元素</td><td>回傳由它刪除掉的元素</td><td>原陣列改變</td></tr><tr><td>push()</td><td>在陣列尾端加入元素</td><td>回傳陣列的新長度</td><td>原陣列改變</td></tr><tr><td>pop()</td><td>在陣列尾端刪除元素</td><td>回傳它移除掉的元素</td><td>原陣列改變</td></tr><tr><td>unshift()</td><td>在陣列前端加入元素</td><td>回傳陣列的新長度</td><td>原陣列改變</td></tr><tr><td>shift()</td><td>在陣列前端刪除元素</td><td>回傳它移除掉的元素</td><td>原陣列改變</td></tr><tr><td>toString()</td><td>將每個陣列元素轉成字串</td><td>回傳字串</td><td>原陣列不改變</td></tr><tr><td>toLocaleString()</td><td>toString()的本地化</td><td>回傳本地化後的字串</td><td>原陣列不改變</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 日幣</span></span><br><span class="line"><span class="keyword">let</span> prices = [<span class="string">'300'</span>, <span class="number">500</span>, <span class="number">8236</span>, <span class="number">42</span>];</span><br><span class="line">prices.toLocaleString(<span class="string">'ja-JP'</span>,&#123;<span class="attr">style</span>:<span class="string">'currency'</span>,<span class="attr">currency</span>: <span class="string">'JPY'</span>&#125;); </span><br><span class="line"><span class="comment">// "300,￥500,￥8,236,￥42"</span></span><br></pre></td></tr></table></figure><h2 id="ES5-陣列方法"><a href="#ES5-陣列方法" class="headerlink" title="ES5 陣列方法"></a>ES5 陣列方法</h2><ul><li>這些方法的第一個引數大多是函式，它會對陣列中每一個元素都調用一次這個函式。</li><li>不會對稀疏陣列裡不存在的元素起作用。</li><li>第一個參數的函式引數通常有三個：陣列元素值、該陣列元素的索引、陣列本身。</li><li>這些當成第一引數的函式，也接受額外第二引數，如有指定此引數，傳入的函式會被當作第二引數的方法來調用–&gt;傳入的第二引數會變成傳入函式內的<code>this</code>關鍵字的值。</li><li>不會修改調用他們的陣列，如果傳函式給這些方法，就有可能修改陣列。</li></ul><table><thead><tr><th>方法</th><th>功能</th><th>回傳</th><th>原陣列</th></tr></thead><tbody><tr><td>join()</td><td>將陣列的所有元素轉成字串並串接起來</td><td>回傳結果字串</td><td>原陣列不改變</td></tr><tr><td>forEach()</td><td>逐一查用陣列元素，對每個元素調用指定的函式</td><td>回傳調用後的陣列</td><td>原陣列改變</td></tr><tr><td>map()</td><td>將陣列每個元素，逐一傳給指定的函式</td><td>回傳調用後的陣列</td><td>原陣列不改變</td></tr><tr><td>filter()</td><td>將陣列每個元素，逐一傳給指定的函式所給的條件</td><td>回傳符合條件組成的陣列</td><td>原陣列不改變</td></tr><tr><td>every()</td><td>將指定的函式套用在每個陣列元素上</td><td>回傳 true 或 false</td><td>原陣列不改變</td></tr><tr><td>some()</td><td>將指定的函式套用在每個陣列元素上</td><td>回傳 true 或 false</td><td>原陣列不改變</td></tr><tr><td>reduce()</td><td>依指定的函式，結合陣列的元素產生一個值</td><td>回傳產生值得結果</td><td>原陣列不改變</td></tr><tr><td>reduceRight()</td><td>依指定的函式，(右至左)結合陣列的元素產生一個值</td><td>回傳產生值得結果</td><td>原陣列不改變</td></tr><tr><td>indexOf()</td><td>根據指定的值在陣列中(從頭到尾)搜尋元素</td><td>有找到回喘該元素索引值，沒找到回傳-1</td><td>原陣列不改變</td></tr><tr><td>lastIndexOf()</td><td>根據指定的值在陣列中(從尾到頭)搜尋元素</td><td>有找到回喘該元素索引值，沒找到回傳-1</td><td>原陣列不改變</td></tr></tbody></table><h2 id="陣列型別"><a href="#陣列型別" class="headerlink" title="陣列型別"></a>陣列型別</h2><p>判斷是否為陣列，使用Array.isArray()</p><h2 id="類陣列物件（array-like）"><a href="#類陣列物件（array-like）" class="headerlink" title="類陣列物件（array-like）"></a>類陣列物件（array-like）</h2><p>物件，為它加上<code>length</code>屬性 -&gt; 類陣列物件（array-like）<br>以 <code>typeof</code> 來查看陣列，會得到物件 <code>object</code>，但到底陣列和其他物件有什麼不同？最大的不同是陣列有：</p><ul><li><code>length</code>這個特殊屬性</li><li>從<code>Array.prototype</code>繼承過來的許多實用的方法</li><li>陣列的<code>class</code>屬性值為<code>Array</code>這幾點吧。</li></ul><p>但是所謂的「類陣列」(Array-like) 也是如此嗎？並不是。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span>,</span><br><span class="line">    push: <span class="built_in">Array</span>.prototype.push,</span><br><span class="line">    splice: <span class="built_in">Array</span>.prototype.splice</span><br><span class="line">&#125;</span><br><span class="line">obj.push(<span class="string">'d'</span>);</span><br><span class="line">obj; <span class="comment">// &#123;0: "a", 1: "b", 2: "c", 3: "d", length: 4, push: ƒ&#125;</span></span><br></pre></td></tr></table></figure><h2 id="作為陣列的字串"><a href="#作為陣列的字串" class="headerlink" title="作為陣列的字串"></a>作為陣列的字串</h2><ul><li>字串的行為如唯獨的陣列。<h3 id="讀取字串裡個別的字元方法："><a href="#讀取字串裡個別的字元方法：" class="headerlink" title="讀取字串裡個別的字元方法："></a>讀取字串裡個別的字元方法：</h3></li><li>使用 charAt()</li><li>使用中括號 []</li></ul><p>字串是不可變的(immutable)值，如果把他們當成陣列，他們會視為唯讀的陣列。<br>push(), sort(), reverse(), splice() 會修改陣列的方法，不能用在字串上。</p><p>自我推薦：<a href="https://ithelp.ithome.com.tw/users/20104175/ironman/2584" target="_blank" rel="noopener">JavaScript之一定要瞭解的 Array 與方法 :: 第 11 屆 iT 邦幫忙鐵人賽</a></p><p>推薦：<a href="https://hackmd.io/ByKX8O9ETLqsMLeNX2DRGQ?both" target="_blank" rel="noopener">JavaScript 陣列(Array)的方法 - HackMD</a> by 鵬化</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> 讀書會筆記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把要的元素留下來的陣列 Array 方法 filter()</title>
      <link href="/tsuifei.github.io/JS_ironMan33_All-elements-that-pass-the-test-implemented-by-the-provided-function/"/>
      <url>/tsuifei.github.io/JS_ironMan33_All-elements-that-pass-the-test-implemented-by-the-provided-function/</url>
      
        <content type="html"><![CDATA[<h6 id="Array-33"><a href="#Array-33" class="headerlink" title="Array 33"></a>Array 33</h6><blockquote><p>媽媽說，蘋果要挑大顆又漂亮來拜，神明才會保佑我們。</p></blockquote><p><code>map()</code>和<code>filter()</code>常常被稱為最好用的兩個陣列方法，之所以好用，有一個原因是我們可以任意要求對每個元素所做的事，無論是運算或是篩選，不只這樣，這兩個陣列都是會回傳回來一個新的陣列，且不會更動到原來的陣列，處理陣列時，可以拿這兩位兄弟做很多事情哩！</p><a id="more"></a><p>我們先來看看 <code>filter()</code>的基本資訊：<br><strong>原型：</strong> Array.prototype.filter()<br><strong>功能：</strong> 將經指定的函式運算後，由原陣列中通過該函式檢驗的元素回傳一個新陣列。<br><strong>改變：</strong> 不會改變元陣列。<br><strong>語法：</strong> var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])<br><strong>回傳值：</strong> 回傳新陣列，原陣列不改變<br><strong>參數：</strong> callback 函式、<code>thisArg</code>，第二參數可忽略。</p><p>透過<code>filter()</code>函式的第一參數：callback 函式所指定的過濾條件，返回一個新陣列 (非常好用)。例如我們只想保留陣列裡，字串長度大於三的字串元素，可以輕易地取得。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'Jack'</span>, <span class="string">'John'</span>, <span class="string">'May'</span>, <span class="string">'Su'</span>, <span class="string">'Ada'</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value.length &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line">arr2.join(<span class="string">'、'</span>); <span class="comment">//  Jack、John</span></span><br></pre></td></tr></table></figure><p>我們也可以用它搭配可去掉空字串的字串方法<code>trim()</code>，再將陣列沒用或空的元素刪除，就可得到一個新的、乾淨的陣列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'Hello'</span>, <span class="string">''</span>, <span class="string">'Hi'</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="string">'Ciao'</span>, <span class="string">' '</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">inutile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> inutile &amp;&amp; inutile.trim();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">newArr; <span class="comment">// ['Hello', 'Hi', 'Ciao']</span></span><br></pre></td></tr></table></figure><p>需注意的是，在 IE9(不包含 IE9)以下的版本並不支援 trim()方法。<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim" target="_blank" rel="noopener">String.prototype.trim() - JavaScript | MDN</a></p><p><code>filter()</code>好用的原因，除了可以產生一個新陣列，且不會更動到原本的陣列，對於沒有值的元素也不會起作用。而<code>filter()</code>和<code>splice()</code>的不同點，正是<code>filter()</code>不會更動到原陣列。</p><p>在<code>filter()</code>的第一個參數所帶入的 callback 函式，可以帶入多個參數，如果我們只帶入一個參數，這個參數即表示是使用<code>filter()</code>此陣列的元素，而第二與第三個參數則代表元素的索引位置和陣列本身。例如下面這個例子，我們想要過濾出來，大於 5 的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> filtered = array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">filtered; <span class="comment">// [6, 7, 8, 9]</span></span><br><span class="line">array; <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</span></span><br></pre></td></tr></table></figure><p>利用<code>filter()</code>，我們也可以輕鬆地去除陣列裡重複的元素，可以達到這樣的效果是因為使用<code>indexOf()</code>會回傳第一個元素位置的（index），如果之後有重複元素的位置與<code>indexOf()</code>回傳的位置不相等，就會被<code>filter()</code>過濾掉。而這時的過濾結果，只會先保留第一個找到的元素，第二個重複的元素就不會被放進回傳的陣列裡了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'E'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">element, index, self</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">newArr; <span class="comment">// ["B", "A", "E", "C", "F", "G"]</span></span><br></pre></td></tr></table></figure><p>我們更可以把這些去掉重複的元素，且讓陣列的排序整齊一點的功能，包成一個函式，使用起來就方便多了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeDuplicates</span>(<span class="params">originArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = originArray.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arrSelf</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arrSelf.indexOf(value) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result.sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">removeDuplicates(array); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><p>今天的<code>filter()</code>就先介紹到這裡，因為自己也是初級生，想把舊語法先練熟，所以還未使用到箭頭函式，將來應該就會慢慢朝向 ES6 的寫法了。</p><blockquote><p>如有需要改進的地方，拜託懇請告知，我會盡快修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非常彈性好用的陣列 Array 方法 map()</title>
      <link href="/tsuifei.github.io/JS_ironMan32_Calling-a-provided-function-on-every-element-and-return-result/"/>
      <url>/tsuifei.github.io/JS_ironMan32_Calling-a-provided-function-on-every-element-and-return-result/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-32"><a href="#Day-32" class="headerlink" title="Day 32"></a>Day 32</h6><blockquote><p>如果日行一善可以持續，那鐵人應該也可以。</p></blockquote><p>上一篇我們講解了陣列方法的 <code>forEach()</code>，知道它可以做迭代這件事，但在 ECMAScript 5 的陣列方法中大部分的方法都是以迭代為基礎，<code>map()</code>也是。</p><p><code>map()</code>算是陣列方法中最實用的方法之一，我們可以用<code>map()</code>來轉換陣列內的元素，轉換成什麼可由我們決定，以我們想要的方式轉換後，<code>map()</code>會幫我們這些轉換結果，放入另一個新的陣列，回傳回來。</p><a id="more"></a><p>例如，我們有一個含有數字的物件，但只想要取出裡面的數字；或是，我們的陣列裡包含了函式 <del>是啊，陣列裡也可放函式沒忘吧？</del> 但我們需要這些函式的 promise，<code>map()</code>可以幫我們把元素轉換成另一個格式傳回來。</p><p>在「JavaScript 學習手冊」這本書裡有許多範例（有部分修改），我們來試著理解一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shoppingCart = [</span><br><span class="line">  &#123; <span class="attr">itemName</span>: <span class="string">'Book'</span>, <span class="attr">price</span>: <span class="number">220</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">itemName</span>: <span class="string">'Bag'</span>, <span class="attr">price</span>: <span class="number">350</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> itemNames = shoppingCart.map(<span class="function"><span class="params">x</span> =&gt;</span> x.itemName);</span><br><span class="line"><span class="comment">// 只把 itemNames 提取出來</span></span><br><span class="line">itemNames; <span class="comment">// ["Book", "Bag"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 price 打七九折後提取出來</span></span><br><span class="line"><span class="keyword">const</span> discounts = shoppingCart.map(<span class="function"><span class="params">x</span> =&gt;</span> x.price * <span class="number">0.79</span>);</span><br><span class="line">discounts; <span class="comment">// [173.8, 276.5]</span></span><br></pre></td></tr></table></figure><p>當然，用在陣列上也是ㄧ樣的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">newArr = arr.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line">newArr; <span class="comment">//  [1, 4, 9, 16, 25, 36]</span></span><br></pre></td></tr></table></figure><p><a href="https://s0developer0mozilla0org.icopy.site/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">Array.prototype.map() - JavaScript | MDN</a><br><strong>原型：</strong> Array.prototype.map();<br><strong>功能：</strong> 建立一個新的陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。<br><strong>回傳值：</strong> 回傳新陣列，原陣列不改變。對陣列中的各元素進行操作，操作後的值會被寫入新的陣列中並返回。<br><strong>參數：</strong> callback 函式和<code>thisArg</code>第二參數可忽略，可參考前一篇的<a href="https://ithelp.ithome.com.tw/articles/10228571" target="_blank" rel="noopener">forEach</a>。<br><strong>改變：</strong> 不會改變原陣列。<br><strong>語法：</strong> <code>var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])</code></p><p>當我們提供的函式被呼叫的時候，這個函式會使用我們之前提到的 callback 函式的三個參數：元素本身、元素索引和陣列本身。陣列本身這個參數通常比較少用到，利用參數的特性，我們可以輕易地取到我們想要的值和索引：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">arr2.join(<span class="string">'、'</span>); <span class="comment">// 2、4、6、8、10、12</span></span><br></pre></td></tr></table></figure><p><code>map()</code>也可以做到修正陣列這件事，架設我們有一個價格的陣列，只要不超過金額 50 的商品就標示「無折扣」，那麼我們就可以利用<code>map()</code>來過濾與修改這些值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prices = [<span class="number">42</span>, <span class="number">57</span>, <span class="number">89</span>, <span class="number">23</span>, <span class="number">78</span>, <span class="number">12</span>];</span><br><span class="line"><span class="keyword">const</span> newPrices = prices.map(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (elem &lt; <span class="number">50</span>) <span class="keyword">return</span> <span class="string">'no Discount'</span>;</span><br><span class="line">  <span class="keyword">return</span> elem;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">newPrices; <span class="comment">//  ["no Discount", 57, 89, "no Discount", 78, "no Discount"]</span></span><br></pre></td></tr></table></figure><p><code>map()</code>也有一些超級好用的用法。例如，假設我們有兩個不同的陣列，分別是產品名稱和價格，但我們想把它們結合在一起，就可以輕易的利用<code>map()</code>提取元素和索引的特性，來組合成另一組資料。：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [<span class="string">'book'</span>, <span class="string">'cap'</span>, <span class="string">'bag'</span>];</span><br><span class="line"><span class="keyword">const</span> prices = [<span class="number">125</span>, <span class="number">76</span>, <span class="number">390</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = items.map(<span class="function">(<span class="params">elem, index</span>) =&gt;</span> (&#123;</span><br><span class="line">  itemName: elem,</span><br><span class="line">  price: prices[index]</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">listItems;</span><br><span class="line"><span class="comment">// [&#123;itemName: "book", price: 125&#125;,</span></span><br><span class="line"><span class="comment">//  &#123;itemName: "bag", price: 390&#125;,</span></span><br><span class="line"><span class="comment">//  &#123;itemName: "bag", price: 390&#125;]</span></span><br></pre></td></tr></table></figure><p>是不是很神奇？我們在<code>listItems</code>使用了索引的提取，為什麼需要索引？是因為我們想要把<code>items</code>與<code>prices</code>裡的元素用它們的索引連結起來。</p><p><code>map()</code>本身是回傳陣列，我們希望的是物件的資料格式，所以從兩個陣列中提取我們所要的資訊，在 callback 函式裡前後加上<code>{}</code>，再把我們提取的元素放入，回傳就會是物件了。</p><p>需要注意的是，我們必須用<code>( )</code>將物件格式包起來，如果沒包起來，箭頭函式的寫法會將大括號視為區塊標示。</p><p>今天的陣列 Array 方法 <code>map()</code>就介紹到此，接下來的陣列方法會繼續持續下去喔～</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 迴圈升級的陣列 Array 方法 forEach()</title>
      <link href="/tsuifei.github.io/JS_ironMan31_Executes-a-provided-function-once-for-each-array-element/"/>
      <url>/tsuifei.github.io/JS_ironMan31_Executes-a-provided-function-once-for-each-array-element/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-31"><a href="#Day-31" class="headerlink" title="Day 31"></a>Day 31</h6><blockquote><p>別一張張的發傳單，宣傳什麼折扣吧！NewsLetters 鍵按寄出一次搞定，像迭代一樣。</p></blockquote><p>前幾篇我們聊到了 ECMAScript 5 的陣列方法，聊到這些方法都有迭代（iterating）的特色，也就是把我們想要執行的函式，從頭到尾逐一（iterates through）的把陣列裡的元素帶進去這個函式處理一遍，<code>forEach()</code>便是我們會常用的方法之一。</p><a id="more"></a><p>我們直接看看在大犀牛裡的範例，直接以<code>forEach()</code>取陣列的值來相加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  sum += value;</span><br><span class="line">&#125;);</span><br><span class="line">sum; <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>或是為每個陣列元素遞增，而原陣列也會因為<code>forEach()</code>所帶入的函式而改變原有的陣列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">  array[index] = value + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">data; <span class="comment">// [2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p><a href="https://s0developer0mozilla0org.icopy.site/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener">Array.prototype.forEach() - JavaScript | MDN</a><br><strong>原型：</strong> Array.prototype.foreach()<br><strong>功能：</strong> 對陣列的每個元素執行一次提供的函數。<br><strong>改變：</strong> 不會直接改變原陣列，但可能會依帶入的函式而改變。<br><strong>語法：</strong> arr.forEach(callback[, thisArg]);<br><strong>回傳值：</strong> undefined。<br><strong>參數：</strong> callback 函式與 thisArg</p><p>我們來看一下<code>forEach()</code>較完整的語法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//your iterator</span></span><br><span class="line">&#125;[, thisArg]);</span><br></pre></td></tr></table></figure><p><code>forEach()</code>本身可帶兩個參數，第一個是必須的 callback 函式，第二個參數 thisArg 是可選擇性的。這個 callback 函式會將 Array 中的每一個元素作為參數，帶進這個 callback 函式裡，每個元素各執行一次。</p><p>而第一個 callback 函式則可傳入三個參數：</p><ol><li>currentValue 目前被處理的陣列元素值</li><li>index 目前被處理的陣列元素索引(可選)</li><li>array 呼叫 forEach()陣列本身(可選)</li></ol><p>如果我們只需要陣列的值，也可寫成只有一個參數的函式，其他的會被忽略。</p><p><code>forEach()</code>的第二個參數<code>thisArg</code>是可選擇性的，如果有這個參數，它就會被作為 callback 回呼函式每次被調用的 this 的值。需要注意的是 callback 函式，如果是箭頭函式，則在創建該函數時已按詞法綁定，因此 thisArg 不會起作用。</p><p>我們來看一下例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="comment">// 沒有第二參數 thisArg</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  sum += x;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有第二參數 thisArg</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;, arr); <span class="comment">// this -&gt;obj</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">[ 5, 10, 20, 30 ]</span></span><br><span class="line"><span class="comment">[ 5, 10, 20, 30 ]</span></span><br><span class="line"><span class="comment">[ 5, 10, 20, 30 ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>因為 callback 函式的第二個參數，會改變 scop 範疇、改變 this 的值，也就是這個函式裡的<code>arr</code>，也因此會印出三次參數<code>thisArg</code>的<code>arr</code>。</p><p>在真實的情境裡我們比較少用到 callback 函式的第二個參數，在「Secrets of the JavaScript Ninja」忍者這本書的第四章有更詳盡的說明。</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 陣列 Array 之小菜還沒出完</title>
      <link href="/tsuifei.github.io/JS_ironMan30_Array-dinner-is-not-finished/"/>
      <url>/tsuifei.github.io/JS_ironMan30_Array-dinner-is-not-finished/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-30"><a href="#Day-30" class="headerlink" title="Day 30"></a>Day 30</h6><blockquote><p>據聞，在法國晚餐可以從七點半吃到 11 點。婚宴呢？可以從晚上十點吃到凌晨五點。我的鐵人賽大概就是這個概念。</p></blockquote><p>從來沒想過，自己可以寫陣列寫得這麼久，每天都會超過三百字以上，有時想想，老天鵝！也才一個陣列就這樣寫了一個月還不夠，那物件、異步、範疇、正規和 promise 不就排到明年去了？</p><p>打從轉職到現在，學習路上一直是沮喪、坎坷、壓力、燒腦的無盡迴圈，就像寫遞迴ㄧ樣，幾次的無限迴圈搞到無法關機，真的是會讓人嚇到。問自己嚇到後還要不要寫？要！因為這或許會成為下半輩子的樂趣之一。</p><a id="more"></a><p>寫程式對自己而言，好像是右撇子換成左手寫字，以往直覺性的設計腦袋開始要試著把邏輯理出來，真的是件不太容易的事。轉職一年半載的，如果說不太容易，也表示說有機會變成容易，因為深信，「不可能」是不存在的，所以一路跌跌撞撞到現在。</p><p>不過，能夠還在學習的路上，真的是要感謝蠻多人的，無論是指導與教授的饅頭，或是一起學習討論，甚至是在網路上的社群裡，或留言指正的朋友，這些點點滴滴都讓自己更有勇氣的繼續下去。雖然最終的目的是能夠轉職成功，也就是找一份工作，但是學習這個旅程已經很精彩，這個旅程也ㄧ定會繼續下去。</p><p>鐵人賽期間，除了自己發文，也發現了好多很棒的主題，尤其一些大神們的文章，更是篇篇精彩，只是，寫文剩餘的時間要把這些系列文章看完，實在不容易，所以賽後也會繼續把這些文章慢慢地消化與學習。</p><p>參賽期間，常常透過胡大的<a href="https://ithelp.ithome.com.tw/users/20091346/ironman/2621" target="_blank" rel="noopener">後設鐵人：我從其他鐵人們身上學到的事</a>系列，得到更多的好文推薦，且每天可以跟著去想念的歐洲旅行，實在舒壓不少，這裡是ㄧ定要繼續回頭挖寶的。</p><p>以下是賽後想讀的系列文章：<br>一起學習的夥伴們的文章，篇篇都想讀，且很多是以讀 Spec 為主，真的相當佩服。</p><h3 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML+CSS"></a>HTML+CSS</h3><p><a href="https://ithelp.ithome.com.tw/users/20111825/ironman/2549" target="_blank" rel="noopener">每天來點 CSS Specification</a> by Ruru<br><a href="https://ithelp.ithome.com.tw/users/20112726/ironman/2274" target="_blank" rel="noopener">鉄人 28 號 FX </a> by letter liu<br><a href="https://ithelp.ithome.com.tw/users/20117586/ironman/2617" target="_blank" rel="noopener">重新認識 CSS</a> by Titangene<br><a href="https://ithelp.ithome.com.tw/users/20120683/ironman/2609" target="_blank" rel="noopener">從門外漢到前端新手</a> by JinWe<br><a href="https://ithelp.ithome.com.tw/users/20120740/ironman/2632" target="_blank" rel="noopener">前端新手進化史</a> by yachen</p><h3 id="超想了解的無障礙網頁"><a href="#超想了解的無障礙網頁" class="headerlink" title="超想了解的無障礙網頁"></a>超想了解的無障礙網頁</h3><p><a href="https://ithelp.ithome.com.tw/users/20108045/ironman/2454" target="_blank" rel="noopener">實踐無障礙網頁設計（Web Accessibility）</a> by Askie Lin</p><h3 id="JavaScript-框架"><a href="#JavaScript-框架" class="headerlink" title="JavaScript + 框架"></a>JavaScript + 框架</h3><p><a href="https://ithelp.ithome.com.tw/users/20120099/ironman/2593" target="_blank" rel="noopener">JavaScript 試煉之旅</a> by Penghua<br><a href="https://ithelp.ithome.com.tw/users/20120053/ironman/2273" target="_blank" rel="noopener">Typescript 初心者手札</a> by Kira<br><a href="https://ithelp.ithome.com.tw/users/20112158/ironman/2614" target="_blank" rel="noopener">技術在走，Vue.js 要有</a> by mangoSu</p><h2 id="其他大神與高手的系列文章"><a href="#其他大神與高手的系列文章" class="headerlink" title="其他大神與高手的系列文章"></a>其他大神與高手的系列文章</h2><h3 id="HTML-CSS-1"><a href="#HTML-CSS-1" class="headerlink" title="HTML+CSS"></a>HTML+CSS</h3><p><a href="https://ithelp.ithome.com.tw/users/20112550/ironman/2072" target="_blank" rel="noopener">金魚都能懂的網頁設計入門 - 金魚都能懂了你還怕學不會嗎</a> by CSScoke<br><a href="https://ithelp.ithome.com.tw/users/20112550/ironman/2092" target="_blank" rel="noopener">連續 30 天的超實務網頁設計的垂直置中教學</a> by CSScoke</p><h3 id="JavaScript-框架-1"><a href="#JavaScript-框架-1" class="headerlink" title="JavaScript + 框架"></a>JavaScript + 框架</h3><p><a href="https://ithelp.ithome.com.tw/users/20103315/ironman/2668" target="_blank" rel="noopener">從 Hooks 開始，讓你的網頁 React 起來</a> by pjchender<br><a href="https://ithelp.ithome.com.tw/users/20103565/ironman/2527" target="_blank" rel="noopener">深入現代前端開發</a> by 愷開<br><a href="https://ithelp.ithome.com.tw/users/20092232/ironman/1612" target="_blank" rel="noopener">你懂 JavaScript 嗎？</a> by cythilya(桑夏)<br><a href="https://ithelp.ithome.com.tw/users/20106935/ironman/2188" target="_blank" rel="noopener">在 React 生態圈內打滾的一年 feat. TypeScript</a> by 神 Q 超人<br><a href="https://ithelp.ithome.com.tw/users/20119924/ironman/2235" target="_blank" rel="noopener">透過 ESLint 練習 JavaScript ES6</a> by 江江好<br><a href="https://ithelp.ithome.com.tw/users/20106426/ironman/2136" target="_blank" rel="noopener">前端工程師用 javaScript 學演算法</a> by hannahpun<br><a href="https://ithelp.ithome.com.tw/users/20120757/ironman/2708" target="_blank" rel="noopener">跟著 YDKJS 作者 Kyle Simpson 打造全新 JavaScript Mindset</a> by Ashe Li</p><h3 id="很棒的綜合經驗"><a href="#很棒的綜合經驗" class="headerlink" title="很棒的綜合經驗"></a>很棒的綜合經驗</h3><p><a href="https://ithelp.ithome.com.tw/users/20040221/ironman/2236" target="_blank" rel="noopener">菜鳥工程師必修的 30 堂溝通課</a> by 廖洧傑<br><a href="https://ithelp.ithome.com.tw/users/20083608/ironman/2055" target="_blank" rel="noopener">前端「設計」聖光之路</a> by 卡斯伯<br><a href="https://ithelp.ithome.com.tw/users/20104132/articles" target="_blank" rel="noopener">試著把切版專案升級到 gulp4.0 吧</a> by ayugioh2003</p><p>感謝曾在這裡留言的朋友們，給本人的指正與鼓勵，更感謝以上這些參賽者用心且堅持的寫出這些好文，知識分享是這世界上最美的事，也因此，期望自己可以秉持著同樣的信念，產出有用的文章。</p><h4 id="30-天只是一個月，也只是開始，接下來還沒寫完的陣列方法還會繼續喔～-A-bientot-D"><a href="#30-天只是一個月，也只是開始，接下來還沒寫完的陣列方法還會繼續喔～-A-bientot-D" class="headerlink" title="30 天只是一個月，也只是開始，接下來還沒寫完的陣列方法還會繼續喔～ À bientôt ! :-D"></a>30 天只是一個月，也只是開始，接下來還沒寫完的陣列方法還會繼續喔～ À bientôt ! :-D</h4><p><img src="https://ithelp.ithome.com.tw/upload/images/20191015/20104175fmQbvF3tW7.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191015/20104175fmQbvF3tW7.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS ECMAScript 5 的陣列 Array 方法淺析</title>
      <link href="/tsuifei.github.io/JS_ironMan29_About-ECMAScript5s-Array-Method/"/>
      <url>/tsuifei.github.io/JS_ironMan29_About-ECMAScript5s-Array-Method/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-29"><a href="#Day-29" class="headerlink" title="Day 29"></a>Day 29</h6><blockquote><p>生活要簡約，寫程式也是。但是，可能嗎？</p></blockquote><p>ECMAScript 5 的陣列方法，除了前兩篇介紹的<code>indexOf()</code>和<code>lastIndexOf()</code>外，還有許多非常好用的方法，這些方法包含了對陣列做迭代（iterating）、對映（mapping）、過濾（filtering）、測試（testing）、約簡（reducing）<del>這是什麼？！</del> 和搜尋(search)的功能。</p><p>剛開始接觸這些「動詞」時，實在有點不知所措，我們先來了解一下這些詞的意義。因為這些詞用在不同的領域會有不太相同的解釋，所以我們以 JavaScript 的解釋為主。中文翻譯部分也會以「JavaScript 大全中文版」為主。</p><a id="more"></a><p><img src="https://ithelp.ithome.com.tw/upload/images/20191014/20104175XLumawbfhE.png" alt="https://ithelp.ithome.com.tw/upload/images/20191014/20104175XLumawbfhE.png"></p><h3 id="迭代（iterating）"><a href="#迭代（iterating）" class="headerlink" title="迭代（iterating）"></a>迭代（iterating）</h3><ul><li>forEach()</li></ul><p>Iterate 的中文是「重複」，在程式裡指的是反覆運算，如果我們希望程式重複的做一件事，最常想到的是迴圈，重複執行一項指令。而迭代也和迴圈相似，反覆的運算直到不符合我們給的條件而停止。迭代也常被拿來和「遞迴」（Recursively）一起討論，遞迴算是迭代的升級版，和迭代最大的不同是，遞迴會把我們運算出來的結果，當作下一次重複的初始值，直到找到符合我們要的值與到達終止的條件。<br>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BF%AD%E4%BB%A3" target="_blank" rel="noopener">疊代 - 維基百科，自由的百科全書</a></p><h3 id="對映（mapping）"><a href="#對映（mapping）" class="headerlink" title="對映（mapping）"></a>對映（mapping）</h3><ul><li>map()</li></ul><p>有些書上也會把 mapping 翻譯成鏡射或是映射。較容易理解的解釋是我們對每一個陣列上的元素做一些「加工」，然後加工後的結果，再依原本的陣列順序「存放」在另一個新的陣列裡。例如，我們希望對每個陣列裡的數字做「同樣」的運算，然後再把這些運算完的結果，照順序放到另一個陣列裡。<br>參考：<a href="https://en.wikipedia.org/wiki/Mapping" target="_blank" rel="noopener">Mapping - Wikipedia</a></p><h3 id="過濾（filtering）"><a href="#過濾（filtering）" class="headerlink" title="過濾（filtering）"></a>過濾（filtering）</h3><ul><li>filter()</li></ul><p>相較於其他，過濾很容易懂。顧名思義就像是過濾器，很像我們常用的 if 語句，只把我們想要的（符合條件）留下來，集合起來成另一個陣列。</p><h3 id="測試（testing）"><a href="#測試（testing）" class="headerlink" title="測試（testing）"></a>測試（testing）</h3><ul><li>every()</li><li>some()</li></ul><p>測試這個詞大家都懂，但是本人覺得這裡的測試，比較像是「是非題」，檢查陣列元素時，如果有一個符合我們給的條件，就會回傳 true，全部都不符合條件就會回傳 false。感覺這樣的運作方式很像 JavaScript 裡的邏輯運算子的 AND <code>&amp;&amp;</code>和 OR<code>||</code>，如果是<code>||</code>，只要有一個是<code>true</code>就算其他的都是<code>false</code>也會回傳<code>true</code>。</p><h3 id="約簡（reducing）"><a href="#約簡（reducing）" class="headerlink" title="約簡（reducing）"></a>約簡（reducing）</h3><ul><li>reduce()</li><li>reduceRight()</li></ul><p>Reducer 的中文是「減速器」<del>是在簡約什麼？</del>，這聽起來有點古怪，被稱為 reduce 的原因是因為，我們通常會用它來將陣列精簡成一個值，例如加總或計算陣列的平均值。也就是說，依據我們指定的函式，結合陣列的元素而產生一個值。這樣的方式常被拿來用在程式中的運算，所以也會被成為注入（inject）或折疊（fold）。</p><h3 id="搜尋-searching"><a href="#搜尋-searching" class="headerlink" title="搜尋(searching)"></a>搜尋(searching)</h3><ul><li>indexOf()</li><li>lastIndexOf()</li></ul><p>search 相信大家都知道，這個詞就是搜尋和查找的意思，這些方法會依照我們給的值，去陣列裡查找，並將找到的這個值的位置回傳給我們。這兩個搜尋的方法，是少數不以函式當參數的陣列方法。</p><h3 id="ECMAScript-5-的陣列方法共同的特徵"><a href="#ECMAScript-5-的陣列方法共同的特徵" class="headerlink" title="ECMAScript 5 的陣列方法共同的特徵"></a>ECMAScript 5 的陣列方法共同的特徵</h3><p>以上就是 ECMAScript 5 的陣列方法的淺略解析，基本上這些方法都有一些共同的特徵：</p><ol><li>這些方法的基礎都是使用「迭代」，對陣列元素重複做同一件事。</li><li>這些方法的參數大多是函式，以呼叫(callback)函式的方法，來當此方法的參數，且會對陣列裡的元素執行一次此函式。</li><li>如果陣列是稀疏的，指定使用的函式不會在這些稀疏陣列上起作用。</li><li>陣列方法的參數函式會用三個引數來調用：陣列的元素值、陣列的索引值以及陣列本身。通常只需引數的第一個，可忽略第二、三個引數。</li><li>陣列方法的參數函式也可接受額外的第二引數（如語法的[, thisArg]），如果有此第二引數，那麼傳入的參數函式會被當作第二引數的方法來調用，等同於我們傳入的第二引數會變成傳入的參數函式內的<code>this</code>關鍵字的值。這部分是不是感覺有點混亂？ <del>我也是</del>我們之後有更詳細的說明。</li></ol><p>如果能了解上面的特性與規則，相信碰上 ECMAScript 5 的陣列方法，用起來就會更得心應手了。</p><p>原本是想要今天開始進入 ECMAScript 5 陣列方法的重心的 <del>進入內心戲</del>，但是看來應該是要在鐵人賽之後了，明天是鐵人賽的最後一天，總是要聊一下參賽感言，感言講完了，我們再好好的來聊聊這幾個 ECMAScript 5 非常重要的陣列方法囉！<del>沒錯！我想繼續鐵人！</del></p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 陣列 Array 方法，找出最後一個元素的索引值 lastIndexOf()</title>
      <link href="/tsuifei.github.io/JS_ironMan28_Find-the-index-value-of-the-last-element/"/>
      <url>/tsuifei.github.io/JS_ironMan28_Find-the-index-value-of-the-last-element/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-28"><a href="#Day-28" class="headerlink" title="Day 28"></a>Day 28</h6><blockquote><p>你！就是你。那個最後一個戴黑帽黑衣的站出來！你認識那位排在前頭和你穿ㄧ樣的俠客嗎？</p></blockquote><p>昨天我們介紹了<code>indexOf()</code>，今天要來介紹和它算是一對的<code>lastIndexOf()</code>。<br><code>lastIndexOf()</code>會把我們指定的元素，在陣列裡查找，並將陣列裡「最後一個」找到的元素索引值 <del>其實也是第一個</del>，傳回來給我們。</p><a id="more"></a><p>但這兩個方法有什麼不同？我們先來看一下範例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'hi'</span>, <span class="string">'D'</span>, <span class="string">'hi'</span>, <span class="string">'b'</span>, <span class="string">'hi'</span>];</span><br><span class="line"></span><br><span class="line">arr.indexOf(<span class="string">'hi'</span>); <span class="comment">// 2 第一個 "hi"</span></span><br><span class="line"></span><br><span class="line">arr.lastIndexOf(<span class="string">'hi'</span>); <span class="comment">// 6 最後一個 "hi"</span></span><br></pre></td></tr></table></figure><p>兩個操作的方式幾乎是ㄧ樣的，只是<code>indexOf()</code>會把第一個找到元素的索引值傳回來，而<code>lastIndexOf()</code>顧名思義，就是把在陣列裡，我們指定要找元素，且是在陣列裡面最後一個的索引值傳回來。且<code>lastIndexOf()</code>在找尋元素時，會從陣列的尾端開始找。因為找尋的順序相反，所以找到的第一個元素，其實也就是從陣列看來的最後一個。</p><p>如同<code>indexOf()</code>ㄧ樣，如果我們有給第二個參數（從哪裡開始找），它也會從指定參數開始往「前」找。</p><p>如果<code>lastIndexOf()</code>找不到我們想找的元素，也會和<code>indexOf()</code>ㄧ樣，回傳給我們 -1。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf" target="_blank" rel="noopener">Array.prototype.lastIndexOf() - JavaScript | MDN</a></p><p><strong>原型：</strong> Array.prototype.lastIndexOf()<br><strong>功能：</strong> 回傳指定元素在陣列中最後一個被找到的索引值。<br><strong>改變：</strong> 不會改變原陣列<br><strong>語法：</strong> arr.lastIndexOf(searchElement[, fromIndex])<br><strong>回傳值：</strong> 在陣列中找到的最後一個元素索引值；沒找到則為 -1。<br><strong>參數：</strong> 要找的元素、從哪裡開始找。</p><h3 id="確定這個元素是陣列的唯一"><a href="#確定這個元素是陣列的唯一" class="headerlink" title="確定這個元素是陣列的唯一"></a>確定這個元素是陣列的唯一</h3><p>我們是不是可以利用<code>indexOf()</code>和<code>lastIndexOf()</code>的特性來確認我們找到的元素，是陣列裡的唯一？我們可以用 <code>===</code> 來比較，如果相同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'hi'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> item1 = arr2.indexOf(<span class="string">'hi'</span>); <span class="comment">// item1 回傳 2</span></span><br><span class="line"><span class="keyword">let</span> item2 = arr2.lastIndexOf(<span class="string">'hi'</span>); <span class="comment">// item2 回傳 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testUnique</span>(<span class="params">item1, item2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (item1 === item2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testUnique(item1, item2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="找出所有陣列裡指定的索引值"><a href="#找出所有陣列裡指定的索引值" class="headerlink" title="找出所有陣列裡指定的索引值"></a>找出所有陣列裡指定的索引值</h3><p>在上一篇<code>indexOf()</code>的介紹裡有提到，我們可透過<code>indexOf()</code>與<code>push()</code>將查找到的元素列表，以陣列的方式回傳回來，<code>lastIndexOf()</code>也可以辦到。它會尋找所有在陣列裡，我們指定查找元素的索引值，以<code>push()</code>將索引值集合在一個陣列裡。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> results = [];</span><br><span class="line"><span class="keyword">const</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>];</span><br><span class="line"><span class="keyword">let</span> element = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">let</span> idx = array.lastIndexOf(element); <span class="comment">// 把找到的索引值存在變數裡</span></span><br><span class="line"><span class="keyword">while</span> (idx != <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果回傳值不是 -1 表示有找到</span></span><br><span class="line">  results.push(idx); <span class="comment">// 將索引值放入陣列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果索引值大於 0，就回傳 找到的元素索引值，否則就回傳 -1</span></span><br><span class="line">  idx = idx &gt; <span class="number">0</span> ? array.lastIndexOf(element, idx - <span class="number">1</span>) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">results; <span class="comment">// [4, 2, 0]</span></span><br></pre></td></tr></table></figure><p>與<code>indexOf</code>的方法不同的是，因為<code>lastIndexOf()</code>是從陣列尾端往前找，所以得到的索引值也會從大到小。</p><p>今天的<code>lastIndexOf()</code>就介紹到這裏囉～</p><hr><p>我們在學習程式語言的時候，除了會去看一些技術文章或是影片教學外，大家是否會去看一些比較軟性的影片，如勵志或是如何規劃學習的影片？尤其對於轉職的本人來說，到底程式工程師需要有什麼樣的特質與正確的心態，甚至在職場上如何面對工作的壓力，與如何快速的進步 <del>對本人無效</del>，是需要一些技巧的。</p><p>發現這個法國的 youtuber 是在兩三個月前，他稱他自己為遊牧開發人員，人住在巴釐島，除了有許多遠端的案子，還有經營 youtube 頻道、做教學影片，甚至前陣子還在巴釐島開了課，請法國人到亞洲包吃包住學程式。</p><p>他的影片有許多是在討論他的觀察與想法，因為直接且真誠，所以頗受歡迎。前一陣子看到這個影片覺得頗正面，便把它記錄下來，如果有興趣，可以使用 youtube 的字幕翻譯功能觀看。</p><h2 id="如果早知道，對初學者的建議"><a href="#如果早知道，對初學者的建議" class="headerlink" title="如果早知道，對初學者的建議"></a>如果早知道，對初學者的建議</h2><p>這支影片聊的主題是，一些他覺得剛開始學習程式語言的人，可以提前了解的學習面向，以下是大約的節錄：<br><a href="https://www.youtube.com/watch?v=G34p5eFg634" target="_blank" rel="noopener">CE QUE J’AURAIS AIMÉ SAVOIR QUAND J’AI DÉBUTÉ LA PROGRAMMATION - YouTube</a></p><h3 id="第一"><a href="#第一" class="headerlink" title="第一"></a>第一</h3><p>不要什麼都想學，學你需要用到的技術或程式語言，專注這些就好。例如，如果你想學前端，就必須先瞭解前端需要用到什麼語言，例如 HTML, CSS, JavaScript 就先把這些學好，而不要一下子就跳到 Node 或急著想了解框架。且前端變化大，或許開始學到真正用到這段期間，還會有許多的變化產生。</p><h3 id="第二"><a href="#第二" class="headerlink" title="第二"></a>第二</h3><p>剛開始學寫程式的時候，只要達到會寫與會動，可以運作就可以了，要讓它運作，需要什麼東西要先思考。初期要寫出來的程式碼完美，是不可能的，可以先試著寫出來，可以運作，再慢慢回頭重構你的碼。</p><h3 id="第三"><a href="#第三" class="headerlink" title="第三"></a>第三</h3><p>把注意力集中在專案，而不是技術或新的語言。新的技術或者是語言，或許可以做更多的功能，但瀏覽者看到的是什麼？使用者看到的是什麼？看到的是具體的專案呈現。技術語言只是工具，如果學新技術，還是需要實做來呈現，也就是做專案。</p><p>希望以上的分享，大家會喜歡。</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 找出元素索引值的陣列 Array 方法 indexOf()</title>
      <link href="/tsuifei.github.io/JS_ironMan27_Finding-element-index-values-in-an-array/"/>
      <url>/tsuifei.github.io/JS_ironMan27_Finding-element-index-values-in-an-array/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-27"><a href="#Day-27" class="headerlink" title="Day 27"></a>Day 27</h6><blockquote><p>那一排，都是穿黑衣戴口罩的，去幫我找出搗亂的。抱歉，我只能給你 -1 因為連我們偶爾都會穿黑衣戴口罩。</p></blockquote><p>終於，我們要進入 ECMAScript 5 的陣列方法了！<br>ECMAScript 5 定義了許多很重要的陣列方法，包括了過濾、檢測、遍歷、搜索和鏡射的方法，讓我們能更輕易的操控陣列與陣列元素。</p><p>但是今天是週末，我們先來介紹相對比較沒那麼複雜的<code>indexOf()</code>。</p><a id="more"></a><p><code>indexOf()</code>方法像是一個會通風報信的吹哨人，請它去幫忙找出陣列裡面的某個指定元素，它就會 <del>明查暗訪</del> 幫我們把這個元素找出來，並告訴我們這個元素在哪個位置（索引值），它只會給我們「第一個」找到的位置 <del>表示有交差</del>，如果沒有找到，<code>indexOf()</code>就會回傳給我們 -1 表示在陣列裡找不到這個元素。</p><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" target="_blank" rel="noopener">Array.prototype.indexOf() - JavaScript | MDN</a></p><h1 id="陣列處理方法集合"><a href="#陣列處理方法集合" class="headerlink" title="陣列處理方法集合"></a>陣列處理方法集合</h1><p><strong>原型：</strong> Array.prototype.indexOf()<br><strong>功能：</strong> 搜尋陣列中指定的值。<br><strong>改變：</strong> 不會改變原陣列。<br><strong>語法：</strong> arr.indexOf(searchElement[, fromIndex])<br><strong>回傳值：</strong> 在陣列中找到的第一個元素索引值；沒找到則為 -1。<br><strong>參數：</strong> 要找的元素、從哪裡開始找。</p><p>為了不混淆，我們以字串元素來示範</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'D'</span>, <span class="string">'C'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 沒給參數，不知道我們要找的元素是什麼，回傳 -1 很合理。</span></span><br><span class="line">arr.indexOf(); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到的 "c" 在索引值 2 的位置</span></span><br><span class="line">arr.indexOf(<span class="string">'c'</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 從索引值 2 的位置開始找，所以找到第二個 "b"</span></span><br><span class="line">arr.indexOf(<span class="string">'b'</span>, <span class="number">2</span>); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 從索引值 3 的位置開始找，會區分大小寫，找不到 "c" 回傳 -1</span></span><br><span class="line">arr.indexOf(<span class="string">'c'</span>, <span class="number">3</span>); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二參數預設就是 0 ，這裡有寫沒寫都ㄧ樣</span></span><br><span class="line">arr.indexOf(<span class="string">'c'</span>, <span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二參數 -5 表示從後面數過來 -5 的位置開始找，所以找得到 "c"</span></span><br><span class="line">arr.indexOf(<span class="string">'c'</span>, <span class="number">-5</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是從 -5 開始找就找不到"c" 所以回傳 -1</span></span><br><span class="line">arr.indexOf(<span class="string">'c'</span>, <span class="number">-4</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h3 id="參數的規則很直覺"><a href="#參數的規則很直覺" class="headerlink" title="參數的規則很直覺"></a>參數的規則很直覺</h3><p><code>indexOf()</code>可帶兩個參數，第一個參數<code>searchElement</code>是指定要找尋的元素，第二個參數<code>fromIndex</code>索引值，不是必須，表示要從哪一個位置開始搜尋。如果這個索引值大於或等於陣列的長度，會直接回傳 -1，因為要開始搜尋的元素都已經超過陣列長度，自然搜尋就起不了作用。</p><p>如果給的<code>fromIndex</code>索引值是一個負數，就會從陣列的最後一個往回算，等同最後一個的索引值是 -1，以此類推。</p><p>雖然表示往回算，但<code>indexOf()</code>的搜尋順序依然會從陣列的左往右一一搜尋。如果負數索引值在回頭計算之後仍然小於 0，則會從左往右全部搜尋。</p><p>這個參數的預設值為 0（即搜尋整個陣列）。還有，<code>indexOf()</code>並不像其他大部分的 ECMAScript 5 陣列方法一樣，參數可以帶函式，帶函式參數對<code>indexOf()</code>是無效的。</p><h3 id="找出所有陣列裡指定的索引值"><a href="#找出所有陣列裡指定的索引值" class="headerlink" title="找出所有陣列裡指定的索引值"></a>找出所有陣列裡指定的索引值</h3><p>雖然<code>indexOf()</code>只會回傳給我們第一個找到的元素位置，但是我們可以使用迴圈，將陣列裡面所有符合搜尋條件元素的索引值，放在一個陣列裡：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findAll</span>(<span class="params">arr, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> results = [];</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">let</span> fromIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (fromIndex &lt; len) &#123;</span><br><span class="line">    fromIndex = arr.indexOf(element, fromIndex);</span><br><span class="line">    <span class="keyword">if</span> (fromIndex === <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 沒找到完成搜尋</span></span><br><span class="line">    results.push(fromIndex); <span class="comment">// 將找到的索引值放入陣列</span></span><br><span class="line">    fromIndex = fromIndex + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = findAll(arr, <span class="string">'b'</span>);</span><br><span class="line">result; <span class="comment">// [1, 5]</span></span><br></pre></td></tr></table></figure><p>如果可以將找到的索引位置的值，集中放入陣列裡是不是更方便？<code>indexOf()</code>雖然無法直接做到，但是有其他方法可以做到這些，例如 ECMAScript 5 的<code>filter</code>或 ECMAScript 6 的<code>find()</code>都可以輕易辦到。</p><h3 id="參考型別的元素找法"><a href="#參考型別的元素找法" class="headerlink" title="參考型別的元素找法"></a>參考型別的元素找法</h3><p>和某些部分陣列的方法ㄧ樣，<code>indexOf()</code>是無法直接查找參考型別的元素，像是陣列、物件，需要將這些元素指定給一個變數，這個變數在陣列裡，就可使用<code>indexOf()</code>到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'a'</span>, &#123; <span class="attr">a</span>: <span class="number">42</span> &#125;];</span><br><span class="line"></span><br><span class="line">arr2.indexOf(<span class="string">'a'</span>); <span class="comment">// 0 找得到</span></span><br><span class="line">arr2.indexOf(&#123; <span class="attr">a</span>: <span class="number">42</span> &#125;); <span class="comment">// -1 找不到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 將元素指定給變數</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">42</span>, arr];</span><br><span class="line">arr3.indexOf(arr); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> arr4 = [<span class="string">'a'</span>, obj, <span class="number">12</span>];</span><br><span class="line">arr4.indexOf(obj); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>其實，還有另一個<code>indexOf()</code>的孿生陣列方法<code>lastIndexOf()</code>功能和<code>indexOf()</code>差不多 <del>簡直ㄧ樣</del>，我們明天可以來聊聊，順便穿插一些輕鬆題外話～敬請期待囉～</p><p>才剛要介紹 ECMAScript 5 的陣列方法，鐵人賽就快要結束了，那 ECMAScript 6 呢？ <del>不長進的留到明年寫嗎？</del> 參加鐵人賽所獲得的，也不只是介紹這些方法而已。因鐵人賽讓本人開始了解查找資料的樂趣 <del>大嬸瘋了</del> 所以，應該會繼續不定期寫下去喔～</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote><h6 id="開頭的那句開場白，寫的時候有點心驚驚，會不會太敏感、會不會太表明立場？所謂民主，應該是不需要懼怕這些的，所謂民主，應該是可以讓人們自由的發表言論而不被壓抑，民主的另一種姿態是勇敢，勇敢捍衛這些得來不易的自由。-這些絕對不是要湊字數-XD"><a href="#開頭的那句開場白，寫的時候有點心驚驚，會不會太敏感、會不會太表明立場？所謂民主，應該是不需要懼怕這些的，所謂民主，應該是可以讓人們自由的發表言論而不被壓抑，民主的另一種姿態是勇敢，勇敢捍衛這些得來不易的自由。-這些絕對不是要湊字數-XD" class="headerlink" title="開頭的那句開場白，寫的時候有點心驚驚，會不會太敏感、會不會太表明立場？所謂民主，應該是不需要懼怕這些的，所謂民主，應該是可以讓人們自由的發表言論而不被壓抑，民主的另一種姿態是勇敢，勇敢捍衛這些得來不易的自由。 這些絕對不是要湊字數 XD"></a>開頭的那句開場白，寫的時候有點心驚驚，會不會太敏感、會不會太表明立場？所謂民主，應該是不需要懼怕這些的，所謂民主，應該是可以讓人們自由的發表言論而不被壓抑，民主的另一種姿態是勇敢，勇敢捍衛這些得來不易的自由。 <del>這些絕對不是要湊字數 XD</del></h6>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 把陣列 Array 轉成字串與本地化的 toLocaleString()</title>
      <link href="/tsuifei.github.io/JS_ironMan26_Converts-Array-to-string-and-localized/"/>
      <url>/tsuifei.github.io/JS_ironMan26_Converts-Array-to-string-and-localized/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-26"><a href="#Day-26" class="headerlink" title="Day 26"></a>Day 26</h6><blockquote><p>我不只知道你從哪裡來，還可以知道你那裡幾點、拿什麼貨幣跟你交換！</p></blockquote><p>前一篇介紹了可以把陣列轉成字串的<a href="https://ithelp.ithome.com.tw/articles/10226686" target="_blank" rel="noopener"><code>toString()</code></a>的方法，今天我們就來介紹更好用的<code>toLocaleString()</code>。</p><p>大家應該有發現，這個方法多了個關鍵字的 Locale ，也應該猜得出來它可以幫我們做本地化這件事吧？<code>toLocaleString()</code>是<code>toString()</code>的本地化(localized)版本，它會藉由呼叫元素的<code>toLocaleString()</code>方法，把每個陣列元素都轉成字串，然後以區域的特性（由參數定義）來將元素轉換成當地化的版本，再串接這些結果為一個字串。</p><a id="more"></a><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString" target="_blank" rel="noopener">Array.prototype.toLocaleString() - JavaScript | MDN</a></p><p><strong>原型：</strong> Array.prototype.toLocaleString()<br><strong>功能：</strong> 將陣列裡的元素本地化，並轉換為字串。<br><strong>改變：</strong> 原陣列不變。<br><strong>語法：</strong> arr.toLocaleString([locales[,options]]);<br><strong>回傳值：</strong> 表示數組元素的字符串。<br><strong>參數：</strong> 依本地化語言標記轉換</p><p><code>toLocaleString()</code>的參數，可依本地化的選擇給予語言標記當參數，再依照不同的「語言」與「區域標識符(區域設置)」顯示不同的輸出結果。語言標記是依<a href="https://tools.ietf.org/html/bcp47" target="_blank" rel="noopener">BCP 47 - Tags for Identifying Languages</a>為標記標準，<a href="https://www.w3schools.com/jsref/jsref_tolocalestring.asp" target="_blank" rel="noopener">w3schools</a>有提供比較清楚易懂的語言標記列表。</p><h3 id="把元素的數字都變成日幣"><a href="#把元素的數字都變成日幣" class="headerlink" title="把元素的數字都變成日幣"></a>把元素的數字都變成日幣</h3><p>因為<code>toLocaleString()</code>有可根據語言和區域標識符(區域設置)顯示不同的輸出。也包括了幣值的轉換，幣值的代碼可參考<a href="https://www.cbc.gov.tw/public/Attachment/2839315671.pdf" target="_blank" rel="noopener">這裏</a></p><p>例如，我們希望我們將一個陣列的數字，全部轉換成當地的貨幣格式顯示，就可直接使用<code>toLocaleString()</code>轉換，但是轉換貨幣只會對數字型別的元素有效。我們可以在<code>toLocaleString()</code>中帶入參數，並指明語言標記碼與貨幣的單位，就可帶出指定貨幣的符號與格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日幣</span></span><br><span class="line"><span class="keyword">let</span> prices = [<span class="string">'300'</span>, <span class="number">500</span>, <span class="number">8236</span>, <span class="number">42</span>];</span><br><span class="line">prices.toLocaleString(<span class="string">'ja-JP'</span>, &#123; <span class="attr">style</span>: <span class="string">'currency'</span>, <span class="attr">currency</span>: <span class="string">'JPY'</span> &#125;);</span><br><span class="line"><span class="comment">// "300,￥500,￥8,236,￥42"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新台幣</span></span><br><span class="line"><span class="keyword">let</span> prices = [<span class="number">300</span>, <span class="number">500</span>, <span class="number">8236</span>, <span class="number">42</span>];</span><br><span class="line">prices.toLocaleString(<span class="string">'zh-TW'</span>, &#123; <span class="attr">style</span>: <span class="string">'currency'</span>, <span class="attr">currency</span>: <span class="string">'TWD'</span> &#125;);</span><br><span class="line"><span class="comment">// "$300.00,$500.00,$8,236.00,$42.00"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 法國歐元</span></span><br><span class="line"><span class="keyword">let</span> prices = [<span class="string">'300'</span>, <span class="number">500</span>, <span class="number">8236</span>, <span class="number">42</span>];</span><br><span class="line">prices.toLocaleString(<span class="string">'fr-FR'</span>, &#123; <span class="attr">style</span>: <span class="string">'currency'</span>, <span class="attr">currency</span>: <span class="string">'EUR'</span> &#125;);</span><br><span class="line">(<span class="string">'300, 500,00 €, 8 236,00 €, 42,00 €'</span>); <span class="comment">// 因為'300'是字串，所以會忽略。</span></span><br></pre></td></tr></table></figure><h3 id="初始化數字或日期"><a href="#初始化數字或日期" class="headerlink" title="初始化數字或日期"></a>初始化數字或日期</h3><p>我們也可以用<code>toLocaleString()</code>來初始化時間與日期，使用時必須以建構式的方式創建一個日期 Date 物件，再把這物件放入陣列裡，然後選擇「區域語言標記」來當參數，即可得到當地的時間、日期顯示格式。如果沒有給參數，<code>toLocaleString()</code>會以瀏覽器端為依據。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 沒給參數 人在台灣所以是台灣時間格式</span></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'Taiwan, Tainan'</span>, date];</span><br><span class="line">arr.toLocaleString();</span><br><span class="line"><span class="comment">// "Taiwan, Tainan,2019/10/11 上午4:38:08"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 台灣時間</span></span><br><span class="line"><span class="keyword">let</span> dateTw = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> arrTw = [<span class="string">'Taiwan, Tainan'</span>, dateTw];</span><br><span class="line">arrTw.toLocaleString(<span class="string">'zh-TW'</span>);</span><br><span class="line"><span class="comment">// "Taiwan, Tainan,2019/10/11 上午4:38:40"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日本時間</span></span><br><span class="line"><span class="keyword">let</span> dateJp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> arrJp = [<span class="string">'Japan, Osaka'</span>, dateTw];</span><br><span class="line">arrJp.toLocaleString(<span class="string">'ja-JP'</span>);</span><br><span class="line"><span class="comment">// "Japan, Osaka,2019/10/11 4:38:40"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 法國時間</span></span><br><span class="line"><span class="keyword">let</span> dateFr = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> arrFr = [<span class="string">'France, Paris'</span>, dateFr];</span><br><span class="line">arrFr.toLocaleString(<span class="string">'fr-FR'</span>);</span><br><span class="line"><span class="comment">// "France, Paris,11/10/2019 à 04:41:10"</span></span><br></pre></td></tr></table></figure><p>有了<code>toLocaleString()</code>，要解決與貨幣和時間日期格式，應該會更輕鬆些吧！今天就介紹到此，明天是週末，我們繼續鐵人喔～</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 把陣列 Array 轉成字串的 toString()</title>
      <link href="/tsuifei.github.io/JS_ironMan25_Returns-string-representing-specified-array-and-its-elements/"/>
      <url>/tsuifei.github.io/JS_ironMan25_Returns-string-representing-specified-array-and-its-elements/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-25"><a href="#Day-25" class="headerlink" title="Day 25"></a>Day 25</h6><blockquote><p>我不想理你是歐洲人、美洲人、非洲人或哪國人，我就是要說中文。</p></blockquote><p>常常聽到人家說 JavaScript 是弱型別語言，剛開始學程式的時候真的有點一頭霧水，進一步的了解，才知道在程式語言的分類上，有所謂強型別（Strong type）和弱型別（Weak type）語言之分，強弱是相對的，但強弱之間並沒有絕對，而是依語言對型態檢查的嚴格程度，以及型態轉換的規則是否多元而定論。</p><p>JavaScript 是偏向弱型別語言的，我們會發現 JavaScript 雖然有型別之分，但是常一不小心就可能踩到雷，或者是被自動轉型，這也算是 JavaScript 難掌控的原因之一吧？例如，我們可以拿字串來做運算，這很怪，但是對 JavaScript 卻是可行的。</p><a id="more"></a><p>兩個 String 相減的結果變成 number 的型別。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">'42'</span> - <span class="string">'2'</span>;</span><br><span class="line">result; <span class="comment">// 40</span></span><br><span class="line"><span class="keyword">typeof</span> result; <span class="comment">// number</span></span><br></pre></td></tr></table></figure><p>也因此，JavaScript 有許多內建的轉型別方法，方便我們轉換型別 <del>轉斜為正？</del>。</p><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/toString" target="_blank" rel="noopener">Array.prototype.toString() - JavaScript | MDN</a></p><p><strong>原型：</strong> Array.prototype.toString()<br><strong>功能：</strong> 將指定的陣列和元素轉成字串。<br><strong>改變：</strong> 不會改變原陣列。<br><strong>語法：</strong> arr.toString()<br><strong>回傳值：</strong> 一個表示指定的數組及其元素的字符串。<br><strong>參數：</strong> 無</p><h2 id="toString-轉型別為字串"><a href="#toString-轉型別為字串" class="headerlink" title="toString() 轉型別為字串"></a>toString() 轉型別為字串</h2><p><code>toString()</code>顧名思義，可透過它將指定的陣列和元素轉成字串，然後在把這這陣列「打包」成一個字符串回傳回來。<br>原理是將每個陣列裡的元素轉成字串（必要時會呼叫元素的 toString()方法），然後連同字串用逗號分隔後的輸出，輸出時並不會包含中括號或任何在陣列裡的元素界定符號也就是說，如果陣列裡面還有陣列，陣列的 [ ] 會一併消除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString(); <span class="comment">// "1,2,3"</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].toString(); <span class="comment">// "a,b,c"</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, <span class="string">'c'</span>]].toString(); <span class="comment">// "1,2,c"</span></span><br></pre></td></tr></table></figure><p><code>toString()</code>在遇到其他型別的元素時會如何轉型？我們可以觀察到，很有趣的<code>null</code>, <code>undefined</code>,<code>NaN</code>和空元素都被消失了（但逗號還留著）；陣列被去中括號，而物件型別反而轉成了 ˋ[object Object]`。到底轉型的規則是什麼，還真的需要好好探究一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">null</span>, &#123; <span class="attr">a</span>: <span class="number">42</span> &#125;, <span class="number">82</span>, , <span class="literal">true</span>, <span class="literal">undefined</span>, [<span class="string">'hi'</span>, <span class="string">'hello'</span>], <span class="literal">NaN</span>].toString();</span><br><span class="line"><span class="comment">// ",[object Object],82,,true,,hi,hello,NaN"</span></span><br></pre></td></tr></table></figure><h3 id="你們是孿生兄弟嗎？"><a href="#你們是孿生兄弟嗎？" class="headerlink" title="你們是孿生兄弟嗎？"></a>你們是孿生兄弟嗎？</h3><p><code>toString()</code>也常常被拿來和<code>join()</code>做比較，兩這到底有什麼差別呢？我們可以以同樣有各種型別的元素陣列，讓兩個方法出裡看看結果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 toString() 轉字串</span></span><br><span class="line">[<span class="literal">null</span>, &#123; <span class="attr">a</span>: <span class="number">42</span> &#125;, <span class="number">82</span>, , <span class="literal">true</span>, <span class="literal">undefined</span>, [<span class="string">'hi'</span>, <span class="string">'hello'</span>], <span class="literal">NaN</span>].toString();</span><br><span class="line"><span class="comment">// ",[object Object],82,,true,,hi,hello,NaN"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 join() 轉字串</span></span><br><span class="line">[<span class="literal">null</span>, &#123; <span class="attr">a</span>: <span class="number">42</span> &#125;, <span class="number">82</span>, , <span class="literal">true</span>, <span class="literal">undefined</span>, [<span class="string">'hi'</span>, <span class="string">'hello'</span>], <span class="literal">NaN</span>].join();</span><br><span class="line"><span class="comment">// ",[object Object],82,,true,,hi,hello,NaN"</span></span><br></pre></td></tr></table></figure><p>結果是一模一樣！這下真的昏頭了，看來，真需要請教前輩這兩個方法的地層運作，但如果說要有什麼不同，是<code>join()</code>可以選擇元素間的分隔符號，但 toString() 卻不行。或許，如果單純想把陣列轉成字串，那麼使用<code>toString()</code>會比較純粹些。大家怎麼看呢？</p><p>後續: 感謝胡大提醒，原來 spec 有寫 (請看留言)，也就是說，使用<code>toString()</code>的結果與使用內建<code>join()</code>方法時不帶參數的結果是相同的。</p><p>放假日，今天到這就好～</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 把陣列 Array 所有元素併成字串，且可任意穿插符號的 join()</title>
      <link href="/tsuifei.github.io/JS_ironMan24_Returns-new-string-by-concatenating-elements-in-array/"/>
      <url>/tsuifei.github.io/JS_ironMan24_Returns-new-string-by-concatenating-elements-in-array/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-24"><a href="#Day-24" class="headerlink" title="Day 24"></a>Day 24</h6><blockquote><p>插隊也不能插成這樣，我們之間總是可以插點花什麼的。</p></blockquote><p>不知道大家有沒有吃過義大利的千層麵，一層麵皮一層蕃茄餡料，然後再一層麵皮一層蕃茄餡料，直到最後一層麵皮鋪上，撒上會拉絲的乳酪，再送進烤箱裡烤，美味的千層麵就這樣做好了。 <del>肚子也餓了</del></p><p><code>join()</code>做的事就像是千層麵一樣，陣列裡面的元素有如番茄餡料，以字串形式包覆，還可以選擇之間要穿插什麼，如果我們不選擇，就是很單純的麵皮<br><del>逗點</del>就是了。</p><a id="more"></a><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join" target="_blank" rel="noopener">Array.prototype.join() - JavaScript | MDN</a></p><p><strong>原型：</strong> Array.prototype.join()<br><strong>功能：</strong> 會將陣列（或一個類陣列（array-like）物件）中所有的元素連接、合併成一個字串，並回傳此字串。<br><strong>改變：</strong> 不會改變原陣列。<br><strong>語法：</strong> arr.join([separator])<br><strong>回傳值：</strong> 回傳一個合併所有陣列元素的字串。假如 arr.length 為 0，將回傳空字串。<br><strong>參數：</strong> 分隔符號。</p><p><code>join()</code>會將陣列裡的所有元素轉成字串，並串接起來回傳一個結果字串。我們可以指定額外的字串，用來分隔每個字串中的元素，如果我們沒有給指定的分隔符號字串，<code>join()</code>就會用預設的逗號來當分隔符號。不只如此，<code>join()</code>還會把一些無效的元素，例如空元素、undefined 或 null 當作空字串來處理，並回傳回來。</p><h3 id="沒給符號也可以跟有給一樣"><a href="#沒給符號也可以跟有給一樣" class="headerlink" title="沒給符號也可以跟有給一樣"></a>沒給符號也可以跟有給一樣</h3><p>我們先來看看<code>join()</code>怎麼用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr;</span><br><span class="line"><span class="keyword">const</span> arr3 = arr;</span><br><span class="line"></span><br><span class="line">arr.join(<span class="string">','</span>); <span class="comment">// "1,2,3,4,5"</span></span><br><span class="line">arr2.join(); <span class="comment">// "1,2,3,4,5"</span></span><br><span class="line">arr3.join(<span class="string">''</span>); <span class="comment">// "12345"</span></span><br></pre></td></tr></table></figure><p>大家有沒發現，其實<code>join()</code>裡沒給分隔符號，和給分隔符號<code>join(&#39;,&#39;)</code>得到的結果是ㄧ樣的。<br>因為所有的符號都屬於字串，所以記得在給參數的符號時，也必須以「字串」的形式包覆，像是<code>join(&#39;,&#39;)</code>。</p><h3 id="把陣列裡的字串元素轉成一整個字串"><a href="#把陣列裡的字串元素轉成一整個字串" class="headerlink" title="把陣列裡的字串元素轉成一整個字串"></a>把陣列裡的字串元素轉成一整個字串</h3><p>將陣列元素用固定符號串成字串，但是遇到參考型別的陣列元素<code>join()</code>會如何處理？<br>結果是<code>join()</code>會把它們都放生，<del>阿不</del> 而不處理這些參考型別的元素。但也不全然是這樣，看了下面的例子，<code>join()</code>只會將 object 的物件行元素放生，但對同是參考型別的陣列卻不會。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'jack'</span>, <span class="string">'john'</span>, <span class="string">'may'</span>, <span class="string">'su'</span>, <span class="string">'Ada'</span>];</span><br><span class="line"><span class="keyword">const</span> str = arr.join(<span class="string">'、'</span>);</span><br><span class="line">str; <span class="comment">// "jack、john、may、su、Ada"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [[<span class="number">1</span>, <span class="number">2</span>], <span class="string">'john'</span>, <span class="string">'may'</span>, &#123; <span class="attr">a</span>: <span class="number">42</span> &#125;, <span class="string">'Ada'</span>];</span><br><span class="line"><span class="keyword">const</span> str2 = arr2.join(<span class="string">' '</span>);</span><br><span class="line">str2; <span class="comment">// "1,2 john may [object Object] Ada"</span></span><br></pre></td></tr></table></figure><h3 id="如果可以活用，還真的很好用"><a href="#如果可以活用，還真的很好用" class="headerlink" title="如果可以活用，還真的很好用"></a>如果可以活用，還真的很好用</h3><p><code>join()</code>所執行的事剛好和<code>split()</code>的方法相反，<code>split()</code>會把字串切成片段來放在陣列裡，而<code>join()</code>則是會把所有元素併成一個陣列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'Hello word, how a bout your ?'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 split() 轉成陣列</span></span><br><span class="line"><span class="keyword">let</span> word = str.split(<span class="string">' '</span>);</span><br><span class="line">word; <span class="comment">// ["Hello", "word,", "how", "a", "bout", "your", "?"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再用 join() 轉回字串</span></span><br><span class="line">word.join();</span><br><span class="line">word; <span class="comment">// "Hello,word,,how,a,bout,your,?"</span></span><br></pre></td></tr></table></figure><p>別忘了，如果字串裡有逗號，<code>join()</code>會把它當作是元素的一部分處理。</p><h3 id="join-可以怎麼寫出來？"><a href="#join-可以怎麼寫出來？" class="headerlink" title="join() 可以怎麼寫出來？"></a>join() 可以怎麼寫出來？</h3><p>我們可以試著寫出一個原生的寫法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.join2 = <span class="function"><span class="keyword">function</span>(<span class="params">separator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">this</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    result += separator + <span class="keyword">this</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以上原生維修中，晚點再來補正確的，抱歉</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr.join(); <span class="comment">// "1,2,3,4"</span></span><br><span class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// "1-2-3-4"</span></span><br><span class="line">arr.join(<span class="string">''</span>); <span class="comment">// "1234"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'hi'</span>, <span class="string">'wow'</span>, <span class="string">'hello'</span>];</span><br><span class="line">arr2.join(); <span class="comment">// "hi,wow,hello";</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 對於無效的元素，join()會置之不理，但是還是會把逗號留下來</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="literal">null</span>, <span class="number">42</span>, <span class="string">'hi'</span>, <span class="literal">undefined</span>];</span><br><span class="line">arr3.join(); <span class="comment">// ",42,hi,"</span></span><br></pre></td></tr></table></figure><p>今天就先介紹到這裡，明天開始連假，但是鐵人賽還是會繼續喔！一起繼續鐵人吧！</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 可讓陣列 Array 反過來的 reverse()</title>
      <link href="/tsuifei.github.io/JS_ironMan23_Reverses-an-array-in-place-reverse()-method/"/>
      <url>/tsuifei.github.io/JS_ironMan23_Reverses-an-array-in-place-reverse()-method/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-23"><a href="#Day-23" class="headerlink" title="Day 23"></a>Day 23</h6><blockquote><p>倒立一點都不稀奇，只要使用一點魔法，我也可以倒著走。</p></blockquote><p>今天要來講一個很輕鬆的陣列方法，它可以把陣列反轉過來，而且和上一篇介紹的<code>sort()</code>ㄧ樣，是原地（in place）的改變原陣列。</p><p>記得有遇過一個習題，是要測驗某個字串是不是回文，回文就是從前面開始讀或從後面開始讀，都會是一樣的結果。像是 aba、haooah 都是，要驗證是不是回文，就會用到<code>reverse()</code>，把字串拆解反轉後，再和原本的字串做比較，如果兩邊相等，就表示是回文字串。</p><a id="more"></a><p><img src="https://ithelp.ithome.com.tw/upload/images/20191008/201041758Q3xMUGpEt.png" alt="https://ithelp.ithome.com.tw/upload/images/20191008/201041758Q3xMUGpEt.png"></p><p><strong>原型：</strong> Array.prototype.reverse()<br><strong>功能：</strong> 可以將陣列中的第一個元素變為最後一個，而最後一個元素則變成第一個。<br><strong>改變：</strong> 會就地改變原陣列<br><strong>語法：</strong> arr.reverse()<br><strong>回傳值：</strong> 反轉後的陣列。<br><strong>參數：</strong> 沒有</p><p>先來看一下範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">arr.reverse();</span><br><span class="line">arr; <span class="comment">// [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><h3 id="試著自己寫反轉"><a href="#試著自己寫反轉" class="headerlink" title="試著自己寫反轉"></a>試著自己寫反轉</h3><p>我們也可以試試看自己寫出一個讓陣列反轉的方法：<br>先建立一個空陣列變數，準備裝倒轉後的元素，以陣列長度來初始化迴圈，因為長度比索引值多ㄧ，所以在這裡我們需要減一，讓它和索引值一樣，接著條件需要設為 0，這樣我們才能從陣列的長度一個個從陣列的尾端將元素取出來，再以<code>push()</code>將取出的元素一一放入我們準備的空陣列，就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reverse2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    result.push(<span class="keyword">this</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="number">42</span>, <span class="literal">NaN</span>, <span class="string">'moi'</span>, <span class="literal">undefined</span>];</span><br><span class="line">arr.reverse2(); <span class="comment">// [undefined, "moi", NaN, 42, "hi"]</span></span><br></pre></td></tr></table></figure><h3 id="字串也可以反轉"><a href="#字串也可以反轉" class="headerlink" title="字串也可以反轉"></a>字串也可以反轉</h3><p>如果是要把一個字串反轉，就要先把字串拆解成陣列，反轉後再把陣列轉成字串就可以了。像是這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .split(<span class="string">''</span>)</span><br><span class="line">    .reverse()</span><br><span class="line">    .join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">reverseString(<span class="string">'hello'</span>); <span class="comment">// "olleh"</span></span><br></pre></td></tr></table></figure><h3 id="原生就可以辦到"><a href="#原生就可以辦到" class="headerlink" title="原生就可以辦到"></a>原生就可以辦到</h3><p>以上的效果其實也可以只用原生的 JavaScript 就可以辦到，且過程不會很複雜，只要預設一個空字串，把拆解下來的字母接起來：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = str.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    result += str[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">'Hello'</span>;</span><br><span class="line">reverseString(str2); <span class="comment">// "olleH"</span></span><br></pre></td></tr></table></figure><p>看似簡單的<code>reverse()</code>，在做字串操控時還蠻常用的，希望今天的介紹大家喜歡，我們一起學習一起成長囉～</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 將陣列 Array 重新排列的 sort()</title>
      <link href="/tsuifei.github.io/JS_ironMan22_%20Sorts-the-elements-of-an-array-sort()-method/"/>
      <url>/tsuifei.github.io/JS_ironMan22_%20Sorts-the-elements-of-an-array-sort()-method/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-22"><a href="#Day-22" class="headerlink" title="Day 22"></a>Day 22</h6><blockquote><p>一堆樸克牌攤在眼前，要照花色排還是大小來排？隨你高興。</p></blockquote><p><code>sort()</code>是個很好用的陣列方法，凡是要把陣列裡面的元素，照我們想排列的方式重新排列都需要用到它。例如在購物網站的商品依價格排列，或是我們看文章時，依照最近的時間排列，都會用到<code>sort()</code>。</p><p>在做排序時，我們也會同時原地(in place)的更動到原陣列，且回傳給我們排好序的陣列。</p><a id="more"></a><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener">Array.prototype.sort() - JavaScript | MDN</a></p><p><strong>原型：</strong> Array.prototype.sort()<br><strong>功能：</strong> 依據字串的 Unicode 編碼進行排序。<br><strong>改變：</strong> 會改變原本的陣列<br><strong>語法：</strong> arr.sort([compareFunction])<br><strong>回傳值：</strong> 回傳排序後的陣列<br><strong>參數：</strong> 可指定一個函式來定義排序的順序。如果省略此參數就會依據字串的 Unicode 編碼進行排序。</p><h2 id="是依據什麼來排列？"><a href="#是依據什麼來排列？" class="headerlink" title="是依據什麼來排列？"></a>是依據什麼來排列？</h2><p><code>sort()</code>是如何依照我們想要的方式排序？如果我們不給<code>sort()</code>參數，它會依照預設的方式排序。我們也可以給一個函式當參數，並將條件寫在函式裡，這樣會比沒有給參數精準很多。</p><h3 id="預設排序大亂入"><a href="#預設排序大亂入" class="headerlink" title="預設排序大亂入"></a>預設排序大亂入</h3><p>預設排序也就是依照我們陣列裡元素的 code UTF-16 的順序排列，什麼是 code UTF-16？ UTF-16 是 Unicode 字元的一種，我們可以直接看看<a href="https://zh.wikipedia.org/zh-tw/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">這張 Unicode 的編碼表</a>，並且來做一些測試：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="number">2</span>,</span><br><span class="line">  <span class="number">8</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">NaN</span>,</span><br><span class="line">  <span class="number">200</span>,</span><br><span class="line">  <span class="string">'Hi'</span>,</span><br><span class="line">  <span class="string">'apple'</span>,</span><br><span class="line">  <span class="string">''</span>,</span><br><span class="line">  <span class="string">'#'</span>,</span><br><span class="line">  <span class="string">'!'</span>,</span><br><span class="line">  <span class="string">'2'</span></span><br><span class="line">];</span><br><span class="line">arr1.sort();</span><br><span class="line"></span><br><span class="line">arr1;</span><br><span class="line"><span class="comment">//[ '', '!', '#', '2', 2, 200, 8, 'Hi', NaN, 'apple', null, undefined ]</span></span><br></pre></td></tr></table></figure><p>排序的結果頗讓人驚訝 <del>簡直像沒排序</del>，<code>sort()</code>會將所有元素轉成字串後，且以第一個字元為對象，再進行排序，而所有符號會被先篩選出來，接著是數字，然後是字母。也因為這樣的比較，所以連<code>200</code>都會排在<code>8</code>前面。而字母則以字母大寫為先、小寫為後來排序。</p><p>需要特別注意的是，這樣的結果有可能因<code>sort()</code>執行環境 <del>也就是瀏覽器</del>的不同，而有預期之外的預設排序結果。所以一般會建議，還是以函式傳入參數來當排序條件會比較穩定。</p><h3 id="用匿名函式當排序條件"><a href="#用匿名函式當排序條件" class="headerlink" title="用匿名函式當排序條件"></a>用匿名函式當排序條件</h3><p>如果希望完全依照自己給的條件排序，最好是給<code>sort()</code>一個帶有條件的匿名函式來當參數，這個匿名函數必須要有兩個參數，然後再依照這兩個參數比較回傳的值，來當排序依據。</p><p><code>sort()</code>會依匿名函式的參數與回傳的值為精確的排序規則：</p><ul><li>當回傳值為負數時，那麼前面的數放在前面</li><li>當回傳值為正整數，那麼後面的數在前面</li><li>當回傳值為零，保持不動。</li></ul><p>這個函式會每次都先拿兩組陣列裡的元素來比較，當回傳值為正，會讓後面的數跑到前面，以上述的規則來移動元素，大家有沒覺得這種方式很眼熟，其實就是使用冒泡排序法來達到排序。</p><p>我們先來看這些例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 沒有給參數的預設排序</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line">arr.sort(); <span class="comment">// [1, 2, 3, 5, 6, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以匿名函式回參數做「升序」排序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b; <span class="comment">// a - b &gt; 0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [1, 2, 3, 5, 6, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要反過來做「降序」排序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b - a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [9, 6, 5, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><p>或許大家會覺得疑惑，怎麼回傳一個 <code>a - b</code>就變升序 <code>b - a</code>就成了降序？<br>這是被精簡化的寫法 <del>聽說高手都會越寫越精簡</del> ，我們可以來看看原本的寫法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// 升序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 正數時，後面的數放在前面</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 負數時，前面的數放在前面</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 正數時，後面的數放在前面</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 負數時，前面的數放在前面</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 升序 另一種寫法，就會精簡到像最上面那樣！</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="comment">// a &gt; b  等於 a - b &gt; 0</span></span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>這就是程式好玩的地方，一步步的精簡到回傳<code>a - b</code>就是升、<code>b - a</code>就是降，還真是新手想不出來的境界啊！</p><h3 id="可以拿-sort-來做什麼？"><a href="#可以拿-sort-來做什麼？" class="headerlink" title="可以拿 sort 來做什麼？"></a>可以拿 sort 來做什麼？</h3><p><code>sort()</code>可以運用的範圍很廣，尤其是參數的匿名函式，依照下的條件不同而達到我們想要的效果。來看看一些範例：</p><h4 id="按照字串長度來排序"><a href="#按照字串長度來排序" class="headerlink" title="按照字串長度來排序"></a>按照字串長度來排序</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'hi'</span>, <span class="string">'Hello'</span>, <span class="string">'Bonjour'</span>, <span class="string">'ciao'</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.length - b.length;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["hi", "ciao", "Hello", "Bonjour"]</span></span><br></pre></td></tr></table></figure><h4 id="對字串做不區分大小寫的排序"><a href="#對字串做不區分大小寫的排序" class="headerlink" title="對字串做不區分大小寫的排序"></a>對字串做不區分大小寫的排序</h4><p>我們在最開頭的時候有聊到，<code>sort()</code>的預設會以 Unicode 來排序，而在 Unicode 的排序裡，大寫字母又會比小寫前面，但當我們要對有大小寫混雜的字串陣列做排序時，如何做到不區分大小寫的排序？可參考下列的方式，先把字串全轉成小寫再比對，就可以得到不分大小寫的排序囉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="string">'apple'</span>, <span class="string">'Banana'</span>, <span class="string">'coco'</span>, <span class="string">'Ege'</span>];</span><br><span class="line"><span class="comment">// 直接預設排序的結果</span></span><br><span class="line">arr.sort(); <span class="comment">//  ["Banana", "Ege", "apple", "coco"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先將字串全轉成小寫再排序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = x.toLowerCase();</span><br><span class="line">  <span class="keyword">let</span> b = y.toLowerCase();</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ["apple", "Banana", "coco", "Ege"]</span></span><br></pre></td></tr></table></figure><p>今天就先介紹到這裡，其實<code>sort()</code>的學問很大，這其中牽涉到的不只是演算法，還有 JavaScript 裡的匿名函式的活用，本人才疏且學淺，好多知識都還來不及吸收，以致不敢介紹給大家，期待有朝一日的自己，可以回頭講解得更清楚些。</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 隨意修、刪、改的陣列 Array 方法 splice()</title>
      <link href="/tsuifei.github.io/JS_ironMan21_Changes-the-contents-of-an-array-method%20/"/>
      <url>/tsuifei.github.io/JS_ironMan21_Changes-the-contents-of-an-array-method%20/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-21"><a href="#Day-21" class="headerlink" title="Day 21"></a>Day 21</h6><blockquote><p>這邊刪一下、那邊加一下，阿不，從後面改起！主管，可不可以不要這樣玩來玩去嗎？</p></blockquote><p>splice 中文為拼接。可以藉由刪除原來有的元素並／或加入新元素來改變一個陣列的內容。</p><p>但其實<code>splice()</code>不只會拼接，還可以指定在哪個點刪除與增加元素，且一次還可以增加多個。剛開始使用<code>splice()</code>常記不起來三個參數的含義，我們可以用這個比喻來增加記憶：</p><p>想像主管請我們做一個產品介紹的投影片，花了一整天終於把投影片做好 <del>這樣算慢嗎？</del>，拿去給主管看時，主管看了看說，啊這樣不行啦，你都沒放產品的側面和背面介紹，你從第三頁（start）那裡開始，把都是文字的那頁（deleteCount）使用說明拿掉，再把我說的側面和背面介紹兩頁（item1, item2）放進去，這樣就會更完美了。。</p><a id="more"></a><p>我們也發現，<code>splice()</code>比起上一篇介紹，可<a href="https://ithelp.ithome.com.tw/articles/10224915" target="_blank" rel="noopener">淺拷貝的 slice()</a>似乎更有彈性。</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20104175tzA52W0iCV.png" alt="splice"></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="noopener">Array.prototype.splice() - JavaScript | MDN</a></p><p><strong>原型：</strong> Array.prototype.splice()<br><strong>功能：</strong> 可以藉由刪除既有元素並／或加入新元素來改變一個陣列的內容。<br><strong>改變：</strong> 會改變原陣列。<br><strong>語法：</strong> var arrDeletedItems = array.splice(start[, deleteCount[, item1[, item2[, …]]]])<br><strong>回傳值：</strong> 一個包含被刪除的元素陣列。如果只有一個元素被刪除，依舊是回傳包含一個元素的陣列。 倘若沒有元素被刪除，則會回傳空陣列。<br><strong>參數：</strong> start[, deleteCount[, item1[, item2[, …]]]], start 是必須的。</p><p>因為<code>splice()</code>的參數有點小複雜，所以我們特別來看一下。直接語意說明：<code>arr1.splice(要插入或刪除的索引位置, 要刪除的元素數量, 要插入的元素內容)</code>。我們先預設這些參數的代稱：splice(start, deleteCount, item )這樣範例會比較清楚。只是要記住，<code>splice()</code>本身所回傳回來的，會是我們刪除掉的元素陣列，而不是使用<code>splice()</code>之後原陣列的結果，如果希望得到原陣列的結果，需要指派另一個變數去接。</p><p>下面的範例我們會從索引值 1 的地方刪除 2 個元素，並將<code>&quot;hi&quot;</code>這個字串放進去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors1 = [<span class="string">'red'</span>, <span class="string">'yellow'</span>, <span class="string">'blue'</span>, <span class="string">'gray'</span>, <span class="string">'purple'</span>];</span><br><span class="line"><span class="keyword">const</span> colors2 = colors1.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'hi'</span>);</span><br><span class="line"></span><br><span class="line">colors1; <span class="comment">// ["red", "hi", "gray", "purple"]</span></span><br><span class="line">colors2; <span class="comment">// ["yellow", "blue"]</span></span><br></pre></td></tr></table></figure><h3 id="刪了幾個，就回傳幾個刪掉的元素陣列回來"><a href="#刪了幾個，就回傳幾個刪掉的元素陣列回來" class="headerlink" title="刪了幾個，就回傳幾個刪掉的元素陣列回來"></a>刪了幾個，就回傳幾個刪掉的元素陣列回來</h3><p>在使用<code>splice()</code>的時候，如果只給<code>start</code>，而省略<code>deleteCount</code>，或是<code>start</code>的值，大於原陣列長度減掉<code>start</code>（也就是<code>deleteCount</code>大於<code>start</code>算起的剩餘元素數量），那麼<code>splice()</code>就會把所有從<code>start</code>開始到陣列到最後一個元素都刪除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors1 = [<span class="string">'red'</span>, <span class="string">'yellow'</span>, <span class="string">'blue'</span>, <span class="string">'gray'</span>, <span class="string">'purple'</span>];</span><br><span class="line"><span class="keyword">const</span> colors2 = colors1.splice(<span class="number">1</span>); <span class="comment">// 從索引值 1 的點開始刪除到全部</span></span><br><span class="line">colors1; <span class="comment">//["red"]</span></span><br><span class="line">colors2; <span class="comment">//["yellow", "blue", "gray", "purple"] // 把刪除的元素通通傳回來</span></span><br></pre></td></tr></table></figure><p>如果是<code>colors1.splice(0);</code>，那麼我們會得到一個空陣列<code>[]</code>，也就是說全部的元素都刪除掉。</p><h3 id="只是想插隊一下的-deleteCount-0"><a href="#只是想插隊一下的-deleteCount-0" class="headerlink" title="只是想插隊一下的 deleteCount = 0"></a>只是想插隊一下的 deleteCount = 0</h3><p>我們可以利用<code>splice()</code>單純做到在一個陣列裡插入元素，方法很簡單，只要把<code>deleteCount</code>設為零就可以了。我們甚至可以一次插入多個元素。當然，回傳的結果會是<code>[ ]</code>空陣列，因為我們什麼都沒刪，如果<code>deleteCount</code>是負數，也會得到和 0 一樣的結果。反之<code>colors1</code>卻獲得了增加一個數字<code>42</code>的陣列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors1 = [<span class="string">'red'</span>, <span class="string">'yellow'</span>, <span class="string">'blue'</span>, <span class="string">'gray'</span>, <span class="string">'purple'</span>];</span><br><span class="line"><span class="keyword">const</span> colors2 = colors1.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="number">42</span>);</span><br><span class="line">colors1; <span class="comment">// ["red", 42, "yellow", "blue", "gray", "purple"]</span></span><br><span class="line">colors2; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h3 id="索引值也可以從後頭開始算"><a href="#索引值也可以從後頭開始算" class="headerlink" title="索引值也可以從後頭開始算"></a>索引值也可以從後頭開始算</h3><p><code>splice()</code>的<code>start</code>接受複數，當我們使用負數的索引值，也表示我們要從陣列的尾端數回來。但是請小心，雖然是 -1 但並不是從尾端直接增加元素，而是從尾端倒數第一個的那個點新增元素，所以，原本最後一個元素會被往後擠。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors1 = [<span class="string">'red'</span>, <span class="string">'yellow'</span>, <span class="string">'blue'</span>, <span class="string">'gray'</span>, <span class="string">'purple'</span>];</span><br><span class="line"><span class="keyword">const</span> colors2 = colors1.splice(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">colors1; <span class="comment">// ["red", "yellow", "blue", "gray", 42, "purple"]</span></span><br><span class="line">colors2; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h3 id="常常被拿來和-slice-比較"><a href="#常常被拿來和-slice-比較" class="headerlink" title="常常被拿來和 slice 比較"></a>常常被拿來和 slice 比較</h3><p>常常會看到<code>splice()</code>和<code>slice()</code>比較的文章，但是倒底兩個方法還是有很大的不同的。<br><code>slice()</code>不會改變原陣列；<code>splice()</code>會。<br><code>slice()</code>回傳指定切下來的陣列；<code>splice()</code>會回傳被刪除的陣列。<br>如果想快速獲得一個淺拷貝的陣列，的確<code>slice()</code>顯得簡潔，但其實<code>splice()</code>也不差，還可以用另ㄧ變數指定的方式，輕易獲得新增或刪除的陣列，用哪個比較方便，就真的要看使用情境了。</p><p>希望今天的小菜大家都還喜歡，其實還有許多不同的用法，礙於篇幅與時間無法一一介紹，希望鐵人賽之後，可以有時間把這些介紹做得更詳細些啊。</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 輕鬆淺拷貝的陣列 Array 方法 slice()</title>
      <link href="/tsuifei.github.io/JS_ironMan20_Shallow-copy-array-slice()-method/"/>
      <url>/tsuifei.github.io/JS_ironMan20_Shallow-copy-array-slice()-method/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-20"><a href="#Day-20" class="headerlink" title="Day 20"></a>Day 20</h6><blockquote><p>老闆，幫我切一段香腸，從第三節到第六節，你手握著的那節不要。謝謝！</p></blockquote><p>slice 的英文是切片或擷取，我們生活中常用的像是：「slice of life」生活的小片段、「slice of bread」一片麵包都是在表示一部分或「片狀」。但在陣列使用<code>slice()</code>的情境，比較像是「切  一段」，因為可以指定從某個元素切到某一個元素 <del>的前一個</del>。 切下來的部份是以複製的型態產生，所以也不會影響原本的陣列。</p><a id="more"></a><h3 id="要哪段給哪段的-slice"><a href="#要哪段給哪段的-slice" class="headerlink" title="要哪段給哪段的 slice()"></a>要哪段給哪段的 slice()</h3><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="noopener">Array.prototype.slice() | MDN</a></p><p><strong>原型：</strong> Array.prototype.slice()<br><strong>功能：</strong> 回傳一個新陣列物件，為原陣列選擇的 begin 至 end（不含 end）部分的淺拷貝（shallow copy）。<br><strong>改變：</strong> 原本的陣列將不會被修改。<br><strong>語法：</strong> arr.slice([begin[, end]])<br><strong>回傳值：</strong> 傳新陣列<br><strong>參數：</strong> begin 自此索引（起始為 0）開始提取拷貝。 end 至此索引值之前停止提取</p><p><code>slice()</code>有兩個預設參數，第一個參數是要從哪個索引值開始切，第二個參數是要在哪一個索引值結束，第二個參數常會讓人會錯意，因為第二個參數如果是三，<code>slice()</code>其實只會取到索引值為二就停止。比較好記的方法是把第二個參數減一，那會比較符合我們平常對「從這裡切到那裡」的認知。</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/20104175upSsl1vmpz.png" alt="https://ithelp.ithome.com.tw/upload/images/20191005/20104175upSsl1vmpz.png"></p><h2 id="只給一個參數的時候"><a href="#只給一個參數的時候" class="headerlink" title="只給一個參數的時候"></a>只給一個參數的時候</h2><h3 id="不給參數就什麼都給你"><a href="#不給參數就什麼都給你" class="headerlink" title="不給參數就什麼都給你"></a>不給參數就什麼都給你</h3><p>在使用<code>slice()</code>的時候，如果不給參數，或只給零，那麼<code>slice()</code>就會把陣列從頭到尾複製一份給我們，也因此，許多人拿<code>slice()</code>來做陣列的淺拷貝，簡潔又方便。 <del>就淺淺的拷貝喔</del></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors1 = [<span class="string">'red'</span>, <span class="string">'yellow'</span>, <span class="string">'blue'</span>, <span class="string">'gray'</span>, <span class="string">'purple'</span>];</span><br><span class="line"><span class="keyword">const</span> colors2 = colors1.slice();</span><br><span class="line"><span class="keyword">const</span> colors3 = colors1.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">colors2; <span class="comment">// [ 'red', 'yellow', 'blue', 'gray', 'purple' ]</span></span><br><span class="line">colors3; <span class="comment">// [ 'red', 'yellow', 'blue', 'gray', 'purple' ]</span></span><br></pre></td></tr></table></figure><h3 id="給我負數我就倒立給你看"><a href="#給我負數我就倒立給你看" class="headerlink" title="給我負數我就倒立給你看"></a>給我負數我就倒立給你看</h3><p>如果我們給的參數是負數，又會發生什麼事？就像<code>length-1</code>ㄧ樣，<code>slice()</code>會從陣列的尾端開始數，如果是<code>-1</code>，就會從陣列尾端取一個，如果這個負數超過陣列的長度，<code>slice()</code>就會把所有能給我們都給出來。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors1 = [<span class="string">'red'</span>, <span class="string">'yellow'</span>, <span class="string">'blue'</span>, <span class="string">'gray'</span>, <span class="string">'purple'</span>];</span><br><span class="line"><span class="keyword">const</span> colors2 = colors1.slice(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> colors3 = colors1.slice(<span class="number">-6</span>);</span><br><span class="line"></span><br><span class="line">colors2; <span class="comment">// [ 'purple' ]</span></span><br><span class="line">colors3; <span class="comment">// [ 'red', 'yellow', 'blue', 'gray', 'purple' ]</span></span><br></pre></td></tr></table></figure><p>我們可以發現，當我們參數是<code>-1</code>時，就好像是使用<code>pop()</code>，只是<code>pop()</code>回傳給我們的被刪掉值的索引值，但是<code>slice(-1)</code>卻會回傳陣列最後一個元素。</p><h3 id="遇到多維的深拷貝就失效"><a href="#遇到多維的深拷貝就失效" class="headerlink" title="遇到多維的深拷貝就失效"></a>遇到多維的深拷貝就失效</h3><p>雖然拿<code>slice()</code>來複製陣列很方便，但如果遇到多維陣列，<code>slice()</code>的複製就會失效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多維陣列，slice() 深拷貝失效</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">arr2; <span class="comment">// [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原陣列</span></span><br><span class="line">arr1[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">'Hi'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兩個陣列都被修改了</span></span><br><span class="line">arr1; <span class="comment">// [ [ 'Hi', 2, 3 ], [ 4, 5, 6 ] ]</span></span><br><span class="line">arr2; <span class="comment">// [ [ 'Hi', 2, 3 ], [ 4, 5, 6 ] ]</span></span><br></pre></td></tr></table></figure><h2 id="兩個參數給好給滿"><a href="#兩個參數給好給滿" class="headerlink" title="兩個參數給好給滿"></a>兩個參數給好給滿</h2><p><code>slice()</code>的第二個參數頗曖昧我們都知道，明明是要擷取至索引值 4 卻只會擷取到 3，在記<code>slice()</code>第二個參數的時候，只要把刪除的索引值再 +1 會比較好記 <del>或是相反</del>。<br>我們來看有第二個參數時的變化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> friends1 = [<span class="string">'Ayda'</span>, <span class="string">'Phi'</span>, <span class="string">'Alex'</span>, <span class="string">'Chris'</span>, <span class="string">'Tracy'</span>, <span class="string">'Thomas'</span>, <span class="string">'Jean'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從索引值 1 擷取 至 2 (2+1=3)</span></span><br><span class="line"><span class="keyword">const</span> friends2 = friends1.slice(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">friends2; <span class="comment">// [ 'Phi', 'Alex' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要第二個參數是 0 就會回傳空陣列</span></span><br><span class="line"><span class="keyword">const</span> friends3 = friends1.slice(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">friends3; <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -2 是從尾端開始數回來</span></span><br><span class="line"><span class="keyword">const</span> friends4 = friends1.slice(<span class="number">2</span>, <span class="number">-2</span>);</span><br><span class="line">friends4; <span class="comment">// [ 'Alex', 'Chris', 'Tracy' ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> friends5 = friends1.slice(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">friends5; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果第二個參數是負數，表示從陣列的尾端算回來。<br>如果第二個參數比原陣列的長度長，那麼<code>slice()</code>就會擷取到陣列的最後一個元素。<br>如果第二個參數和第一個參數一樣，<code>slice()</code>會回傳空陣列，因為第二個參數會 -1 也就把第一個參數給減掉了。</p><p><code>slice()</code>雖然是簡單的陣列方法，但是如果能夠靈活運用，相信對陣列的操控會更加方便。</p><p>這邊有篇以可愛的土司做示範的<code>slice()</code>介紹文，也很直得參考喔～<br><a href="https://dev.to/tvanblargan/arrays-any-way-you-slice-it-1lfl" target="_blank" rel="noopener">Arrays, any way you slice it</a></p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 合併陣列 Array 的方法 concat()</title>
      <link href="/tsuifei.github.io/JS_ironMan19_Concatenate-or-merge-arrays-concat()-Methods/"/>
      <url>/tsuifei.github.io/JS_ironMan19_Concatenate-or-merge-arrays-concat()-Methods/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-19"><a href="#Day-19" class="headerlink" title="Day 19"></a>Day 19</h6><blockquote><p>人生像是一列火車，旅程中總是會搭載著不同貨物，走得越遠掛載的越多，包括肥肉。</p></blockquote><p><img src="https://ithelp.ithome.com.tw/upload/images/20191004/201041759bPpG8rNEQ.png" alt="https://ithelp.ithome.com.tw/upload/images/20191004/201041759bPpG8rNEQ.png"></p><h6 id="圖片來源：www-unsplash-com-Dibyendu-Sekhar-Das"><a href="#圖片來源：www-unsplash-com-Dibyendu-Sekhar-Das" class="headerlink" title="圖片來源：www.unsplash.com / Dibyendu Sekhar Das"></a>圖片來源：<a href="http://www.unsplash.com" target="_blank" rel="noopener">www.unsplash.com</a> / Dibyendu Sekhar Das</h6><p>在法國搭高速火車時，曾經收到朋友的告誡：千萬不要自己亂換車廂，尤其是火車停在某一站的時候。</p><p>原本不以為意，但聽到以下的故事就頓時聽話了：<br>某人在火車停靠在某一站時，因為肚子痛急著想上廁所，但自己座位的那節車廂廁所卻有人，於是到隔壁的車廂去上，拉肚子總是不好解決，花了許多時間，等到舒緩之後，突然意會到怎麼火車還沒開，於是走回去原車廂時，驚！發現原本坐的那節車廂不見了！完全被<code>shift()</code>掉了！</p><a id="more"></a><p>這是真實的故事，因為法國很大，火車從巴黎出發，一路往南開會經過好幾個城市，為了節省資源，會特意在訂票時就把到達同城市的旅客集中在固定的幾節車廂，這樣一來只要到達某站，就會把指定的那幾節車廂拆卸下來（切斷），然後其餘的車廂繼續開往其他城市。反過來想，這列火車也是可以陸續和其他的車廂合併，一起開往巴黎。</p><p>火車的車廂就像是陣列，一節節的車廂合併串起來就是<code>concat()</code>了。 <del>轉大人成功了</del></p><h2 id="concat-一列到達許多城市的火車"><a href="#concat-一列到達許多城市的火車" class="headerlink" title="concat() 一列到達許多城市的火車"></a>concat() 一列到達許多城市的火車</h2><p>concat() 可以在陣列中與其他多個陣列合併，並回傳新的陣列。原陣列不會被改變。我們可以將要合併的陣列或元素，多個或單個，以引數的方式，讓原陣列與這些要併入的陣列或元素合併在一起。</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20191004/20104175qI0DGY793E.png" alt="https://ithelp.ithome.com.tw/upload/images/20191004/20104175qI0DGY793E.png"></p><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank" rel="noopener">Array.prototype.concat() - JavaScript | MDN</a><br>concat() 方法<br><strong>原型：</strong> Array.prototype.concat()<br><strong>功能：</strong> 用來合併兩個或多個陣列或元素。concat()不會改變原有的陣列，回傳一個包含呼叫陣列本身的值，作為代替的是回傳一個新陣列。<br><strong>改變：</strong> 不會改變原有的陣列<br><strong>語法：</strong> var new_array = old_array.concat(value1[, value2[, …[, valueN]]])<br><strong>回傳值：</strong> 一個新的陣列實體。<br><strong>參數：</strong> valueN 陣列以及／或者值，用來合併成一個新的陣列。</p><h2 id="只要放在-裡都吃-不偏食"><a href="#只要放在-裡都吃-不偏食" class="headerlink" title="只要放在( )裡都吃 不偏食"></a>只要放在( )裡都吃 不偏食</h2><p>我們以參數傳入的方式，把要合併的陣列或元素放在( )裡，這部分<code>concat()</code>非常彈性，要多個、單個、或陣列與物件的方式都可以，幾乎是給什麼吃什麼。 <del>好雜食啊</del></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'Hi'</span>, <span class="string">'Wow'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果將陣列以參數傳入concat()，它會拆開這些陣列，並將元素加入原本的陣列。</span></span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> arr3 = arr2.concat(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">const</span> arr4 = arr3.concat(&#123; <span class="attr">a</span>: <span class="number">42</span> &#125;);</span><br><span class="line"></span><br><span class="line">arr1; <span class="comment">// [ 'Hi', 'Wow' ]</span></span><br><span class="line">arr2; <span class="comment">// [ 'Hi', 'Wow', 1, 2, 3 ]</span></span><br><span class="line">arr3; <span class="comment">// [ 'Hi', 'Wow', 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line">arr4; <span class="comment">// [ 'Hi', 'Wow', 1, 2, 3, 4, 5, 6, &#123; a: 42 &#125; ]</span></span><br></pre></td></tr></table></figure><p>既然是多個，我們也可以一次就把要合併的元素或物件合併上去。像這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'Hi'</span>, <span class="string">'Wow'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, &#123; <span class="attr">a</span>: <span class="number">42</span> &#125;);</span><br><span class="line"></span><br><span class="line">arr1; <span class="comment">// [ 'Hi', 'Wow' ]</span></span><br><span class="line">arr2; <span class="comment">// [ 'Hi', 'Wow', 1, 2, 3, 4, 5, 6, &#123; a: 42 &#125; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字串也可以</span></span><br><span class="line"><span class="keyword">const</span> colorName = <span class="string">'purple'</span>;</span><br><span class="line"><span class="keyword">const</span> allColor4 = [...warmColor, ...coldColor, colorName];</span><br><span class="line"></span><br><span class="line">allColor4; <span class="comment">// [ 'red', 'yellow', 'blue', 'gray', 'purple' ]</span></span><br></pre></td></tr></table></figure><h3 id="雖彈性也不要以為可以隨便"><a href="#雖彈性也不要以為可以隨便" class="headerlink" title="雖彈性也不要以為可以隨便"></a>雖彈性也不要以為可以隨便</h3><p>雖然我們可以將陣列以參數傳入<code>concat()</code>，它會自動拆開這些陣列，但並不表示多層的陣列就可行，要注意的是，<code>concat()</code>只會拆開提供給它的第一層陣列，而不會拆開第二層陣列(陣列中的陣列)。也就是說<code>concat()</code> 不會以遞迴(recursively)的方式，把多層的陣列攤平。 <del>想得美</del></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.concat([<span class="number">4</span>, <span class="number">5</span>], <span class="number">6</span>); <span class="comment">// [1,2,3,4,5,6];</span></span><br><span class="line">arr.concat([<span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>]]); <span class="comment">// [ 1, 2, 3, 7, [ 8, 9 ] ]</span></span><br></pre></td></tr></table></figure><h3 id="拷貝拷的沒那麼深的-concat"><a href="#拷貝拷的沒那麼深的-concat" class="headerlink" title="拷貝拷的沒那麼深的 concat()"></a>拷貝拷的沒那麼深的 concat()</h3><p>看到網路上討論到，使用<code>concat()</code>時，如果沒有給參數，就相當是原陣列與一個空陣列拼接，返回的原陣列，就算是原陣列的深拷貝。<br>但是利用<code>concat()</code>來複製陣列，只限用在結構較簡單的陣列上，如果運用在比較複雜與多層的物件上，這個方法就行不通了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'wow'</span>, [<span class="string">'O'</span>, <span class="string">'X'</span>]];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 試著修改第一層和第二層的陣列元素</span></span><br><span class="line">arr[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'OOO'</span>;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">'Hello'</span>;</span><br><span class="line"></span><br><span class="line">arr; <span class="comment">// ["Hello", "wow", ["OOO", "X"]]</span></span><br><span class="line">arr2; <span class="comment">//["hi", "wow", ["OOO", "X"]]</span></span><br></pre></td></tr></table></figure><p>我們可以觀察到，如果修改第一層的<code>arr[0]</code>這個元素為<code>&quot;Hello&quot;</code>，<code>arr2[0]</code>並沒有被修改到，但是當我們修改<code>arr[2][0]</code>為<code>&quot;OOO&quot;</code>的時候，<code>arr2[2][0]</code>也會跟著改成<code>&quot;OOO&quot;</code>。如果要拿<code>concat()</code>來複製物件型態的資料時，還是要特別注意這點。</p><h3 id="push-說-你會的我也會，且比你更會！"><a href="#push-說-你會的我也會，且比你更會！" class="headerlink" title="push() 說 你會的我也會，且比你更會！"></a>push() 說 你會的我也會，且比你更會！</h3><p>還記得我們前幾篇有介紹，從陣列尾端來「新增」元素的<code>push()</code>方法嗎？看起來<code>push()</code>做的事和<code>concat()</code>很像，都是從陣列的尾端加東西，不同之處在哪裡？</p><table><thead><tr><th>concat()</th><th>從原陣列複製一個新的陣列，在新陣列上進行操作，不會改變原陣列的值。</th><th>會拆開參數，把元素加進去</th></tr></thead><tbody><tr><td>push()</td><td>在原陣列上修改，執行 push()原陣列的值也會變</td><td>參數是陣列時，把整個陣列參數作為一個元素</td></tr></tbody></table><h3 id="其餘參數說-你們會的我更會！"><a href="#其餘參數說-你們會的我更會！" class="headerlink" title="其餘參數說 你們會的我更會！"></a>其餘參數說 你們會的我更會！</h3><p>還有另外一種方式可以達到和<code>concat()</code>一樣效果的我們把其餘參數(rest parameter)，這個方式也很方便，效果也一樣。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> warmColor = [<span class="string">'red'</span>, <span class="string">'yellow'</span>];</span><br><span class="line"><span class="keyword">const</span> coldColor = [<span class="string">'blue'</span>, <span class="string">'gray'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 concat()</span></span><br><span class="line"><span class="keyword">const</span> allColor1 = [].concat(warmColor, coldColor);</span><br><span class="line"><span class="comment">// [ 'red', 'yellow', 'blue', 'gray' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以寫成</span></span><br><span class="line"><span class="keyword">const</span> allColor2 = warmColor.concat(coldColor);</span><br><span class="line"><span class="comment">// [ 'red', 'yellow', 'blue', 'gray' ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allColor3 = [...warmColor, ...coldColor];</span><br><span class="line"><span class="comment">// [ 'red', 'yellow', 'blue', 'gray' ]</span></span><br></pre></td></tr></table></figure><p>但據說還是有些許不一樣，我們有機會再好好的測試。 <del>機會？鐵人賽後吧</del></p><p>這三種吃小菜的方法：<code>push()</code>、<code>concat()</code>和其餘參數(rest parameter)大家喜歡哪一種？<br>希望這幾天的小菜，可以讓大家至少對如何刪除或增加陣列的方法有一個概觀，路還很長、小菜還很多樣，還請大家慢慢品嚐囉。</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 從陣列 Array 的開頭刪除元素 shift()</title>
      <link href="/tsuifei.github.io/JS_ironMan18_shift()to-delete-elements-from-the-beginning-of-the-array/"/>
      <url>/tsuifei.github.io/JS_ironMan18_shift()to-delete-elements-from-the-beginning-of-the-array/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-18"><a href="#Day-18" class="headerlink" title="Day 18"></a>Day 18</h6><blockquote><p>別把我頭上的角取下來，這樣我就被 Shift 了。不過也好，這樣我看起來會比較正常。</p></blockquote><p>前一篇我們認識了從陣列的頭部加上一個或多個元素的<code>unshift()</code>，今天要介紹的是從陣列的開端刪除元素的<code>shift()</code>，這一對陣列方法，都屬於佇列(Queue)「先進先出 FIFO」的資料結構。</p><a id="more"></a><p>我們再來以此圖複習一下：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20104175DIqBdswLxB.png" alt="資料結構"></p><h2 id="shift-幫我把頭拿下來"><a href="#shift-幫我把頭拿下來" class="headerlink" title="shift() 幫我把頭拿下來"></a>shift() 幫我把頭拿下來</h2><p>使用<code>shift()</code>方法，會移除陣列的第一個元素，也就是索引值為零的元素，並把這個元素的值回傳回來。也就是說，它會永遠回傳原陣列的第一個元素。</p><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" target="_blank" rel="noopener">Array.prototype.shift() - JavaScript | MDN</a></p><p><strong>原型：</strong> Array.prototype.shift()<br><strong>功能：</strong> 會移除並回傳陣列的第一個元素。<br><strong>改變：</strong> 此方法會改變原陣列的長度和內容。<br><strong>語法：</strong> arr.shift()<br><strong>回傳值：</strong> 自陣列中移除的元素；若陣列為空，則會回傳 undefined。<br><strong>參數：</strong> 無</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20191217/20104175Y17sjkGr8Y.png" alt="shift()"></p><p>我們先來看一下用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.shift(); <span class="comment">// 1 回傳第一個被刪掉的元素值</span></span><br><span class="line">arr; <span class="comment">// [2, 3, 4, 5] 陣列已經去掉第一個元素</span></span><br></pre></td></tr></table></figure><p>陣列中索引值為零的元素，就是第一個元素 <del>廢話</del>，執行之後，<code>shift()</code>會將隨後的其他元素的索引值減一（往前移一位）。假如陣列已經被清空，也就是 length 屬性的值是 0，<code>shift()</code>就會回傳 undefined 給我們。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.shift(); <span class="comment">// 1</span></span><br><span class="line">arr.shift(); <span class="comment">// 2</span></span><br><span class="line">arr.shift(); <span class="comment">// undefined</span></span><br><span class="line">arr; <span class="comment">//[]</span></span><br></pre></td></tr></table></figure><h3 id="如果第一個元素是物件類型的資料"><a href="#如果第一個元素是物件類型的資料" class="headerlink" title="如果第一個元素是物件類型的資料?"></a>如果第一個元素是物件類型的資料?</h3><p>即使想要處理的陣列裡，有包含物件類型的元素，如陣列或物件，<code>shift()</code>也會乖乖的把它傳回來，字串也是如此。 <del>實在是好聽話</del></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [&#123; <span class="attr">a</span>: <span class="number">42</span> &#125;, <span class="string">'Hi'</span>, <span class="number">24</span>];</span><br><span class="line">arr.shift(); <span class="comment">// &#123;a: 42&#125;</span></span><br><span class="line">arr.shift(); <span class="comment">// "Hi"</span></span><br></pre></td></tr></table></figure><h3 id="如果陣列裡的元素包含無效的資料"><a href="#如果陣列裡的元素包含無效的資料" class="headerlink" title="如果陣列裡的元素包含無效的資料?"></a>如果陣列裡的元素包含無效的資料?</h3><p>如果陣列裡頭包含了<code>undefined</code>、<code>null</code>或者是<code>NaN</code>，在使用<code>shift()</code>時會回傳什麼呢？ <del>它還是很聽話</del><code>shift()</code>還是會把這些無效的值回傳給我們。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr3 = [<span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>];</span><br><span class="line">arr3.shift(); <span class="comment">// undefined</span></span><br><span class="line">arr3.shift(); <span class="comment">// null</span></span><br><span class="line">arr3.shift(); <span class="comment">// NaN</span></span><br><span class="line">arr3.shift(); <span class="comment">// undefined 因為陣列空了，所以還是回傳 undefined</span></span><br></pre></td></tr></table></figure><h3 id="多此一舉的徒勞"><a href="#多此一舉的徒勞" class="headerlink" title="多此一舉的徒勞"></a>多此一舉的徒勞</h3><p>使用<code>shift()</code>是不需要給參數的，所以，即使我們給它一些奇怪的參數，它也會無動於衷，做它該做的事，而且還不會報錯。<code>shift()</code>只會完全忽略這些參數。 <del>終於有個性了起來</del>不過，會這樣做存粹是實驗，了解<code>shift()</code>就不會這樣玩弄它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.shift([<span class="string">'hi'</span>]); <span class="comment">// 1</span></span><br><span class="line">arr.shift(<span class="literal">null</span>); <span class="comment">// 2</span></span><br><span class="line">arr.shift(<span class="number">42</span>); <span class="comment">// 3</span></span><br><span class="line">arr.shift(<span class="number">-42</span>); <span class="comment">// 4</span></span><br><span class="line">arr.shift(<span class="string">''</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="shift-是如何辦到刪除第一個元素的？"><a href="#shift-是如何辦到刪除第一個元素的？" class="headerlink" title="shift() 是如何辦到刪除第一個元素的？"></a>shift() 是如何辦到刪除第一個元素的？</h3><p>接下來我們來看看 <code>shift()</code>可能是這樣被寫出來的程式碼：<br>先把第一個元素，也就是索引值是零的元素抓出來，接下來利用<code>for</code>迴圈把剩下的值做索引值的位移。然後，再把位移後的結果去掉最後一個元素，再回傳最開始抓到的第一個值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 這裡的 this 是原要處理的陣列</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.shift2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> firstItem = <span class="keyword">this</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = arr[i + <span class="number">1</span>]; <span class="comment">// 以 往前位移一位的方式，把每個元素往前移一個位置。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移位完成之後，陣列的尾端會是原本的陣列最後一個，這樣就重複了，所以使用length減 1 把最後面的元素刪除。</span></span><br><span class="line">  arr.length--;</span><br><span class="line">  <span class="keyword">return</span> firstItem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr2.shift2(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>以下為<code>shift2</code>裡的<code>for</code>迴圈運作步驟：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以上面的例子 this 長度是 5</span><br><span class="line">this[i] = this[i + 1]</span><br><span class="line">第一圈 this[0] = this[1]  i = 1</span><br><span class="line">第二圈 this[1] = this[2]  i = 2</span><br><span class="line">第三圈 this[2] = this[3]  i = 3</span><br><span class="line">第四圈 this[3] = this[4]  i = 4</span><br><span class="line">第四圈 this[4] = this[5]  i = 5</span><br></pre></td></tr></table></figure><p>今天的<code>shift()</code>就介紹到這裡，希望看完這篇會更清楚<code>shift()</code>的運作原理。另外，今天是本人鐵人賽的第 18 天，但是還有一拖車的陣列方法要介紹啊！</p><p>這次的鐵人賽絕對是無法介紹完的，但是本人會默默地、不定期的繼續把陣列方法介紹下去。因為，鐵人結束後，本人是不可能變鐵人的，所以還是要繼續學習才是，對吧？</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 從陣列 Array 的開頭新增元素的 unshift()</title>
      <link href="/tsuifei.github.io/JS_ironMan17_unshift()to-add-elements-from-the-beginning-of-the-array/"/>
      <url>/tsuifei.github.io/JS_ironMan17_unshift()to-add-elements-from-the-beginning-of-the-array/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-17"><a href="#Day-17" class="headerlink" title="Day 17"></a>Day 17</h6><blockquote><p>頭和腳的關係如此微妙，一個思考一個執行，但對程式的陣列來說，都只是陣列的一部分而已，很公平。</p></blockquote><p>接下來我們會分兩天，聊聊從陣列的開頭（前面）新增或刪除陣列元素的方法。</p><p><code>unshift()</code>和<code>shift()</code>這一對，說穿了和<code>push()</code>、<code>pop()</code>ㄧ樣，只是一個從陣列的前頭增加與刪除元素，另一個則是從陣列的尾端操作。<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20104175DIqBdswLxB.png" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20104175DIqBdswLxB.png"></p><a id="more"></a><p>這是我們從操作面來看的不同，要再探討深一點，就必須了解這兩對寶，在記憶體的操作方式也就是資料結構還是有很大的不同。前一篇我們有介紹到<a href="https://ithelp.ithome.com.tw/articles/10223356" target="_blank" rel="noopener">資料結構的堆疊（Stack）和佇列（Queue）</a>，從尾部增加和刪除元素的<code>push()</code>、<code>pop()</code>是以堆疊（Stack）「後進先出 LIFO」的方式記憶，而從陣列前頭的<code>unshift()</code>和<code>shift()</code>的儲存則是採用佇列(Queue)「先進先出 FIFO」的資料結構。<br>我們再來以此圖複習一下：</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/2010417512XaDyfODV.png" alt="https://ithelp.ithome.com.tw/upload/images/20191002/2010417512XaDyfODV.png"></p><h2 id="unshift-頭上頂著好幾塊餅的非洲婦女"><a href="#unshift-頭上頂著好幾塊餅的非洲婦女" class="headerlink" title="unshift() 頭上頂著好幾塊餅的非洲婦女"></a>unshift() 頭上頂著好幾塊餅的非洲婦女</h2><p>使用<code>unshift()</code>陣列方法，可將一個或多個一組的元素，從陣列的前端加入。也因為是從開端加入元素，連帶也會變動到所有元素的索引值（index），最後被加入陣列的元素索引值，永遠都是<code>index[0]</code>，如果是以多個元素一組的方式加入，則是第一個元素的索引值是 0 。</p><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank" rel="noopener">Array.prototype.unshift() - JavaScript | MDN</a></p><p><strong>原型：</strong> Array.prototype.unshift()<br><strong>功能：</strong> 會添加一個或多個元素至陣列的開頭，並且回傳陣列的新長度。<br><strong>改變：</strong> 原陣列會改變<br><strong>語法：</strong> <code>arr.unshift(element1[, ...[, elementN]])</code><br><strong>回傳值：</strong> 呼叫此方法之物件的新 length 屬性值。<br><strong>參數：</strong> elementN 欲添加至陣列開頭的元素。</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20104175rxy2OArQNk.png" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20104175rxy2OArQNk.png"></p><p>我們先來看一下操作方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.unshift(<span class="number">0</span>); <span class="comment">// 6</span></span><br><span class="line">arr; <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">arr.unshift(<span class="number">-1</span>, <span class="number">0</span>); <span class="comment">// 8</span></span><br><span class="line">arr; <span class="comment">// [-1, 0, 0, 1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">arr.unshift([<span class="string">'Hello'</span>, <span class="string">'Wow'</span>]); <span class="comment">// 9</span></span><br><span class="line">arr; <span class="comment">// [Array(2), -1, 0, 0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>當我們查閱<code>arr</code>時會，我們可以觀察到，一整個陣列被當作是一個元素加入。</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20104175HbWEcAZu28.png" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20104175HbWEcAZu28.png"></p><p>如果想要一次加入多個元素，都要以逗號做區隔，索引值也會以逗號分隔的數量來增加。</p><p>需要注意的是<code>unshift()</code>會將我們所放在<code>unshift()</code>裡的引數列（argument list）<code>unshift(引數列)</code>，以「一次性的」加入陣列的前端，而不會「一個個」的多次放入陣列裡，所以需要注意放入後的順序問題。假如元素是「逐次」的放入陣列前端，那麼這些加入的元素順序就會是倒過來的。</p><h2 id="unshift-是怎麼被寫出來的？"><a href="#unshift-是怎麼被寫出來的？" class="headerlink" title="unshift() 是怎麼被寫出來的？"></a>unshift() 是怎麼被寫出來的？</h2><p>前面有提到<code>unshift()</code>可以ㄧ次或多個元素一起新增至陣列中，所以比較方便的是也把這些引數放在一個陣列裡處理。<br>我們可以使用其餘參數（rest parameter）的功能，其餘參數會將一個不確定數量的參數，集合在一個陣列中。且<code>unshift()</code>的回傳值是返回處理過的陣列長度，這點只要使用陣列的屬性<code>length</code>就可拿到，接下來怎麼把引數的內容一一放到陣列前頭呢？</p><p>我們先來直接看一下 code:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unshift2 = <span class="function"><span class="keyword">function</span>(<span class="params">...elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.length + (elements.length - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = <span class="keyword">this</span>[i - elements.length];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i] = elements[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.unshift2(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>第一個迴圈，我們把<code>i</code>設為原陣列的長度＋引數長度-1，條件為<code>i &gt;= 0;</code>，每跑一次<code>i</code>就減 1。<br>用此方式去偵測原陣列和引數 elements 的長度，再把引數長度先空出來。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">也就是指定引數的索引值，給空出來的原陣列索引值。</span><br><span class="line">整理一下：this -&gt; let arr = [1, 2, 3];</span><br><span class="line">第一個 for(i=3+2 -&gt; 5; i &gt;= 0; i--)</span><br><span class="line">第一圈 this[5] = this[5-(3)=2] 5--  -&gt; i = 4</span><br><span class="line">第二圈 this[4] = this[4-(3)=1] 4--  -&gt; i = 3</span><br><span class="line">第三圈 this[3] = this[3-(3)=0] 3--  -&gt; i = 2</span><br><span class="line">第四圈 this[2] = this[2-(3)=-1] 2--  -&gt; i = 1</span><br><span class="line">第五圈 this[1] = this[1-(3)=-2] 1--  -&gt; i = 0</span><br><span class="line">第六圈 this[0] = this[0-(3)=-3] 0--  -&gt; i = 0   &gt;=0 終止</span><br></pre></td></tr></table></figure><p>這時的 this -&gt; <code>[undefined, undefined, undefined, 1, 2, 3]</code>。</p><p>第二個迴圈負責把要增加的元素（引數），一一指定給第一個迴圈先空下來的引數數量空隙。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第二個 for(i=0; i &lt; 3; i++)</span><br><span class="line">第一圈 this[0] = elements[0]</span><br><span class="line">第二圈 this[1] = elements[1]</span><br><span class="line">第三圈 this[2] = elements[2]</span><br></pre></td></tr></table></figure><p>這個迴圈主要是把引數陣列裡的 index 對應到第一個迴圈空出來的 index 裡，只要對應到 index 也表示會對應到值。</p><p>最後，再把整個陣列長度回傳出來。就完成了！</p><p>本人實在不太會解說整個程式的流程 <del>弱到趴糞</del>，所以把迴圈的部份寫出來，這也是我們在觀察其他人寫的程式碼的方法之一。<br>希望有幫助到大家 <del>自己也受益</del> ！</p><p>明天就來點單純的<code>shift()</code>小菜囉～</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 從陣列 Array 尾端刪除元素的 pop()</title>
      <link href="/tsuifei.github.io/JS_ironMan16_JavaScript-Array-pop()-Method/"/>
      <url>/tsuifei.github.io/JS_ironMan16_JavaScript-Array-pop()-Method/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-16"><a href="#Day-16" class="headerlink" title="Day 16"></a>Day 16</h6><blockquote><p>既然都要被刪掉了，那就跟他告別吧！誰叫他要吊車尾。</p></blockquote><p>在 javascript 裡，我們常常會把 push( )、pop( )、unshift( )、shift( )這四個陣列方法一起討論，因為 push( )、pop( )一組、unshift( )、shift( )一組，正代表著兩種不同的資料結構和演算法，它們分別是堆疊（Stack）和佇列(Queue)，但它們又分別代表什麼呢？我們先來看一下這張圖：</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20191001/20104175Lq4qae4nP9.png" alt="https://ithelp.ithome.com.tw/upload/images/20191001/20104175Lq4qae4nP9.png"></p><a id="more"></a><p>在寫程式的路上，常常聽前輩說電腦科學的基礎很重要，也就是我們常聽到的 Computer Science，但是電腦科學又包含了什麼呢？對於程式設計的領域來說，有資料結構（Data Structure）與演算法（Algorithm）是影響效能的重要關鍵。尤其是資料結構，善用不同的資料結構特性，可達到較好的效能，但是對於初學者而言，要入門並不是那麼親和，但多知道這方面的知識或概念總是好的，或許哪一天會有機會用到也說不定。</p><h3 id="堆疊（Stack）像一疊盤子一樣-剛放上去的先拿"><a href="#堆疊（Stack）像一疊盤子一樣-剛放上去的先拿" class="headerlink" title="堆疊（Stack）像一疊盤子一樣 剛放上去的先拿"></a>堆疊（Stack）像一疊盤子一樣 剛放上去的先拿</h3><p>堆疊是一種依循「後進先出（Last In First Out，LIFO）的有序集合」。說到堆疊，我們常拿疊盤子的例子來說明最清楚。因為是堆疊，我們會從底下一一的疊上來，但是當我們要用盤子時，並不會傻到把整疊盤子拿起來，再把放第一個盤子拿出來用對吧？不會，我們通常會先從最上面的那個盤子開始拿，這樣後進先出（後放先取）的行為模式，就是記憶體裡的堆疊（Stack）。</p><h3 id="佇列-Queue-像排隊一樣-第一個優先-後來的等等"><a href="#佇列-Queue-像排隊一樣-第一個優先-後來的等等" class="headerlink" title="佇列(Queue) 像排隊一樣 第一個優先 後來的等等"></a>佇列(Queue) 像排隊一樣 第一個優先 後來的等等</h3><p>佇列（Queue）依循的則是「先進先出（First In First Out, FIFO）的有序串列」，最常拿來譬喻的就是排隊買門票， <del>排隊上廁所也可以</del> 。先排隊的人先買票，後來的就從後面排隊等候，等到前面的人買完票，才會被輪到。這樣的資料結構最常應用在要列印檔案的時候，先下指令要列印的會先印，之後發出指令要列印時，也只能在前面被列印出來才輪的到。這樣的行為模式就是佇列。</p><p>如果去翻閱和資料結構有關的書籍，會發現在程式語言中，許多運算式的轉換或是方法的呼叫都用得上，真的應該找機會來學學如何應用。</p><p>接下來就要進入陣列方式的介紹，今天要介紹的和前一篇介紹的<code>push()</code>成雙成對的<code>pop()</code>。<code>push()</code>負責從陣列尾端加上新的元素，而<code>pop()</code>則是從陣列的後方，一次只能一個的拿掉元素。</p><h2 id="pop-請斷我尾巴吧！"><a href="#pop-請斷我尾巴吧！" class="headerlink" title="pop() 請斷我尾巴吧！"></a>pop() 請斷我尾巴吧！</h2><p><code>pop()</code> 方法會從陣列的尾端一次移除一個陣列元素，並回傳被移除掉的那個元素的<code>index</code>值。<br>使用<code>pop()</code> 方法並不需要給參數，並且在執行完之後，會改變原陣列的長度與元素內容。</p><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank" rel="noopener">Array.prototype.pop() - JavaScript | MDN</a></p><p><strong>原型：</strong> Array.prototype.pop()<br><strong>功能：</strong> 移除並回傳陣列的最後一個元素。<br><strong>改變：</strong> 此方法會改變原陣列的長度和內容。<br><strong>語法：</strong> arr.pop()<br><strong>回傳值：</strong> 自陣列中移除的元素；若陣列為空，則為 undefined。<br><strong>參數：</strong> 無</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20104175mdzx0csS8N.png" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20104175mdzx0csS8N.png"></p><p>我們看範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.pop(); <span class="comment">// 5</span></span><br><span class="line">arr; <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure><p>接下來看一下原生可能的寫法，為了避免覆蓋到原生的<code>pop()</code>方法，我們把這個方法另外取名為<code>pop2()</code>，並將它放到瀏覽器的開發者工具來測試。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先建立一個陣列變數</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 實作 pop2()</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.pop2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.splice(<span class="keyword">this</span>.length - <span class="number">1</span>, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 測試</span></span><br><span class="line">arr.pop2(); <span class="comment">// 5 表示刪除位於 index[5]的元素</span></span><br><span class="line"><span class="comment">// 觀察 arr</span></span><br><span class="line">arr; <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure><p>我們可以試著了解上述的寫法，以上述的<code>arr</code>的例子來說：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr 的內容 [1,2,3,4,5] 即是 this</span></span><br><span class="line"><span class="comment">// 而 pop2() 的回傳的 this.splice(this.length - 1, 1)[0];</span></span><br><span class="line"><span class="comment">// =&gt; [1,2,3,4,5].splice(從 5 開始取, 取一個)[的位於index 0 位置的元素];</span></span><br><span class="line"><span class="comment">// length - 1 指的是陣列長度的最後一個 5</span></span><br></pre></td></tr></table></figure><p>鐵人賽已經進行到一半了，據說，這才是鐵人賽 <del>地獄</del> 真正的開始。的確，如果沒有大量積稿，能夠一天把一篇寫出來，實在是很吃力的事，尤其有許多東西還在學習，有許多資料要看，雖然有壓力，但或許也是讓自己成長的好方法，讓我們一起加油吧～</p><h4 id="延伸閱讀："><a href="#延伸閱讀：" class="headerlink" title="延伸閱讀："></a>延伸閱讀：</h4><p><a href="https://blog.techbridge.cc/2016/06/24/javascript-data-structure-algorithm-stack/" target="_blank" rel="noopener">用 JavaScript 學習資料結構和演算法：堆疊（Stack）篇</a></p><p><a href="https://blog.techbridge.cc/2016/12/10/javascript-data-structure-algorithm-queue/" target="_blank" rel="noopener">用 JavaScript 學習資料結構和演算法：佇列（Queue）篇</a></p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 從陣列 Array 尾端新增元素的 push()</title>
      <link href="/tsuifei.github.io/JS_ironMan15_JavaScript-Array-push()-Method/"/>
      <url>/tsuifei.github.io/JS_ironMan15_JavaScript-Array-push()-Method/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-15"><a href="#Day-15" class="headerlink" title="Day 15"></a>Day 15</h6><blockquote><p>有付出一定有收穫，有 push ㄧ定有增加，但是要排隊喔～</p></blockquote><p>介紹陣列方法的第一天，想先請大家看一下底下的這張圖，在上一篇，我們依 JavaScript 的更新版本與方法的功能來列出所有<a href="https://d1dwq032kyr03c.cloudfront.net/upload/images/20190929/20104175PsptgttSeB.png" target="_blank" rel="noopener">陣列方法（Array Methods）</a>。</p><p>這張圖上的所有方法，皆是 Chrome 瀏覽器有支援的方法，如果擔心與其他瀏覽器的問題，可以到 <a href="https://caniuse.com/" target="_blank" rel="noopener">Can I use</a> 查閱，看看我們使用的功能是否和其他瀏覽器有相容性的問題。</p><a id="more"></a><p>圖中的陣列方法以「回傳的是什麼」和「是否更動陣列」來區分的原因，是因為當我們實做 JavaScript 的時候，無論是處理陣列或利用陣列方法來達到一些目的，甚至在刷演算題時，都需要清楚的知道這些方法回傳的是什麼，或是會不會更動到原本的陣列，以方便接下來的處理。而將不同的回傳值來區分，也有助於記憶，不然要記這麼多方法，真的是不容易啊！ <del>吞銀杏也不一定有效啊</del></p><p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20104175KAwMsqybra.png" alt="陣列方法"></p><p>今天我們要介紹的陣列方法是<code>push()</code>，主要負責從陣列尾端來「新增」元素，這是我們常會用到的方法，新增資料就靠它。</p><h2 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h2><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank" rel="noopener">Array.prototype.pop() - JavaScript | MDN</a></p><p><strong>原型：</strong> Array.prototype.push()<br><strong>功能：</strong> 會將一或多個的值，加入至一個陣列中。<br><strong>改變：</strong> 此方法會改變原陣列的長度和內容。<br><strong>語法：</strong> arr.push(element1[, …[, elementN]])<br><strong>回傳值：</strong> 呼叫此方法執行的變數時，會回傳執行後的新陣列長度（ length 屬性值）。<br><strong>參數：</strong> elementN, 要增加至陣列末端的元素。</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20104175LRHA7aClhg.png" alt="陣列方法"></p><p>範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [<span class="string">'yellow'</span>, <span class="string">'Orange'</span>, <span class="string">'Red'</span>];</span><br><span class="line"><span class="keyword">const</span> count = colors.push(<span class="string">'Blue'</span>);</span><br><span class="line"></span><br><span class="line">count; <span class="comment">// 4 增加後的陣列長度</span></span><br><span class="line">colors; <span class="comment">// ['yellow', 'Orange', 'Red', 'Blue']</span></span><br></pre></td></tr></table></figure><p>也可以一次增加多個元素:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colors.push(<span class="string">'Violet'</span>, <span class="string">'Green'</span>, <span class="string">'Cyan'</span>);</span><br><span class="line">colors; <span class="comment">// ['yellow', 'Orange', 'Red', 'Blue', 'Violet', 'Green', 'Cyan']</span></span><br></pre></td></tr></table></figure><h3 id="push-方法原型"><a href="#push-方法原型" class="headerlink" title="push() 方法原型"></a>push() 方法原型</h3><p><code>push()</code> 是用什麼方法寫出來的呢？有兩種方法。<br>為了避免覆蓋到原生的<code>push()</code>方法，我們可以把這個方法另外取名為<code>push2</code>和<code>push3</code>，並將他們放到瀏覽器的開發者工具。</p><p>第一種方法：我們可以試著在<code>for</code>迴圈裡，把<code>this</code>用<code>console.log</code>印出來，就可觀察到每跑一次迴圈，就會加上我們放在參數<code>arguments</code>裡的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push2(arguments)</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[<span class="keyword">this</span>.length] = <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡的<code>arguments</code>指的是我們放在<code>push()</code>裡的參數。<br><code>this</code>則是指向我們原本的陣列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// `this`</span></span><br><span class="line">arr.push2(<span class="number">4</span>, <span class="number">5</span>); <span class="comment">// `arguments`</span></span><br><span class="line"><span class="comment">// this[this.length] = arguments[i];</span></span><br><span class="line"><span class="comment">// =&gt;  [1,2][2] = 4</span></span><br><span class="line"><span class="comment">// =&gt; [1,2,4][3] = 5</span></span><br></pre></td></tr></table></figure><p>第二種方法：使用<code>splice()</code>方法特性，和其餘參數的方法，把參數增加到原本的陣列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.push3 = <span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.splice(<span class="keyword">this</span>.length, <span class="number">0</span>, ...rest);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裡的<code>this</code>是指向我們原本的陣列。<br><code>splice(this.length, 0, ...rest)</code>則為<code>splice(陣列長度,0, ...rest)</code><br>ES6 的其餘參數<code>...rest</code>：可以將陣列或物件中的資料取出成獨立變數。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// `this`</span></span><br><span class="line">arr.push3(<span class="number">4</span>, <span class="number">5</span>); <span class="comment">// `[4,5]` =&gt; `...rest`</span></span><br><span class="line"><span class="comment">// this.splice(this.length, 0, ...rest)</span></span><br><span class="line"><span class="comment">// =&gt; [1,2].splice(2,0,...rest)</span></span><br></pre></td></tr></table></figure><p>不知對於今天的解釋，有沒有幫助到大家，更了解<code>push()</code>的運作原理和使用方法？<br>我們明天再繼續介紹<code>pop()</code>囉～</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列 Array 方法概觀</title>
      <link href="/tsuifei.github.io/JS_ironMan14_About-JavaScript-Array-Methods/"/>
      <url>/tsuifei.github.io/JS_ironMan14_About-JavaScript-Array-Methods/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-14"><a href="#Day-14" class="headerlink" title="Day 14"></a>Day 14</h6><blockquote><p>知道怎麼做，但是如果有好工具會更得心應手。</p></blockquote><p>JavaScript 一直在演化，也因此因不同時期推出的新方法好像是給我們補充能量，原本需要複雜的程序寫出來的函式，現在大多可用內建的方法處理 <del>for 被放生了</del>，不但直接且經過優化，以往使用<code>For</code>迴圈來遍歷陣列，現在只要用內建方法就可以，簡單又好用。</p><p>如果有用 javascript 來操作處理 JSON 的經驗，會發現陣列方法實在是非常好用，無論是在陣列上的資料過濾、排序、儲存、組合都超級方便！我們可以想像一下，如果我們想要做出好看又好吃的甜點，是不是需要一些必須的工具，例如刮刀、擠花袋、打蛋器（電動的更好、量匙、電子秤等等，如果沒有這些，即使有上好的材料與器材如烤箱，要做甜點勢必困難重重，而這些陣列 Array 的方法正如這些工具，幫我們快速又精準的把甜點做出來。 <del>寫著寫著就餓了</del></p><a id="more"></a><p><img src="https://ithelp.ithome.com.tw/upload/images/20190929/20104175xe6gdKuhHZ.png" alt="dessert"></p><h3 id="好工具永遠不嫌多"><a href="#好工具永遠不嫌多" class="headerlink" title="好工具永遠不嫌多"></a>好工具永遠不嫌多</h3><p>這些好用的陣列工具（功能），是<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">什麼時候被增加</a>到 javascript 裡呢？javascript 發展至今，最主要的版本為 ECMAScript 3/5/6/7/10 ，在 ES3.0 的時期，推出了基本的新增、刪除與切割字串的方法; ES5 又推出了許多查詢與迭代，功能強大的方法。到了 ES6（2015 年發布)，又推出了一些更強大的陣列方法，如迭代器、尋找、替代等相關陣列方法。</p><p>ES3.0 是最標準的，許多方法都是在 3.0 的時候推出來的，這個時期推出的方法，是現今使用的方法中最重要的部分。ES6 因為更新的部分頗多，所以許多人都把 ES6 當成一個檻，有了它可以更加速的開發專案，也因此成為前端工程師的標準技能之一。</p><p>接下來的版本，我們就都知道了，越受歡迎的語言，更新的速度也會越頻繁 <del>看 Python 就知道了</del>。等到 ES7、ES10 出來了，但各家的瀏覽器卻不一定有支援這些新方法，就像年輕人發明的新詞彙、新說法，中年大嬸（瀏覽器）怎麼可能聽得懂？總要一些時間之後，才能讓大嬸聽懂年輕人說的話。</p><p>但是，大嬸也是有愛追流行和傳統婦女之分，跟上潮流的大嬸(瀏覽器)就聽得懂年輕人的詞彙，<del>那些傳統婦女我們就放生吧！</del></p><p>但是每次年輕人（新版 JS）說什麼，讓大部分的大嬸（瀏覽器）都聽不太懂也頗煩惱，會產生代溝啊！所以就有一位在年輕人之間走跳的壯年人（Babel）出來協調翻譯，讓大嬸都聽得懂年輕人的話，讓鴻溝化為無痕……<del>實在好難掰</del></p><h2 id="以功能性來區分的陣列方法"><a href="#以功能性來區分的陣列方法" class="headerlink" title="以功能性來區分的陣列方法"></a>以功能性來區分的陣列方法</h2><p>我們可以發現許多人在介紹陣列方法時，都是以方法是否可以複製、回傳值來分，這也是一種不錯的記憶方法，畢竟方法那麼多，沒記好要用這些方法總是會卡卡的。先來看看以功能分類的陣列方法列表：</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20190929/20104175PsptgttSeB.png" alt="dessert"></p><h2 id="JavaScript-的三巨頭"><a href="#JavaScript-的三巨頭" class="headerlink" title="JavaScript 的三巨頭"></a>JavaScript 的三巨頭</h2><p>上面說了大嬸和年輕人的故事，其實應該說說 JavaScript 的源頭的，在 JavaScript 裡主要構成的成分有：</p><ul><li>ES3/5/6/7/10(ECMAScript) 規範</li><li>DOM (Document Object Model) 文件物件模型</li><li>BOM (Browser Object Model) 瀏覽器物件模型</li></ul><p>ECMAScript 是 JavaScript 所擬出來的規範，而 DOM 和 BOM 是以參與形式增加了許多使用上的規則，透過 DON 以 JavaScript 來操控 HTML 也就是 Windows; 而 BOM 則是透過 JavaScript 來操控瀏覽器。ECMAScript 給出 DOM 和 BOM 的標準，由各個瀏覽器來補充與支援這些方法，讓這些新功能可以在最新的瀏覽器上被讀取與使用。</p><p>瀏覽器執行 JavaScript 的環境，是由不同的瀏覽器廠商，結合 ECMAScript 固定的規範而產生出來執行的環境，也因此，各個瀏覽器讀取 DOM 和 BOM 會有些許差異，才造成相同的程式碼在不同的瀏覽器解析下會有不同的結果。尤其是 BOM 是操作瀏覽器的規則，各家瀏覽器都以自己的標準為標準 <del>好任性</del>，自然呈現的差異性會比較大。</p><p>接下來將介紹陣列方法的篇章，會以 Chrome 最新版的瀏覽器為主 <del>其他放生</del>，如何知道 Chrome 有支援哪些新的方法？只要我們打開 Chrome 的開發工具，選擇<code>console</code>分頁，輸入<code>Array.prototype</code>按<code>entre</code>之後就會出現在這個瀏覽器版本可以執行方法和屬性。</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20190929/20104175O7rB8LpoRb.png" alt="prototype"></p><p>希望大家在學習 JavaScript 時可以多去了解 JavaScript 歷史與演化，這或許會對掌控這個語言的特性更有幫助。明天我們正式進入陣列方法的介紹囉～</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遍歷陣列的方法</title>
      <link href="/tsuifei.github.io/JS_ironMan13_Different-ways-to-traverse-an-Array-in-JavaScript/"/>
      <url>/tsuifei.github.io/JS_ironMan13_Different-ways-to-traverse-an-Array-in-JavaScript/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-13"><a href="#Day-13" class="headerlink" title="Day 13"></a>Day 13</h6><blockquote><p>傻傻以為迴圈是唯一，那只是沙灘上的一塊小岩石。</p></blockquote><p>回想剛開始學程式時，看到 While 迴圈可以透過 ASCII 碼，把英文數字從 ａ 到 Z 印出來，感到好驚訝！到底是怎麼辦到的？但是，經過了幾次無限迴圈的背叛後，才知道如果迴圈不給一個「範圍」，就會出大事。 <del>電腦整個當掉要重開</del></p><p>記得小時候家裡小孩多，當時的台灣經濟正在起飛 <del>馬上透露了世代</del>，家庭代工正興起。記得媽媽總是會叫我們兄弟姐妹來幫忙 <del>是滴，本人兄弟姐妹都有。</del> 當時的手工產品是要寄往北方某個遙遠國度的聖誕節飾品，也就是要掛在樹上的小型禮物盒。媽媽先是叫我們排排坐，開始解說步驟，接著就開始這條要完成「一百個」小禮物的童工生產線：</p><a id="more"></a><ul><li>哥哥把一張包裝紙拿起來放桌上</li><li>姊姊把四方形的保麗龍放在包裝紙上</li><li>我用包禮物的方法把保麗龍包起來</li><li>妹妹用金線把四方形的禮物綑起來 <del>有時還要我幫她</del></li><li>弟弟把印有 Mede in Taiwan 的小金貼紙貼在禮物的底部</li></ul><p>這樣就完成了一個小飾品。</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20190928/20104175SagETy0KNh.png" alt="圖"></p><h2 id="迴圈和陣列有什麼關係？"><a href="#迴圈和陣列有什麼關係？" class="headerlink" title="迴圈和陣列有什麼關係？"></a>迴圈和陣列有什麼關係？</h2><p>以上述的情境來說，所有要做的小飾品是陣列；童工生產線是迴圈；小童工各自的工作項目，是在迴圈裡的處理步驟。而陣列的範圍是長度「一百個」這個數量。也就是說，這個迴圈要跑一百次。</p><p>一般我們想要「批次處理」一堆資料就會想到用迴圈，因為迴圈可以自動化的將我們想做的事「逐ㄧ」套在各個元素上執行，而迴圈又以<code>for</code>迴圈最常被使用。</p><p>那我們常聽到的「迭代(iterate)」是什麼？和「遍歷(traversal)」又有什麼不同？請教了前輩才比較清楚的理解，剛剛說的“「逐ㄧ」套在各個元素上執行”，其實就是「迭代」。而迭代是由「遍歷 + 改變」構成的，整個過程即為「迭代 = 遍歷 + 改變」。</p><p>對於陣列，<code>for</code>迴圈是最常使用的遍歷方式，我們可以在這個遍歷的方法裡做許多事。例如說在迴圈裡畫星星 <del>或耍廢</del>。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 印出五顆星星</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> star = <span class="number">0</span>; star &lt; <span class="number">5</span>; star++) &#123;</span><br><span class="line">  <span class="comment">// 執行五次：從star為0到4</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'*'</span>); <span class="comment">// 印出星星</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是時代不同了，JavaScript 每次更新，都會給我們帶來許多好用的方法，該做的事都和迴圈都幫我們一起包在裡面了，尤其是<code>ECMAScript 5</code>增加了許多功能強大的迭代陣列方法，這就是 JavaScript 的內建陣列函式的巧妙之處了。有關 JavaScript 的內建陣列函式，會在接下來的篇章一一介紹。</p><h2 id="遇到稀疏陣列怎麼辦？"><a href="#遇到稀疏陣列怎麼辦？" class="headerlink" title="遇到稀疏陣列怎麼辦？"></a>遇到稀疏陣列怎麼辦？</h2><p>遍歷陣列的作法，是逐一的去走訪在陣列的每一個值，看過政治人物在街頭嗎？他們看到民眾時會和民眾逐一握手，那一排的民眾是陣列；每一個民眾就像是元素；握手就是讓元素產生變化 <del>考慮看看要不要投你</del>。<br>但是，如果這位政治人物在逐一握手的時候，中間卡了座石獅子，他也會跳過這隻不會握手的石獅子，繼續跟下一位民眾握手。這一排民眾就成了稀疏（spars）陣列的民眾、而這隻石獅子就是稀疏陣列裡面無效或空的元素。</p><p>通常在使用迭代陣列方法，遇到是稀疏陣列的時候，我們會先把一些無效或空的元素先排除，例如<code>null</code>或<code>undefined</code>，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, , <span class="literal">null</span>, <span class="number">5</span>, <span class="literal">undefined</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr[i]) <span class="keyword">continue</span>;</span><br><span class="line">  arr2.push(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">arr2; <span class="comment">// [1,2,5]</span></span><br></pre></td></tr></table></figure><p>我們希望回傳的是這個陣列被處理過後的結果，但如果是稀疏陣列，這些無效的值也會被一併保留，很沒意義。所以在做處理前，最好先把陣列處理成密集的陣列，這樣迭代才有意義。</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以陣列 Array 的複製談型別（下）</title>
      <link href="/tsuifei.github.io/JS_ironMan12_How-to-copy-an-Array-in-JavaScript-part2/"/>
      <url>/tsuifei.github.io/JS_ironMan12_How-to-copy-an-Array-in-JavaScript-part2/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-12"><a href="#Day-12" class="headerlink" title="Day 12"></a>Day 12</h6><blockquote><p>拿到它，先看它是什麼？拿它來做什麼? 再決定。</p></blockquote><p>在複製陣列之前，先理解了 JavaScript 會依資料型別 Primitive type（基本型別）和 Non-primitive type（非基本型別）而有不同的運作方式，我們就可以進一步的來了解，我們常聽到的深拷貝（DeepCopy)和淺拷貝(shallow) 是什麼、在什麼情境下要選擇哪一種複製方法、如何實作出這些深拷貝和淺拷貝。</p><h2 id="什麼是拷貝？"><a href="#什麼是拷貝？" class="headerlink" title="什麼是拷貝？"></a>什麼是拷貝？</h2><p>在生活中我們最常做的拷貝就是影印，假如我有一份筆記，朋友跟我借去拷貝，當他拿著我的筆記，到影印機前，按下拷貝鍵的那一刻，複製的筆記從機器跑出來，這時「拷貝」這件事就算完成，「我的筆記」和「他影印的筆記」是各自獨立的筆記，之後他要在這份影印的筆記上塗鴉也好、修改也好，也不會影響我的筆記。</p><a id="more"></a><p>但是在 JavaScript 裡，當我們新建立一個變數<code>a</code>，賦予這個變數一個值，然後再建立一個新變數<code>b</code>，接著以<code>=</code>指定運算子來把<code>a</code> 指定給<code>b</code>，這樣就算拷貝嗎？雖然我們<code>a</code>、<code>b</code>叫出來看都是 ˋ42ˋ，但是這真的是拷貝嗎。？是或不是？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">a; <span class="comment">// 42</span></span><br><span class="line">b; <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><h3 id="被複製的資料型別是重點"><a href="#被複製的資料型別是重點" class="headerlink" title="被複製的資料型別是重點"></a>被複製的資料型別是重點</h3><p>事實上，這得要看我們要複製什麼東西，才能知道我們是否可以「輕易」的複製，且「真正」的把複製和被複製的徹底分離。<br>更確切的說，如果我們要複製的變數值型態，是屬於 Primitive data types（基本資料型別），也就是以下的資料型態：</p><ul><li>Number (數字)，例如 <code>42</code></li><li>String (字串)，例如 <code>&quot;Hi&quot;</code></li><li>Boolean (布林值)，例如 <code>true</code></li><li>undefined</li><li>null</li></ul><p>那麼我們就可以放心的以上述的方式複製。</p><p>還記得前一篇提到的 Call by value（呼叫變數的值）嗎？這些資料型別在 JavaScript 裡是屬於 Immutable (不可變)的基本型別，以值的方式複製可以得到真正的、獨立的複製。</p><h3 id="你以為你複製了，但是並。沒。有。"><a href="#你以為你複製了，但是並。沒。有。" class="headerlink" title="你以為你複製了，但是並。沒。有。"></a>你以為你複製了，但是並。沒。有。</h3><p>但是，如果今天要被複製的資料型態是 Non Primitive data types（非基本資料型別），也就是 Object (物件型別)，那就無法完全複製。例如：</p><ul><li>Array (陣列)，例如 <code>[1, 2, 3, 4, 5]</code></li><li>Object (物件)，例如 <code>{ name : &quot;Tsuifei&quot;}</code></li></ul><p>因為陣列和物件是屬於 Call by reference（呼叫變數的記憶體位址），也就是說當我們複製這類型的資料，只是複製了這個變數的記憶體位置，所以當我們呼叫複製和被複製的變數時，都會指向同一個記憶體位置，當然，裡面的值也是同一個值，改任何一個，都會動到兩個變數的值。<br>我們再來複習一下前一篇的範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by reference(參考值)</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Tracy'</span>,</span><br><span class="line">  city: <span class="string">'Tainan'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = person;</span><br><span class="line">person2.name = <span class="string">'Ayda'</span>;</span><br><span class="line"></span><br><span class="line">person; <span class="comment">// name: "Ayda"</span></span><br><span class="line">person2; <span class="comment">// name: "Ayda"</span></span><br></pre></td></tr></table></figure><p>我們可以看到，在我們修改從<code>person</code>複製出來的<code>person2</code>時，<code>person</code>也被修改了。</p><h2 id="物件專用的深拷貝和淺拷貝"><a href="#物件專用的深拷貝和淺拷貝" class="headerlink" title="物件專用的深拷貝和淺拷貝"></a>物件專用的深拷貝和淺拷貝</h2><p>終於，我們要進入 <del>深眠和淺眠</del> 這個正題了。<br>不知大家有沒發現，在討論這個深淺拷貝的範例時，清一色都是用物件來示範？原來，「深拷貝」和「淺拷貝」是針對物件的資料型別複製時，所產生的現象而來的啊！</p><p>但是要如何在 JavaScript 中區分深拷貝和淺拷貝？何時該用「深拷貝」或「淺拷貝」，用最簡單的方式是取決於我們想要複製的資料<code>[元素]</code>是什麼型別。 <del>結束。</del></p><h3 id="淺拷貝-只要一層都好說"><a href="#淺拷貝-只要一層都好說" class="headerlink" title="淺拷貝 [ ] 只要一層都好說"></a>淺拷貝 [ ] 只要一層都好說</h3><p>完全的複製 Array 而不受原陣列影響，即使修改複製過來的物件裡的值，也不會改變複製來源，這個物件裡面的「元素」可以是任何一種資料型態，反著說，就是這個物件裡面的元素，不能是物件。如果遇到這樣的資料，就可以用淺拷貝的方法複製。</p><p>有哪幾種方法可以做淺拷貝？最常被拿來用的是 JavaScript 內建的陣列方法<code>slice()</code>。 <del>它的詳細解說會在後幾章才會介紹到。</del> <code>slice()</code>通常拿來做從陣列中切取我們需要的元素出來，在這裡我們使用<code>slice(0)</code>表示我們要從頭到尾都切下來。 <del>切切切</del></p><p>在下面第一個範例，「淺拷貝」是可行的，因為<code>arr1</code>陣列裡的元素是基本資料型別<code>Number</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">42</span>;</span><br><span class="line">arr1; <span class="comment">// [1, 2, 3]</span></span><br><span class="line">arr2; <span class="comment">// [42, 2, 3]</span></span><br></pre></td></tr></table></figure><p>但是以下這個範例，<code>arr1</code>陣列裡的「元素」是「物件型別」的陣列，淺拷貝對於原物件裡面的元素值是物件型態就是不行！ <del>噠美噠美</del></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 淺拷貝 []</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">arr2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">42</span>;</span><br><span class="line">arr1;</span><br><span class="line"><span class="comment">// 0: (3) [42, 2, 3]</span></span><br><span class="line"><span class="comment">// 1: (3) [4, 5, 6]</span></span><br><span class="line">arr2;</span><br><span class="line"><span class="comment">// 0: (3) [42, 2, 3]</span></span><br><span class="line"><span class="comment">// 1: (3) [4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>網路上能找到的大多是淺拷貝的例子，雖然淺 <del>可別因此就鄙視它</del>，只要確認要複製的來源物件，裡面的元素不是物件型別，還是非常好用的。<br>礙於篇幅，這裡只介紹一種淺拷貝的方式，有興趣的朋友可查找網路上其他的方法，例如用解構式、迴圈或使用<code>map()</code>都可達到淺拷貝的效果。</p><h3 id="深拷貝-–-gt-DNA-被複製，桃莉羊出現了"><a href="#深拷貝-–-gt-DNA-被複製，桃莉羊出現了" class="headerlink" title="深拷貝 [ [ ],[ ] ] –&gt; DNA 被複製，桃莉羊出現了"></a>深拷貝 [ [ ],[ ] ] –&gt; DNA 被複製，桃莉羊出現了</h3><p>何時使用深拷貝？當我們想要完全複製一份「物件」裡面的元素也是「物件」，就可以使用深拷貝，這種情境就是我們在本文開頭所說的，用影印機複製筆記ㄧ樣，複製完就是兩個獨立的個體了。</p><p>做深拷貝的方法並不多，大部分都是靠外來的函式庫來撐腰，例如 lodash 和 jQuery 的第三方主流函式庫，如果使用原生的 JavaScript 來做深拷貝，似乎只能使用<code>JSON.stringify()</code>和<code>JSON.parse()</code>的交互作用，達到深拷貝的效果。</p><p>來看一下 MDN 對這兩個函式的解釋： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener">JSON.stringify()| MDN</a> ｜ <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank" rel="noopener">JSON.parse() | MDN</a></p><blockquote><p><code>JSON.stringify()</code>方法是將一個 JavaScript 的值(物件或陣列)轉換為一個<code>JSON</code>的字串。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">];</span><br><span class="line">arr = <span class="built_in">JSON</span>.stringify(arr); <span class="comment">// "[[1,2,3],[4,5,6]]"</span></span><br></pre></td></tr></table></figure><blockquote><p><code>JSON.parse()</code>方法用來解析<code>JSON</code>的字串，構造由字串描述的 JavaScript 值或物件。</p></blockquote><p>這時的<code>arr</code>已經變成 JSON 的字串格式：<code>&quot;[[1,2,3],[4,5,6]]&quot;</code>。<br>接下來再轉回陣列的型態：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="built_in">JSON</span>.parse(arr); <span class="comment">// [[1,2,3],[4,5,6]]</span></span><br></pre></td></tr></table></figure><p>把原本的物件值轉成字串，然後再轉回來物件的型態，兩個函式手牽手處理下來，就等於複製了一份<code>arr1</code>到<code>arr2</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonDeepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr1 = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> arr2 = jsonDeepClone(arr1);</span><br><span class="line"></span><br><span class="line">arr2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">42</span>;</span><br><span class="line">arr1;</span><br><span class="line"><span class="comment">// 0: (3) [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 1: (3) [4, 5, 6]</span></span><br><span class="line">arr2;</span><br><span class="line"><span class="comment">// 0: (3) [42, 2, 3]</span></span><br><span class="line"><span class="comment">// 1: (3) [4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>這樣的一個拷貝過程與結果就是深拷貝（DeepCopy）了。</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以陣列 Array 的複製談型別（上）</title>
      <link href="/tsuifei.github.io/JS_ironMan11_How-to-copy-an-Array-in-JavaScript-part1/"/>
      <url>/tsuifei.github.io/JS_ironMan11_How-to-copy-an-Array-in-JavaScript-part1/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-11"><a href="#Day-11" class="headerlink" title="Day 11"></a>Day 11</h6><blockquote><p>別懷疑，複製就是拷貝，深拷貝淺拷貝就是深複製淺複製，呼～</p></blockquote><p>人家說，如果我們可以和某位朋友一起旅行 30 天，要嘛旅程結束變至親，不然就是變仇人，鐵人賽已經第十天，本人也開始有點了解 Array 這位木訥寡言，但一肚子學問的中年大叔。很難想像，光陣列就可以讓我寫十天寫不盡，即使寫完它，但是後頭還有多少 JavaScript 特性或其他奇怪的東西要了解？不過，只要確定走在進步的路上，那就繼續走吧！</p><h2 id="複製到哪個程度？"><a href="#複製到哪個程度？" class="headerlink" title="複製到哪個程度？"></a>複製到哪個程度？</h2><p>要說到陣列的複製，得讓我們聊聊 Javascript 是怎麼將型別分類的，原因是這牽涉到記憶體的分配與讀取的方式。在這之前，我們再來複習一下，在前幾天有聊到的 Javascript 資料型別。</p><a id="more"></a><p>在「你說不知道的 JS 導讀，型別與文法」提面提到，JavaScript 定義了七個內建型別：</p><ul><li>Null</li><li>Undefined</li><li>Boolean</li><li>Number</li><li>String</li><li>Object</li><li>Symbol (ES6 增加的，但目前還很少用)</li></ul><p>而在這些型別中，又被分為兩大類 Primitive type（基本型別）和 Non-primitive type（非基本型別）。形容這兩大類的詞彙有許多版本，我們可以透過底下這張圖看得更清楚一點。</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20104175vA55RlDfRq.png" alt="DataType圖"></p><p>實作時常會聽到<code>call by reference</code> 還是 <code>call by value</code>，這兩個有什麼不同？最簡易的解釋方法是：</p><ul><li>Call by value : 呼叫變數的值</li><li>Call by reference : 呼叫變數的記憶體位址</li></ul><p><code>Objet</code> 和 <code>Array</code> 在 Javascript 屬於複合型（composite）或參考型（reference）的原始資料類型，在呼叫、複製或傳參數的時候，是參考記憶體的位址而不是值，這點要特別注意。</p><p>在查找資料時，又多了新的疑問，因為許多人談到另一種名叫<code>call by sharing</code> 雖然讀了許多資料，但本人還是無法清楚的釐清它和<code>Call by reference</code>的相異之處，有興趣的朋友可以來看看這篇<a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/" target="_blank" rel="noopener">深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？ | TechBridge 技術共筆部落格</a> 相信會有收穫的，在本人還沒完全吸收的狀況下，還是留給高人來解說比較保險。</p><h2 id="比較不同型別的複製的方法"><a href="#比較不同型別的複製的方法" class="headerlink" title="比較不同型別的複製的方法"></a>比較不同型別的複製的方法</h2><h3 id="By-value-你的是你的，我的是我的"><a href="#By-value-你的是你的，我的是我的" class="headerlink" title="By value 你的是你的，我的是我的"></a>By value 你的是你的，我的是我的</h3><p>這些抽象的概念，初學者並不是那麼容易懂，但透過實作會讓這些抽象部分更有感覺。</p><p>我們先創建一個變數<code>a</code>，再將<code>a</code>複製給<code>b</code>，接著重新給<code>b</code> 一個新值，然後以這兩個變數的結果來觀察。我們會發現<code>a</code>和<code>b</code>都有各自的值。<code>a</code>的值不會因為<code>b</code>而更動到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by value</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'something'</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b = <span class="string">'somebody'</span>;</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// something</span></span><br><span class="line">b; <span class="comment">// somebody</span></span><br></pre></td></tr></table></figure><h3 id="By-reference-你怎麼把我變得跟你一樣？"><a href="#By-reference-你怎麼把我變得跟你一樣？" class="headerlink" title="By reference 你怎麼把我變得跟你一樣？"></a>By reference 你怎麼把我變得跟你一樣？</h3><p>我們先以物件資料型態的物件來測試。</p><p>先建立一個物件<code>person</code>，並給予兩個屬性，在另創一個變數<code>person2</code>，並將<code>person</code>指向（或複製）到<code>person2</code>，這時我們試著修改<code>person2</code>的某個屬性，結果<code>person</code>的屬性也被更動了。</p><p>在修改<code>person2</code>這個<code>object</code>裡的<code>name</code>屬性時，也會同時改到原來參考的<code>person</code>的<code>name</code>屬性，是不是很恐怖？</p><p>因為他們兩個是住在同一個記憶體裡啊！只不過，當我們認為從<code>person</code>複製一份到<code>person2</code>這件事，實際上是並沒有像影印一樣拷貝一份，而是拷貝時，我們跟<code>person2</code>說，要找<code>person2</code>就來<code>person</code>這個位址查找吧，所以來到同樣一個位址，改變<code>person2</code>也就理所當然的改到原本的<code>person</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by reference(參考值)</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Tracy'</span>,</span><br><span class="line">  city: <span class="string">'Tainan'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = person;</span><br><span class="line">person2.name = <span class="string">'Ayda'</span>;</span><br><span class="line"></span><br><span class="line">person; <span class="comment">// name: "Ayda"</span></span><br><span class="line">person2; <span class="comment">// name: "Ayda"</span></span><br></pre></td></tr></table></figure><p>接下來我們來測試我們的主角陣列。<br>同樣是先創建一個陣列的變數<code>arr1</code>，並複製一份給<code>arr2</code>，接著我們試著在<code>arr2</code>的<code>index3</code>位置加入一個陣列元素<code>4</code>(使用<code>push()</code>也可以)，再把兩個陣列叫出來觀察。</p><p>嗯，<code>arr1</code>也被更動到了！ <del>是不是很討厭！</del></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 陣列 by reference(參考值)</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1;</span><br><span class="line">arr2[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">arr1; <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">arr2; <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>因為<code>Array</code>也是參考型<code>(reference)</code>的原始資料類型所以也會像<code>Object</code>一樣，在修改時也會更改到原始參考值<code>by reference</code>。</p><h3 id="住在同一個位址有問題嗎？"><a href="#住在同一個位址有問題嗎？" class="headerlink" title="住在同一個位址有問題嗎？"></a>住在同一個位址有問題嗎？</h3><p>這樣的狀況會對寫程式和處理資料有什麼影響？ <del>會出人命啊</del> 當然會。</p><p>想像一下我們跟同學借了筆記來抄，抄完之後我們開始在我們抄過來的筆記上畫重點，甚至塗鴉，等到借我們筆記的同學翻開他的筆記時，發現 <del>這什麼鬼啊</del> 筆記上有著我們畫的密密麻麻的記號和塗鴉，友誼還要走下去嗎？</p><p>上面的複製方式是我們最常用的，也是最直覺的複製方法，但是卻對陣列與物件的資料行不通，有其他方法複製嗎？當然有 <del>或….應該有～～</del>。</p><p>我們可以利用 JavaScript 許多內建的方法來做複製這件事，但是 JavaScript 可沒那麼容易讓我們複製物件型態的資料。大家也聽過很多人都在聊的「深拷貝（DeepCopy）」和「淺拷貝（ShallowCopy）」，這兩者的區別又在哪裡呢？</p><p>我們可以先想像一下，在 JavaScript 裡，要複製這些物件型別的「DNA」是有難度的，假如我們想徹徹底底地模仿一位巨星，髮型、服飾、化妝、配件都和這位巨星打扮的一模一樣，這樣或許看起來一樣，但當我們講話、走路時，就馬上會被識破，然後我們努力的把自己的音調也改了、姿態也修正了，以為一切都完美了，結果，遇到這會巨星的好朋友或男友，你想，我們會過關嗎？</p><p>物件型別的複製，正有如以上講述情境的尷尬，也就是說，即使是複製，也是分好幾個層級的。我們明天再來聊聊，如何改變我們的<code>DNA</code>，完完全全地成為那位巨星！ <del>甘五摳零？</del></p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何把陣列或元素清空和刪除</title>
      <link href="/tsuifei.github.io/JS_ironMan10_Remove-empty-or-delete-array-elements/"/>
      <url>/tsuifei.github.io/JS_ironMan10_Remove-empty-or-delete-array-elements/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h6><blockquote><p>好好的吃頓飯也是一種優雅。刪除也是。</p></blockquote><p>「如何把陣列或元素清空」也要寫一篇？ <del>妳當牛肉麵在寫嗎？</del><br>自從有了這本「JavaScript 大全」<del>當枕頭，阿不是</del>，才發現自己真是懵懂無知，但求知識不嫌遲，只能盡量腦補，讓自己盡量處於知道 JavaScript 到底做了什麼的狀態～結論是：路，還很長。</p><p>原本以為 Javascript 像某些語言ㄧ樣，可以控制記憶體或把某部分的記憶體釋放出來，就在網路上開始找如何刪除變數的文章，結果搜尋結果清一色是在講，如何「刪除陣列裡的元素」這件事，才發現 JavaScript 似乎沒有完全把變數刪除這件事，我們也看不見記憶體的存取或清空的狀態，只能用一些機制來驗證。結論是對陣列 Array 來說，沒有把陣列刪除變數這件事，似乎就只能把陣列清空，而不能刪除變數。 <del>自己無法作主的人生</del></p><a id="more"></a><h3 id="用-Delete-刪除陣列可以嗎？"><a href="#用-Delete-刪除陣列可以嗎？" class="headerlink" title="用 Delete 刪除陣列可以嗎？"></a>用 Delete 刪除陣列可以嗎？</h3><p>在「JavaScript 大全」裡 <del>p55</del> 有說明： 1.如果用<code>let</code> 來宣告變數，創立的特性會是<code>nonconfigurable</code>也就是不可配置的，這個變數是不可用<code>delete</code>這個運算子刪除。 2.如果不是在<code>strict</code>模式底下，將值指定給一個為宣告的變數，JavaScript 會自動為我們創建一個全域變數，用這種方式創建的變數具有<code>configurable</code>特性，也就是可以被<code>delete</code>運算子刪除。</p><p>第一點說的宣告，其實也包括了用<code>let</code>和<code>const</code>來宣告變數，我們可以可以用簡單的方式來測試一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">delete</span> b; <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">delete</span> c; <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line">d = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">delete</span> d; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// Uncaught ReferenceError: d is not defined</span></span><br></pre></td></tr></table></figure><p>變數 <code>d</code> 就真的這樣被刪除掉了！</p><p>那麼其他不是透過<code>Delete</code>刪除的變數，是怎麼被全域環境清除掉的？<br>JavaScript 有一種清理 <del>廚餘</del>的機制，是一種垃圾收集器(garbage collector)，它會在變數不再被使用的時候出現，並釋放掉不再使用的記憶體，當然，變數也就這樣真的刪除掉了。</p><p>終於要進入今天的主題了：刪除陣列元素 <del>在拖什麼啊</del></p><h2 id="完全清空陣列"><a href="#完全清空陣列" class="headerlink" title="完全清空陣列"></a>完全清空陣列</h2><h3 id="第一種方法-全部掏掉"><a href="#第一種方法-全部掏掉" class="headerlink" title="第一種方法 全部掏掉"></a>第一種方法 全部掏掉</h3><p>將空陣列[]直接指派給要清除的 Array，這種方式其實不算清空，比較像是我們拿另一塊空的記憶體，重新指派給這個變數。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1;</span><br><span class="line">arr1 = [];</span><br><span class="line">arr1; <span class="comment">// []</span></span><br><span class="line">arr2; <span class="comment">//  [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>可以確定的是，如果我們複製了一份，複製的那份將不會受到原陣列的影響。<br>這一種方式和底下幾種清除陣列元素的方式，有一個很大的不同，就是使用重新指派的方式清空陣列，如<code>arr1 =[]</code>，因為重新指派，所以即使在這之前有做陣列複製如<code>arr2 = arr1</code>，兩個陣列也不會互相影響。<br><img src="https://ithelp.ithome.com.tw/upload/images/20190925/201041758t4T0hQuop.png" alt="記憶體配置圖"></p><h3 id="第二種方法-將長度歸零就沒事？"><a href="#第二種方法-將長度歸零就沒事？" class="headerlink" title="第二種方法 將長度歸零就沒事？"></a>第二種方法 將長度歸零就沒事？</h3><p>直接將陣列的長度<code>length</code>歸<code>0</code>，這種方式效能會比較好。但是，恩湯恩湯。因為複製於這個陣列的其他陣列，也會被改變。也就是說是以參考同一個記憶體位置<code>by Reference</code>的方式進行複製。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1;</span><br><span class="line">arr1.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">arr1; <span class="comment">// []</span></span><br><span class="line">arr2; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h3 id="第三種-用-splice-就比較好？"><a href="#第三種-用-splice-就比較好？" class="headerlink" title="第三種 用 splice 就比較好？"></a>第三種 用 splice 就比較好？</h3><p>splice()通常是拿來刪除陣列裡的某個元素，當然也可以拿來刪除元素，但是 splice()本身並不會複製一份新陣列，而是會指向原陣列的位址，所以原陣列被刪除的元素，複製過來的陣列元素也同時會被刪除。<br>splice()的用法在後面的篇章會有更詳盡的介紹。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1;</span><br><span class="line">arr1; <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">arr1.splice(<span class="number">0</span>, arr1.length);</span><br><span class="line"></span><br><span class="line">arr1; <span class="comment">// []</span></span><br><span class="line">arr2; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h3 id="第四種-趕盡殺絕的清"><a href="#第四種-趕盡殺絕的清" class="headerlink" title="第四種 趕盡殺絕的清"></a>第四種 趕盡殺絕的清</h3><p>利用<code>while</code> 迴圈與陣列長度，使用<code>pop()</code>從尾端刪除陣列元素的功能遍歷陣列，一一從尾端清除陣列元素，<code>pop()</code>同樣是就地改變的方法，所以也會同時改動到被複製出來的陣列。我們在前幾章有講到<a href="https://ithelp.ithome.com.tw/articles/10218138" target="_blank" rel="noopener">控制陣列長度的特有屬性：Length</a>，有興趣的可以參考一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1;</span><br><span class="line">arr1; <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="keyword">while</span> (arr1.length) &#123;</span><br><span class="line">  arr1.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr1; <span class="comment">// []</span></span><br><span class="line">arr2; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>以上三種方法，都是在複製陣列時，以參考同一個記憶體位置<code>by Reference</code>的方式進行複製，所以使用<code>arr1.length = 0</code>的方式清空陣列，則所複製出來的陣列<code>arr2 = arr1</code> 的<code>arr2</code>會受原來的<code>arr1</code>影響，同時被清空，所以將<code>arr1.length = 0</code>也等於將<code>arr2</code>清空。</p><h2 id="Delete-的另一種用法：將陣列某一元素清除"><a href="#Delete-的另一種用法：將陣列某一元素清除" class="headerlink" title="Delete 的另一種用法：將陣列某一元素清除"></a>Delete 的另一種用法：將陣列某一元素清除</h2><h3 id="Delete-的假清除-洞還在"><a href="#Delete-的假清除-洞還在" class="headerlink" title="Delete 的假清除 洞還在"></a>Delete 的假清除 洞還在</h3><p>在文章最初，我們介紹了用<code>delete</code>運算子來刪除整個陣列，但其實它比較常被拿來清除陣列的某一元素。直接清除陣列元素的方法<code>delete</code>，個人覺得這也不算真的清除，只是把這個元素回歸為空的狀態，也就是 empty(undefined)。我們可以以<code>length</code>來驗證陣列元素並不會因為使用<code>delete</code>而改變長度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1.length; <span class="comment">// 5 -&gt; arr1 陣列的長度</span></span><br><span class="line"><span class="keyword">delete</span> arr1[<span class="number">1</span>]; <span class="comment">// true -&gt; 刪除索引值為1的元素</span></span><br><span class="line">arr1; <span class="comment">// [1, empty, 3, 4, 5] -&gt; 被刪除的元素變成 empty 空的了。</span></span><br><span class="line">arr1.length; <span class="comment">// 5 -&gt; arr1 陣列的長度仍是5</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> arr1; <span class="comment">// false -&gt; 確認索引值 1 在 arr1 陣列裡有沒有值</span></span><br><span class="line">arr1[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">// 將 2 指定給剛剛刪除的索引值 1</span></span><br></pre></td></tr></table></figure><p>刪除陣列的元素，類似將<code>undefined</code>指定給該元素，但仍和<code>empty</code>會有些微差距嘛？這點還需要驗證。要特別注意的是，用<code>delete</code>刪元素並不會改變陣列的長度，且此陣列就成為一個「稀疏」的陣列。</p><p>使用「稀疏」陣列會造成什麼影響？有時候我們希望用一些方法來處理陣列，然後把處理完的結果回傳回來，如果陣列裡有稀疏的狀態，那麼當我麼用方法去遍歷陣列元素時，就會回傳 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">delete</span> arr1[<span class="number">1</span>]; <span class="comment">// 刪除某一元素陣列後的陣列 -&gt; [1, empty, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr1.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// 用 map() 遍歷每個元素將其 * 2</span></span><br><span class="line">arr2; <span class="comment">// 回傳結果 -&gt; [2, empty, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><h3 id="把無所事事的傢伙通通踢出去"><a href="#把無所事事的傢伙通通踢出去" class="headerlink" title="把無所事事的傢伙通通踢出去"></a>把無所事事的傢伙通通踢出去</h3><p>有時候我們會拿到有許多無效 <del>被搞爛</del>的元素在陣列裡，如何刪除陣列裡這些無所事事的<code>undefined</code>、<code>null</code>、<code>0</code>或其他的元素？讓處理陣列資料時更順利？我們可以利用 JavaScript 的<code>while</code>迴圈，來遍歷陣列內容，一一來把我們過濾過後，要保留的元素留在陣列中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter_array</span>(<span class="params">testArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">-1</span>,</span><br><span class="line">    arrLength = testArray ? testArray.length : <span class="number">0</span>,</span><br><span class="line">    resIndex = <span class="number">-1</span>,</span><br><span class="line">    result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (++index &lt; arrLength) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = testArray[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      value !== <span class="string">''</span> &amp;&amp;</span><br><span class="line">      value !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">      !<span class="built_in">isNaN</span>(value) &amp;&amp;</span><br><span class="line">      value !== <span class="literal">false</span> &amp;&amp;</span><br><span class="line">      value !== <span class="number">0</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      result[++resIndex] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">filter_array([<span class="literal">NaN</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="number">-22</span>, <span class="string">''</span>, <span class="literal">undefined</span>, <span class="number">47</span>, <span class="literal">null</span>]); <span class="comment">// [15, -22, 47]</span></span><br></pre></td></tr></table></figure><p>相信大家在看完這一篇之後，會對於刪除陣列或元素有更加深的認識。老實說，真心覺得鐵人賽最大的收穫，是在寫文章的時候，找到的資料有吸收，且發現原來這麼多方法與面向，真的是一件很有趣的事啊！ 且前幾天收到一些大大的回饋，無論是指定或提問，都讓本人雀躍不已，在每一次的交流中，更可以加深自己對 JavaScript 的理解，實在感謝！</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何轉型別為陣列</title>
      <link href="/tsuifei.github.io/JS_ironMan09_How-to-convert-to-Array-in-JavaScript/"/>
      <url>/tsuifei.github.io/JS_ironMan09_How-to-convert-to-Array-in-JavaScript/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-09"><a href="#Day-09" class="headerlink" title="Day 09"></a>Day 09</h6><blockquote><p>轉大人和轉職ㄧ樣不簡單</p></blockquote><p>這樣一句話「JavaScript 是弱型別語言」 好像出現好幾次了，但它常出現也不是沒有原因，因為我們常常會忘記 JavaScript 會幫我們默默地 <del>偷偷的</del> 把資料轉型別這件事，且轉成它認為是合理的型別，但對我們而言卻是雷… <del>默默哭泣…</del>。</p><p>在聊如何轉型別或轉成陣列時，先讓我們來聊聊 JavaScript 的型別轉換這件事吧。</p><a id="more"></a><p>就像犀牛大全裡面說的，JavaScript 對值的型別要求很有彈性 <del>是沒原則吧…</del>。例如布林值的<code>true</code>和 <code>false</code>偶爾會變成 1 與 0，對其他的型別也是如此，如果 JavaScript 想要字串，它會把我們給它的任何值都轉成字串; 如果它<del>不是我們</del>想要數字，會把我們給它的任何型別的值轉成數字 <del>好隨心所欲與任性</del>，偶而轉大人轉不過去，它就直接吐 <code>NaN</code> Not a number 給我們。</p><p>我們來看幾個例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test1 = <span class="string">'hello '</span> + <span class="number">42</span>;</span><br><span class="line">test1; <span class="comment">// "hello 42" -&gt; 自動把 42 轉成字串，不然叫它怎麼辦</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test2 = <span class="string">'42'</span> + <span class="string">'24'</span>;</span><br><span class="line">test2; <span class="comment">// "4224"</span></span><br></pre></td></tr></table></figure><p>我們稱這種換換型別的方式為隱性轉型，也就是 JavaScript 自動幫我們轉型這件事。詳細的轉型資料實在太多，在「犀牛大全」裡就有 6,1/2 頁，有興趣可以參考這本犀牛，再加上「你說不知道的 JS」，一邊看一邊實作會更有感覺。其中有許多奇怪的部分，以下，只是舉出其中一個例子而已。 <del>到底有多少規則啊！</del></p><h3 id="數字和運算子的隱性轉型-implicit"><a href="#數字和運算子的隱性轉型-implicit" class="headerlink" title="數字和運算子的隱性轉型 implicit"></a>數字和運算子的隱性轉型 implicit</h3><p>在 JavaScript 有個頗怪異的現象，就是如果是「相加」，只要兩個相加數其中一個為「字串數字」如 <code>&quot;42&quot;</code>，它就會把另一個數字也轉成字串處理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'42'</span> + <span class="number">24</span>; <span class="comment">// "4224"</span></span><br><span class="line"><span class="number">42</span> + <span class="string">'24'</span>; <span class="comment">// "4224"</span></span><br><span class="line"><span class="number">42</span> + <span class="number">24</span>; <span class="comment">// "4224"</span></span><br></pre></td></tr></table></figure><p>而這種現象只會出現在「加法」，而在減、乘、除、求餘時，卻會自動把「字串數字」轉成「數字」，而順利進行運算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'42'</span> - <span class="number">24</span>; <span class="comment">// 18</span></span><br><span class="line"><span class="number">42</span> - <span class="string">'24'</span>; <span class="comment">// 18</span></span><br><span class="line"><span class="number">42</span> - <span class="number">24</span>; <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>一些隱性轉型成數字的規則：</p><ul><li>如果是可以解析(parse)的字串數字，就會轉成數字</li><li>任何不是數字字面值的字串會被轉成<code>NaN</code></li><li><code>true</code> 會被轉成<code>1</code>，而 <code>false</code> 和空字串<code>&quot;&quot;</code>都會被轉成<code>0</code></li></ul><h2 id="顯性轉型-Explicit"><a href="#顯性轉型-Explicit" class="headerlink" title="顯性轉型 Explicit"></a>顯性轉型 Explicit</h2><p>顯性轉換型別最簡單的方式是使用<code>Boolean()</code>, <code>Number()</code>, <code>String()</code>或者是<code>Object()</code>這些內建函式。以下是一些範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>([]); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>); <span class="comment">// "true"</span></span><br><span class="line"><span class="literal">true</span>.toString(); <span class="comment">// "true" 與 String(true); 同效果</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'42'</span>); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="number">42</span>); <span class="comment">// Number &#123;42&#125;</span></span><br></pre></td></tr></table></figure><ul><li>除了<code>null</code>和<code>undefined</code>之外，任何值可使用<code>toString()</code>方法，結果和使用<code>String()</code>相同。</li><li>將<code>null</code>和<code>undefined</code>轉為物件，會產生 <code>TypeError</code>。</li></ul><h2 id="針對陣列的相互轉型別"><a href="#針對陣列的相互轉型別" class="headerlink" title="針對陣列的相互轉型別"></a>針對陣列的相互轉型別</h2><h3 id="把陣列轉成字串"><a href="#把陣列轉成字串" class="headerlink" title="把陣列轉成字串"></a>把陣列轉成字串</h3><p>我們常常需要把我們的陣列轉成字串，去做其他的處理，最簡單的方式就是使用內建的<code>toString()</code>函式。我們也可以使用<code>String()</code>，但記得要用一個變數去接它，就可達到一樣的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.toString();</span><br><span class="line">arr; <span class="comment">// "1,2,3,4,5"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">String</span>(arr);</span><br><span class="line">arr2; <span class="comment">// "1,2,3,4,5"</span></span><br></pre></td></tr></table></figure><h3 id="把陣列裡面的值個別轉成數字"><a href="#把陣列裡面的值個別轉成數字" class="headerlink" title="把陣列裡面的值個別轉成數字"></a>把陣列裡面的值個別轉成數字</h3><p>我們可以使用<code>map()</code> 去遍歷陣列裡的元素，並調用<code>parseInt()</code>這個可以將其他型別轉成數字的函數，將每個元素轉成數字，要注意<code>parseInt()</code>裡的第二個參數是進位，我們使用十進位去處理，如果沒給第二個參數，它就 <del>會亂給你看</del> 會有不預期的結果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(x, <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">result; <span class="comment">// (3) [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>另一種寫法好神奇</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'10'</span>, <span class="string">'20'</span>, <span class="string">'30'</span>, <span class="string">'40'</span>, <span class="string">'50'</span>];</span><br><span class="line"></span><br><span class="line">arr2.map(<span class="built_in">Number</span>);</span><br><span class="line"><span class="comment">// [10, 20, 30, 40, 50]</span></span><br></pre></td></tr></table></figure><p>如果有字面值無法轉成數字，當然就轉成代表不是數字的<code>NaN</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = [<span class="string">'10'</span>, <span class="string">'20'</span>, <span class="string">'wow'</span>, <span class="string">'40'</span>, <span class="string">'Hi'</span>];</span><br><span class="line">arr3.map(<span class="built_in">Number</span>);</span><br><span class="line"><span class="comment">// (5) [10, 20, NaN, 40, NaN]</span></span><br></pre></td></tr></table></figure><h3 id="類陣列-Array-like-轉為陣列"><a href="#類陣列-Array-like-轉為陣列" class="headerlink" title="類陣列(Array-like)轉為陣列"></a>類陣列(Array-like)轉為陣列</h3><p>在前幾天的<a href="https://ithelp.ithome.com.tw/articles/10218175" target="_blank" rel="noopener">「陣列有哪幾種？」</a>的篇章中，我們有介紹到陣列中的類陣列，而如何把類陣列物件中的值取出，並轉換成單純的陣列？<br>使用<code>Object.values()</code>可得到一組只有值得陣列，也剛好可以把類陣列的值(value)取出，這個方法也同時適用在一般的物件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj);</span><br><span class="line"><span class="comment">// Object.values(obj).map(ele =&gt; ele); 另一種寫法</span></span><br><span class="line"><span class="comment">// (4) ["a", "b", "c", 3]</span></span><br></pre></td></tr></table></figure><h3 id="二維陣列轉換成一維陣列"><a href="#二維陣列轉換成一維陣列" class="headerlink" title="二維陣列轉換成一維陣列"></a>二維陣列轉換成一維陣列</h3><p>一般我們很少會自己創建多維陣列，所謂一維或二維陣列，就是在一個陣列裡，只有一組中括號，如果這組中括號裡有兩個或兩個以上的陣列(中括號)，就稱為多維陣列，當我們拿到這樣的陣列，又必須用方法去處理他，這時就可以用以下的方法，達到「壓平」陣列的效果。<br>現確認這個陣列的長度是否是零，如果是就不用處理它了，直接回傳零，這只是一個過濾機制。接下來，先將陣列以<code>toString()</code>轉成字串，在用<code>split()</code>以逗號分格每個元素，最後再以<code>Number</code>確保元素為數字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.toString().split(<span class="string">','</span>).map(<span class="built_in">Number</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>], <span class="number">6</span>], <span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>]));</span><br><span class="line"><span class="comment">// (6) [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><p>感謝 <a href="https://ithelp.ithome.com.tw/users/20091346/ironman/1150" target="_blank" rel="noopener">Huli</a> 提醒，在這個範例裡所使用的<code>flatten()</code>，只會對陣列元素是數字的多維陣列起作用，其他數字以外的型別就沒辦法使用<code>flatten()</code>了。</p><p>另外有幾種可以把多維陣列壓平的方法，原來<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" target="_blank" rel="noopener">MDN 上面都有範例</a>，甚至是用遞迴的方式解決，有興趣的可以參考一下，這個「[遞迴（recurse）只應天上有, 凡人該當用迴圈（iterate）]的寫法。 <del>本人絕對是凡人</del></p><p>大家有沒有發現，我們已經開始使用幾個 JavaScript 的方法在處理這些不是陣列的資料？接下來我們也會一一介紹這些內建的陣列方法喔～</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判別是否為陣列 Array</title>
      <link href="/tsuifei.github.io/JS_ironMan08_How-to-determine-if-it-is-an-array/"/>
      <url>/tsuifei.github.io/JS_ironMan08_How-to-determine-if-it-is-an-array/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-08"><a href="#Day-08" class="headerlink" title="Day 08"></a>Day 08</h6><blockquote><p>如果你不是台灣的國民，就不能在台灣投票</p></blockquote><p>Javascript 是弱型別語言，也因為這個特性，在處理資料時 JavaScript 很可能的很好心，一不小心就把資料自動轉型成另一個資料型態了，所以為了避免在使用陣列內建方法或處理陣列時出現錯誤，常常會使用許多方法來判別是否為陣列。如果元素不是陣列，就無法使用陣列專用的函式或做些陣列的處理，因此才會有確認某元素的原型是陣列的需要。</p><p>陣列 Array 在 JavaScript 裡的型別是<code>object</code>，這點可以透過 typeof 這個運算符回傳的資訊，來確認某一資料是否為陣列。但是，在物件裡的某一元素是否為陣列，又該怎麼判別？ 以下有幾種方法：</p><a id="more"></a><h2 id="判別變數是否為陣列"><a href="#判別變數是否為陣列" class="headerlink" title="判別變數是否為陣列"></a>判別變數是否為陣列</h2><p>這邊有四個同是陣列，但不同形態內容的元素，還有一個非陣列的物件變數，我們可以拿它們來測試。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 陣列常値 // 數字陣列</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非同型陣列</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'one'</span>, <span class="number">2</span>, <span class="string">'three'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 陣列裡有陣列</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="string">'one'</span>, <span class="number">2</span>, <span class="string">'three'</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非同型陣列</span></span><br><span class="line"><span class="keyword">const</span> arr4 = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'Tsuifei'</span>, <span class="attr">type</span>: <span class="string">'object'</span>, <span class="attr">luckyNumber</span>: [<span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">42</span>] &#125;,</span><br><span class="line">  [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'Philippe'</span>, <span class="attr">type</span>: <span class="string">'object'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'Ayda'</span>, <span class="attr">type</span>: <span class="string">'object'</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">too</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'array can contain function too'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'three'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 物件</span></span><br><span class="line"><span class="keyword">const</span> me = &#123; <span class="attr">name</span>: <span class="string">'Tsuifei'</span>, <span class="attr">type</span>: <span class="string">'object'</span>, <span class="attr">luckyNumber</span>: [<span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">42</span>] &#125;;</span><br></pre></td></tr></table></figure><h3 id="isArray-小而美"><a href="#isArray-小而美" class="headerlink" title="isArray 小而美"></a>isArray 小而美</h3><p>最簡單的陣列判斷語法 isArray，用的是內建 Array 物件中的 isArray，是個 ES5 的標準方法:<br><code>Array.isArray(variable)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(arr1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr2); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr3); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr4); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(me); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="constructor-Array-輕而巧"><a href="#constructor-Array-輕而巧" class="headerlink" title="constructor === Array 輕而巧"></a>constructor === Array 輕而巧</h3><p>使用<code>constructor</code>，這個是在 Chrome 瀏覽器中效能最佳的判斷方法，它是直接用物件的建構式來判斷:<br><code>variable.constructor === Array</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr1.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">arr2.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">arr3.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">arr4.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">me.constructor === <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="判別物件中的陣列"><a href="#判別物件中的陣列" class="headerlink" title="判別物件中的陣列"></a>判別物件中的陣列</h2><h3 id="constructor-Array"><a href="#constructor-Array" class="headerlink" title="constructor === Array"></a>constructor === Array</h3><p>與上方一個相同，只是針對物件中的陣列來使用，如果要判別物件中的其中屬性是否為陣列，可以先判斷這個屬性是否存在，再繼續判斷這個值是否為陣列，我們以物件型態的變數來測驗，如下:<br><code>variable.value &amp;&amp; variable.value.constructor === Array</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> me = &#123;</span><br><span class="line">  name: <span class="string">'Tsuifei'</span>,</span><br><span class="line">  type: <span class="string">'object'</span>,</span><br><span class="line">  luckyNumber: [<span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">42</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">me.name &amp;&amp; me.name.constructor === <span class="built_in">Array</span>; <span class="comment">// false</span></span><br><span class="line">me.type &amp;&amp; me.type.constructor === <span class="built_in">Array</span>; <span class="comment">// false</span></span><br><span class="line">me.luckyNumber &amp;&amp; me.luckyNumber.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="instanceof-物件的實例"><a href="#instanceof-物件的實例" class="headerlink" title="instanceof 物件的實例"></a>instanceof 物件的實例</h3><p>先來看看 MDN 怎麼解釋：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="noopener">MDN instanceof</a><br><code>instanceof</code> 運算符用於測試建構式函式的 prototype 屬性，是否出現在物件的原型鏈中的任何位置，也就是說<code>instanceof</code> 運算符是用於判斷是否為某個建構式<code>new</code>的實例，優點為語法簡潔清楚。</p><p>但是缺點還是有的，雖然只要是在原型鏈上面的類別，都會回傳<code>true</code>，但是建構是有可能因為某些原因而被修改，改變之後的值很有可能不存在於原型鏈上，這時判別回傳得到的值就會成為<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnuc</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> testF = <span class="keyword">new</span> fnuc();</span><br><span class="line">testF <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line"><span class="comment">// false testF 不是一個陣列,它是一個建構式宣告出來的實例(物件)</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code>不只可以判別陣列，也可以拿來判別其他的型別，如<code>string</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr5 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr5 <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrObj = <span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">arrObj <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也適用於其他型別的判別</span></span><br><span class="line"><span class="keyword">var</span> arrObj = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello world'</span>);</span><br><span class="line">arrObj <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code>有個缺點，就是處理的<code>window</code>或<code>iframe</code>時的變數會失效，詳細的解說在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof#instanceof%E5%92%8C%E5%A4%9A%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%A4%9A%E4%B8%AAframe%E6%88%96%E5%A4%9A%E4%B8%AAwindow%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92" target="_blank" rel="noopener">MDN</a>有較詳細的說明。</p><h3 id="toString-call"><a href="#toString-call" class="headerlink" title="toString.call"></a>toString.call</h3><p>==推薦使用==<br>網路上推薦這種方式判別的頗多，原因應該是這種方式是所有情況都可以正確判別的一種，且可適用各種狀況，也可以判斷陣列以外的其他特別物件，唯一缺點是效率最差。<br>在 JavaScript: The Definitive Guide, 6th Edition 書中有提到，Array.isArray 其實就是用這個方式實作的。<br><code>Object.prototype.toString.call(variable) === &#39;[object Array]&#39;</code></p><p>網路上也有人寫成一支判斷陣列終極解決方案，先用<code>typeof</code>判別，再確認瀏覽器支不支援這個判別方法，如果不支援，就用另一種方式判別。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr6 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr7 = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayFn</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 包成函式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.isArray === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(obj); <span class="comment">// 如果瀏覽器支援就用 isArray() 方法</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否則就使用 toString 方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">isArrayFn(arr6); <span class="comment">// true</span></span><br><span class="line">isArrayFn(arr7); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="用哪一種？"><a href="#用哪一種？" class="headerlink" title="用哪一種？"></a>用哪一種？</h3><p>這幾個方式的選擇，網路上的前輩建議是==只要學最後一種==就行了(就是最後一種)，可以正確判斷並應用在各種情況為首要條件，有時候正確性比效能快更為重要，更何況它其實是萬用的，除了陣列之外也可以用於其它的判斷情況。雖然它的語法對初學者來說，可能無法在此時完全理解 <del>在說我嗎？</del>，不過就先知道要這樣用就行了。</p><hr><p>寫完才發現<a href="https://segmentfault.com/a/1190000006150186" target="_blank" rel="noopener">這篇更詳細的介紹</a>，有興趣的可以轉台過去看，真的很詳細，推～</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何讀取和寫入陣列 Array 元素</title>
      <link href="/tsuifei.github.io/JS_ironMan07_How-to-read-and-write-array-elements/"/>
      <url>/tsuifei.github.io/JS_ironMan07_How-to-read-and-write-array-elements/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-07"><a href="#Day-07" class="headerlink" title="Day 07"></a>Day 07</h6><blockquote><p>只要有資料，都會有 CRUD ，那陣列呢？</p></blockquote><p>CRUD 是什麼？ <del>能吃嗎？？</del> CRUD 分別代表：建立 Create, 讀取 Read, 更新 Update 和刪除 delete 。 如果資料只能讀不能取，那會很悲慘，就像逛到一間好吃的甜點店，裡面擺滿了好吃的法式甜點，我們無法吃到，也無法買到，那不是很失落？ <del>其實掏錢就可以了。</del></p><h2 id="這一排的第-個位子坐著誰？"><a href="#這一排的第-個位子坐著誰？" class="headerlink" title="這一排的第[ ]個位子坐著誰？"></a>這一排的第[ ]個位子坐著誰？</h2><p>要讀取或寫入陣列這件事情，並不是那麼困難，因為陣列是物件的另一種特殊形式，只要使用方括號 [ ]，即可指定某個元素，如果陣列裡有物件型態的元素也一樣用這種方式取得。記得方括號是元素的位置，也就是這個元素的所在索引值(index)。</p><a id="more"></a><p>如果想讀取的元素不存在，例如陣列只有 5 個元素，我們卻想要讀取第 7 個，Javascrupt 並不會因此報錯，而直接回應 <code>undefined</code>給我們。我們來看看如何取值吧！</p><h4 id="arrayName-index-陣列名-索引值"><a href="#arrayName-index-陣列名-索引值" class="headerlink" title="arrayName[index] / 陣列名[索引值]"></a>arrayName[index] / 陣列名[索引值]</h4><p>以下有許多不同型態的陣列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 陣列常値 // 數字陣列</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非同型陣列</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'one'</span>, <span class="number">2</span>, <span class="string">'three'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 陣列裡有陣列</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="string">'one'</span>, <span class="number">2</span>, <span class="string">'three'</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非同型陣列</span></span><br><span class="line"><span class="keyword">const</span> arr4 = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'Tsuifei'</span>, <span class="attr">type</span>: <span class="string">'object'</span>, <span class="attr">luckyNumber</span>: [<span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">42</span>] &#125;,</span><br><span class="line">  [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'Philippe'</span>, <span class="attr">type</span>: <span class="string">'object'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'Ayda'</span>, <span class="attr">type</span>: <span class="string">'object'</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">too</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'array can contain function too'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'three'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>如果想要取出某個陣列，只要照<code>arrayName[index]</code>這個規則取就可以了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr1[<span class="number">1</span>]; <span class="comment">// 2</span></span><br><span class="line">arr2[<span class="number">0</span>]; <span class="comment">// "one"</span></span><br><span class="line">arr3[<span class="number">1</span>]; <span class="comment">//(3) ["one", 2, "three"]</span></span><br><span class="line">arr4[<span class="number">3</span>]; <span class="comment">// ƒ too() &#123; return "array can contain function too" &#125;</span></span><br><span class="line">arr3[<span class="number">2</span>]; <span class="comment">// undefined, arr3 並沒有這個元素</span></span><br></pre></td></tr></table></figure><h3 id="取陣列的最後一個元素"><a href="#取陣列的最後一個元素" class="headerlink" title="取陣列的最後一個元素"></a>取陣列的最後一個元素</h3><p>也可以利用陣列長度屬性 <code>length-1</code> 的特性，輕鬆取到最後一個元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr4[arr4.length - <span class="number">1</span>]; <span class="comment">// "three"</span></span><br><span class="line">arr3[arr3.length - <span class="number">1</span>]; <span class="comment">// (3) ["one", 2, "three"]</span></span><br></pre></td></tr></table></figure><h3 id="取陣列中的陣列-一層層找"><a href="#取陣列中的陣列-一層層找" class="headerlink" title="取陣列中的陣列 一層層找"></a>取陣列中的陣列 一層層找</h3><p>如果遇到陣列中還有陣列，可以利用多層的中括號<code>[ ][ ]</code>取到值。但只限於陣列裡的陣列，如果是非同型資料的陣列資料，就無法用這個方式取了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr3[<span class="number">1</span>][<span class="number">2</span>]; <span class="comment">// "three"</span></span><br></pre></td></tr></table></figure><h3 id="座位沒人-undefined"><a href="#座位沒人-undefined" class="headerlink" title="座位沒人 undefined"></a>座位沒人 undefined</h3><p>如果陣列是稀疏陣列，那麼當然是找不到，而會丟個<code>undefined</code>回來。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr5 = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, , , <span class="number">5</span>],</span><br><span class="line">  [<span class="string">'a'</span>, , <span class="string">'c'</span>]</span><br><span class="line">];</span><br><span class="line">arr5[<span class="number">1</span>][<span class="number">1</span>]; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="取物件型態資料的方法"><a href="#取物件型態資料的方法" class="headerlink" title="取物件型態資料的方法"></a>取物件型態資料的方法</h3><p>如果是陣列裡面有物件型態的資料，就無法用陣列的方括號<code>[]</code>來取，而要用點 <code>.</code>加上<code>key</code>來取值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr4[<span class="number">0</span>].luckyNumber; <span class="comment">// (4) [5, 7, 13, 42]</span></span><br></pre></td></tr></table></figure><h3 id="ES6-的好物"><a href="#ES6-的好物" class="headerlink" title="ES6 的好物"></a>ES6 的好物</h3><p>在 ES6 新增加的功能中，有一個很好用的方法叫解構賦值，它可以把陣列或物件中的資料取出成一個獨立變數，也算是讀取的一種方法，但有礙篇幅，有機會我們再來討論吧。</p><h2 id="寫入即是更新-update"><a href="#寫入即是更新-update" class="headerlink" title="寫入即是更新 update"></a>寫入即是更新 update</h2><p>當我們是某一個網站的會員，我們都可以找到可以修改我們個人資料的頁面，我們把新的資料更新，其實也是在「覆蓋」我們之前填的資料。</p><p>陣列讀入資料的方式基本上和取出的方式ㄧ樣，都是依照陣列的位置來進行覆蓋，以單個元素或整個陣列為單位的方式都可行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr5 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">arr5[<span class="number">2</span>] = <span class="number">42</span>; <span class="comment">// [1, 2, 42, 4, 5]</span></span><br><span class="line"></span><br><span class="line">arr5[<span class="number">5</span>] = &#123; <span class="attr">say</span>: <span class="string">'hi'</span>, <span class="attr">name</span>: <span class="string">'Tsuifei'</span>, <span class="attr">city</span>: <span class="string">'Tainan'</span> &#125;;</span><br><span class="line"><span class="comment">// [1, 2, 42, 4, 5, &#123;say: "hi", name:"Tsuifei", city:"Tainan"&#125;]</span></span><br><span class="line"></span><br><span class="line">arr5[<span class="number">5</span>].say = <span class="string">'Hello'</span>;</span><br><span class="line">arr5[<span class="number">5</span>]; <span class="comment">// &#123;say: "hi", name:"Tsuifei", city:"Tainan"&#125;</span></span><br></pre></td></tr></table></figure><h3 id="不小心成為稀疏陣列"><a href="#不小心成為稀疏陣列" class="headerlink" title="不小心成為稀疏陣列"></a>不小心成為稀疏陣列</h3><p>如果陣列長度是 5 ，但我們指定讀入的位置比陣列長度大，那麼就會造成陣列成為稀疏陣列，JavaScript 也會以<code>undefined</code>來填補這些空隙，並將長度延展至指定讀入的長度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr6 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr6[<span class="number">8</span>] = <span class="number">42</span>; <span class="comment">// (9) [1, 2, 3, 4, 5, empty × 3, 42]</span></span><br></pre></td></tr></table></figure><p>今天就介紹到這裡，相信今天的小菜口味不是很重，且很好消化，如果熟悉這些讀取規則，相信在將來學到物件<code>Object</code>或<code>JSON</code>格式的資料，應該會更好瞭解才是。</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列 Array 有哪幾種型態 ?</title>
      <link href="/tsuifei.github.io/JS_ironMan06_What-are-the-types-of-Array/"/>
      <url>/tsuifei.github.io/JS_ironMan06_What-are-the-types-of-Array/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-06"><a href="#Day-06" class="headerlink" title="Day 06"></a>Day 06</h6><blockquote><p>JavaScript 一定是個女人，有個性、特立獨行、難以理解，還可以ㄧ次做很多事。</p></blockquote><p>有時候思索著，在學習程式的時候，到底是不是應該把我們所知道的知識，更有系統的整理出來？但是當我們在整理我們所學的知識時，要如何知道我們所整理的資料正確性？ <del>有時有理解障礙</del> 尤其程式這東西，在學習時常感到很抽象，很多時候讀了幾遍書上寫的，照著範例實做了，卻還是無法理解真正的含義，這或許和學外語很相似，學習一個新的外國語言，會聽、會寫、會講都會有好幾個階段，也需要時間去消化與沈澱，持續的學習與練習是必要的，直到有一天，當我們突然發現自己聽得懂外國人在說什麼，那種喜悅應該是很難形容的吧？</p><p>小小感想，只因今天是週六？鐵人賽已經來到了第六天，我的陣列小菜今天比較清淡喔～來聊聊陣列有幾種。</p><a id="more"></a><p>要分哪幾種？一定要分嗎？好吧。第一種：空陣列 <code>arr = []</code> <del>不要打我</del> ，如果這個也要算，那是不是只有數字為元素的也要算一種？不同型別的也要算一種？不行，這樣也太膚淺了，感覺很沒誠意。</p><p>如果真要分，本人認為 <del>本人而已喔</del> 應該只能算三種：</p><ul><li>密集陣列 (dense)</li><li>稀疏陣列 (sparse)</li><li>類陣列 (array-like)</li></ul><h3 id="密集陣列-dense-坐滿做好"><a href="#密集陣列-dense-坐滿做好" class="headerlink" title="密集陣列 (dense) 坐滿做好"></a>密集陣列 (dense) 坐滿做好</h3><p>陣列裡的元素沒有空值，也沒有 <code>undefined</code>，一般在宣告或創建陣列時沒有空隙。像這樣：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190921/20104175Rio5A1NMVE.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190921/20104175Rio5A1NMVE.jpg"></p><h3 id="稀疏陣列-sparse-稀稀落落"><a href="#稀疏陣列-sparse-稀稀落落" class="headerlink" title="稀疏陣列 (sparse) 稀稀落落"></a>稀疏陣列 (sparse) 稀稀落落</h3><p>一般的陣列裡的元素是連續的索引值，元素之間有缺口(gaps)，是稀疏陣列。<br>我們可以從.length 得知陣列的長度。但是如果是稀疏陣列，length 屬性的值也會大於陣列內元素的數目。<br>如果在指定或創建陣列時，省略某個值不寫、逗號間沒有值，產生的陣列就會是稀疏陣列，值被省略的陣列元素並不存在，這些缺口會顯示 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrSparse = [<span class="string">'a'</span>, <span class="string">'b'</span>, , <span class="string">'e'</span>, , <span class="string">'g'</span>]; <span class="comment">// 元素之間有缺口</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [,]; <span class="comment">// [empty]  a1 沒有元素，a1.length 卻是1</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="literal">undefined</span>]; <span class="comment">// a2 陣列有一個元素為 undefined ，a2.length 也是1</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> arr1; <span class="comment">// -&gt; false a1 沒有索引值0 所以回傳 false</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> arr2; <span class="comment">// -&gt; true  a2 在索引值0的位置有undefined 所以回傳 true</span></span><br></pre></td></tr></table></figure><p>理解稀疏陣列是理解 Javascript 陣列真實本質的重要步驟，雖然實務上會遇到稀疏陣列的機會很少，但是如果真的遇到了，也會把它們視為有<code>undefined</code>元素的非稀疏陣列來操作。</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20190921/20104175Tr0q5xcqR0.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190921/20104175Tr0q5xcqR0.jpg"></p><h3 id="類陣列-array-like-半牛半馬"><a href="#類陣列-array-like-半牛半馬" class="headerlink" title="類陣列 (array-like) 半牛半馬"></a>類陣列 (array-like) 半牛半馬</h3><p>當初在「大全」裡看到這句時，實在摸不著頭緒，「不是所有的陣列都可以用陣列的方法」 <del>是歧視嗎？</del> 大全上這樣寫著。更貼切的來說，是類陣列不能直接使用 JavaScript 內建 Array 的方法，在大全裡介紹類陣列的標題寫著「類陣列物件」，又是陣列又是物件的，實在是很讓人混淆，到底是陣列還是物件？JavaScript 也有這麼曖昧的東西啊？</p><p>以 <code>typeof</code> 來查看陣列，會得到物件 <code>object</code>，但到底陣列和其他物件有什麼不同？最大的不同是陣列有：</p><ul><li><code>length</code>這個特殊屬性</li><li>從<code>Array.prototype</code>繼承過來的許多實用的方法</li><li>陣列的<code>class</code>屬性值為<code>Array</code>這幾點吧。</li></ul><p>但是所謂的「類陣列」(Array-like) 也是如此嗎？並不是喔。</p><p>先來看看類陣列長什麼樣子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">  push: <span class="built_in">Array</span>.prototype.push,</span><br><span class="line">  splice: <span class="built_in">Array</span>.prototype.splice</span><br><span class="line">&#125;;</span><br><span class="line">obj.push(<span class="string">'d'</span>);</span><br><span class="line">obj; <span class="comment">// &#123;0: "a", 1: "b", 2: "c", 3: "d", length: 4, push: ƒ&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://ithelp.ithome.com.tw/upload/images/20190921/201041752EQ2YNsI0a.png" alt="https://ithelp.ithome.com.tw/upload/images/20190921/201041752EQ2YNsI0a.png"></p><p>講直白一點，類陣列是物件，可以當成陣列來用 <del>或是是陣列，可以當成物件用</del>。<br>我們可以看到<code>obj</code>的元素是用花括號 {}，是物件的做法。但是物件裡又有<code>length: 3</code>這個陣列的屬性。這就對了，任合物件只要具有數值<code>length</code>屬性，且數值不是負整數，就可以說是類陣列(Array-like)。</p><h3 id="函數引數所形成的陣列，取得不定個數的引數"><a href="#函數引數所形成的陣列，取得不定個數的引數" class="headerlink" title="函數引數所形成的陣列，取得不定個數的引數"></a>函數引數所形成的陣列，取得不定個數的引數</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// (1)</span></span><br><span class="line">  <span class="built_in">console</span>.log(arr); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testList = foo(<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>); <span class="comment">// -&gt;類陣列</span></span><br><span class="line"><span class="keyword">let</span> testList1 = foo(<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>); <span class="comment">// -&gt;類陣列</span></span><br></pre></td></tr></table></figure><h3 id="物件裡有-length-屬性"><a href="#物件裡有-length-屬性" class="headerlink" title="物件裡有 length 屬性"></a>物件裡有 length 屬性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objArr1 <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</span><br><span class="line">objArr1.length;</span><br><span class="line"><span class="comment">//objArr1;  -&gt; [empty x 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或是</span></span><br><span class="line"><span class="keyword">let</span> objArr2 = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">5</span> &#125;);</span><br><span class="line"><span class="comment">// objArr2;  -&gt; [undefined, undefined, undefined, undefined, undefined]</span></span><br></pre></td></tr></table></figure><h3 id="如何辨別一個陣列是類陣列"><a href="#如何辨別一個陣列是類陣列" class="headerlink" title="如何辨別一個陣列是類陣列"></a>如何辨別一個陣列是類陣列</h3><p>在大全裡有提供如何測試是否為類陣列的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">testArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    testArr &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> testArr === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">isFinite</span>(testArr.length) &amp;&amp;</span><br><span class="line">    testArr.length &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    testArr.length === <span class="built_in">Math</span>.floor(testArr.length) &amp;&amp;</span><br><span class="line">    testArr.length &lt; <span class="number">4294967296</span></span><br><span class="line">  )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用上述的函式測試前面兩個類陣列，回傳的都是 <code>true</code>，表示都是類陣列物件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(isArrayLike(objArr1)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isArrayLike(objArr2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>有沒有被類陣列弄得頭很痛？如果是類陣列就無法使用大部分的陣列內建方法，是不是很可惜？下次有機會再來介紹把類陣列轉成一般的陣列的方法吧！</p><p>最後附上一張讓人想放空的圖片送給大家，記得週末要放空一下喔！週末愉快～<br><img src="https://ithelp.ithome.com.tw/upload/images/20190921/20104175z4MbV0ywi8.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190921/20104175z4MbV0ywi8.jpg"></p><h6 id="All-圖片來源：https-unsplash-com"><a href="#All-圖片來源：https-unsplash-com" class="headerlink" title="All 圖片來源：https://unsplash.com"></a>All 圖片來源：<a href="https://unsplash.com" target="_blank" rel="noopener">https://unsplash.com</a></h6><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列屬性 length 的真面貌 </title>
      <link href="/tsuifei.github.io/JS_ironMan05_The-array-property-length/"/>
      <url>/tsuifei.github.io/JS_ironMan05_The-array-property-length/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-05"><a href="#Day-05" class="headerlink" title="Day 05"></a>Day 05</h6><blockquote><p>一列隊伍有長度，也有各式各樣不同的物種，這才有趣嘛！</p></blockquote><p>length 這個屬性應該算是我們在學 Javascript 的初期，最早開始用的一個屬性，我們常常來用它來當作是跑字串或陣列的迴圈條件，但是，作為 Array 的唯一屬性 length 真的有這麼單純嗎？</p><p>我們可以從 Chrome 的開發工具的 console 裡，輸入<code>window.Array.prototype</code> 可以找到它。並試著了解他多一點。<br><img src="0_images/day05_array.png" alt></p><p>先看一下 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length" target="_blank" rel="noopener">NDM</a> 對它的定義：<br>作為 Array 類型的實例物件的 length 屬性，設置或回傳該陣列中的元素數。 該值是一個無符號的 32 位整數，其數值總是大於陣列中的最高索引。</p><a id="more"></a><p>嗯，解釋得很清楚，但好像單薄了點。果然，查找了「JavaScript 大全」的解釋，把 length 解釋得較為詳細，且還講到了密集陣列(dense)和稀疏陣列(sparse)，其中更強調了無論是以上哪種型態的陣列，length 的長度不會等於或小於陣列的最大索引值，也就是說 length 會比陣列最大的索引值多 1。但有個例外，就是空陣列。 <del>廢話</del></p><p>這個其實不難理解，在許多程式語言裡，陣列的索引值都是從 0 開始算起，當然 JavaScript 也不例外。JavaScript 的 length 是從 1 開始，從下面這張圖片可以看出為什麼長度總比索引值大的原因。</p><p><img src="0_images/day05.png" alt></p><h2 id="怎麼使用-length"><a href="#怎麼使用-length" class="headerlink" title="怎麼使用 length ?"></a>怎麼使用 length ?</h2><p>別看 length 這個屬性，好像只能知道陣列的長度，但是如果知道怎麼活用它，會發現他的功用還不少。接下來介紹是幾種 length 的用法：</p><h3 id="求陣列的長度"><a href="#求陣列的長度" class="headerlink" title="求陣列的長度"></a>求陣列的長度</h3><ul><li>只要在我們想知道的陣列變數，以方法的方式加上<code>.length</code>。回傳回來的就是這個陣列的長度。</li><li>不管是密集或稀疏陣列，長度(length)永遠大於索引值(index)。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'hi'</span>, <span class="string">'ho'</span>, <span class="string">'woops'</span>, <span class="string">'ciao'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><ul><li>如果重新指定長度，<code>.length</code>，原本有的會被刪除，沒有的會以空的補上而成為稀疏陣列。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr; <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">arr.length = <span class="number">10</span>;</span><br><span class="line">arr; <span class="comment">// [1, 2, 3, empty × 7]</span></span><br><span class="line">arr.length = <span class="number">3</span>;</span><br><span class="line">arr; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="把陣列清空-第一種"><a href="#把陣列清空-第一種" class="headerlink" title="把陣列清空 第一種"></a>把陣列清空 第一種</h3><p>這的確是個快速清空的方法，但是陣列在 JavaScript 裡，骨子裡是物件，也就是在記憶體裡，當我們宣告它時，也同時記錄了它在記憶體的位置（call by reference），而如果我們複製了這個陣列，然後用 length 這個屬性去操控它，嗯，恩湯喔，很危險，同時會指向來源陣列，所以也會修改來源陣列。<br><a href="https://codepen.io/tsuifei/pen/zYOMRKa?editors=0012" target="_blank" rel="noopener">這個 codepen 有更詳細的範例說明</a>，記得只觀察比對 JS 和 console(在左下角)的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> say = [<span class="string">'hi'</span>, <span class="string">'ho'</span>, <span class="string">'woops'</span>, <span class="string">'ciao'</span>];</span><br><span class="line">say.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(say); <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h3 id="把陣列清空-第二種"><a href="#把陣列清空-第二種" class="headerlink" title="把陣列清空 第二種"></a>把陣列清空 第二種</h3><p>和第一種一樣，都會更動到來源陣列，請慎用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> say = [<span class="string">'hi'</span>, <span class="string">'ho'</span>, <span class="string">'woops'</span>, <span class="string">'ciao'</span>];</span><br><span class="line">say.length = [];</span><br><span class="line"><span class="built_in">console</span>.log(say); <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h3 id="把陣列最後一個元素抓出來"><a href="#把陣列最後一個元素抓出來" class="headerlink" title="把陣列最後一個元素抓出來"></a>把陣列最後一個元素抓出來</h3><p>除了可以用 JavaScript 的內建函式 <code>pop();</code>去提取陣列的最後一個元素外，還可以用下面這種方法。找到陣列中最後一個值， 把 length 的長度減掉 1 再把它對應到索引值，就是陣列的最後一個了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> say = [<span class="string">'hi'</span>, <span class="string">'ho'</span>, <span class="string">'woops'</span>, <span class="string">'ciao'</span>];</span><br><span class="line"><span class="keyword">let</span> lastSay = say[say.length - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(lastSay); <span class="comment">// ciao</span></span><br></pre></td></tr></table></figure><h3 id="刪除陣列的最後一個元素"><a href="#刪除陣列的最後一個元素" class="headerlink" title="刪除陣列的最後一個元素"></a>刪除陣列的最後一個元素</h3><p>直接把原本的陣列長度，用指派的方式減掉最後一個陣列元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> say = [<span class="string">'hi'</span>, <span class="string">'ho'</span>, <span class="string">'woops'</span>, <span class="string">'ciao'</span>];</span><br><span class="line">say.length = say.length - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(say); <span class="comment">// ["hi", "ho", "woops"]</span></span><br></pre></td></tr></table></figure><h3 id="從陣列尾部增加一個元素"><a href="#從陣列尾部增加一個元素" class="headerlink" title="從陣列尾部增加一個元素"></a>從陣列尾部增加一個元素</h3><p>如果要在陣列尾部增加一個元素，除了可以用 JavaScript 的內建函式 <code>push();</code>去增加外，還可以用這種方法增加，真的很奇妙！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> say = [<span class="string">'hi'</span>, <span class="string">'ho'</span>, <span class="string">'woops'</span>, <span class="string">'ciao'</span>];</span><br><span class="line">say[say.length] = <span class="string">'haha'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(say); <span class="comment">// ["hi", "ho", "woops", "ciao", "haha"]</span></span><br></pre></td></tr></table></figure><h3 id="當作是迴圈的停止條件"><a href="#當作是迴圈的停止條件" class="headerlink" title="當作是迴圈的停止條件"></a>當作是迴圈的停止條件</h3><p>這是我們常用的方法，把迴圈限制在陣列的長度範圍內，跑完陣列的長度自動停止，真的很方便。以下的範例就是計算陣列裡面元素的總和。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nbr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nbr.length; i++) &#123;</span><br><span class="line">  sum = sum + nbr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="服用-length-注意事項"><a href="#服用-length-注意事項" class="headerlink" title="服用 length 注意事項"></a>服用 length 注意事項</h3><p>雖然 length 可以這樣用，但並不表示就是好的方法，因為 length 是陣列的屬性，陣列在 JavaScript 是屬於非原始型別(Non-Primitive)也就是物件型別(Object type)與傳址(Pass by referance)， <del>別緊張，這幾個名詞都是指同一件事情。</del> 所以不可不慎用，一改動是會同時更動複製的原陣列的。</p><h2 id="小總結"><a href="#小總結" class="headerlink" title="小總結"></a>小總結</h2><p>不知道這篇 length 的介紹，有沒有讓大家對它有另一種看法，程式的變化實在是太精采，但知道活用或許比知道原本的功能更重要吧？</p><p>透過鐵人賽寫文來查找資料，實在是個不錯的方法，人家說「當爸爸之後才學著怎麼當爸爸」，本人雖然無法當爸爸，但對這句話的涵義也頗有感觸，期望在這樣查找與發現的狀態下，多練些腦肌肉也是好的。</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote><hr><p>==要補充==</p><h1 id="陣列裡的-length-屬性"><a href="#陣列裡的-length-屬性" class="headerlink" title="陣列裡的 length 屬性"></a>陣列裡的 length 屬性</h1><p>對稀疏陣列來說，如果.length 屬性比元素的數目還大，length 會比陣列索引還大，也就是說，陣列永遠不會有元素的索引大於或等於陣列的<code>.length</code>長度。為了要為持這個不變式(invariant)，陣列會有兩個特殊行為： 1.如果我們指定一個值給索引 i，而 i 大於或等於陣列目前的 length 長度，那麼 length 的屬性就會被設為 i+1。 2.如果我們將 length 屬性設為小於目前陣列值的非負整數 n，那麼，任何索引值大於或等於 n 的陣列元素都會因此從陣列中被刪除。<br>==記住：<code>.length</code>長度永遠會比<code>index[]</code>大 1，因為<code>index</code>從 0 開始計算。==</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 創建一個有五個元素的陣列</span></span><br><span class="line">a.length = <span class="number">3</span>; <span class="comment">// a 現在變成 [1,2,3]</span></span><br><span class="line">a.length = <span class="number">0</span>; <span class="comment">// 將長度指定成 0 等於刪除所有元素，所以現在陣列變成 []</span></span><br><span class="line">a.length = <span class="number">5</span>; <span class="comment">// 將長度指定成 5，但是沒有元素，所以會如 new Array(5) a 變成 [empty × 5]</span></span><br></pre></td></tr></table></figure><p>我們也可將長度射設成比現在更大的長度，但並不會因此新增任何的陣列元素，而是會在陣列尾部創建一塊稀疏的區域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.length = <span class="number">15</span>; <span class="comment">// a 變成 [empty × 15]</span></span><br></pre></td></tr></table></figure><p>可以把 length 設為唯讀，鎖死陣列長度嗎？可以。在 ECMAScript，我們可以使用 Object.defineProperty()把陣列 length 設為唯讀，這樣不只無法更改長度，也無法增加長度與刪除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">//</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'length'</span>, &#123; <span class="attr">writable</span>: <span class="literal">false</span> &#125;); <span class="comment">// 設為唯讀</span></span><br><span class="line">a.length = <span class="number">0</span>; <span class="comment">// a 不變。 a 仍然是 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>節錄「JavaScript 大全」的說明：</p><ul><li>陣列(Array)是動態的(dynamic)：陣列的長度可以根據需求變長或變短，沒有必要在創建陣列時，宣告陣列的長度，或是在長短改變時重新配置(reallocate)。</li><li>每個陣列都有一個控制或偵測的屬性：length 特性，對非稀疏陣列(nonsparse)來說，length 代表陣列中所包含的元素數量<br>對稀疏陣列(sparse)而言，length 比陣列中所有元素的索引值還要大，原因不難理解，因為索引值是從 0 開始計算，而 length 是從 1 開始。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 陣列常値</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 數字陣列</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'one'</span>, <span class="number">2</span>, <span class="string">'three'</span>]; <span class="comment">// 非同型陣列</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="string">'one'</span>, <span class="number">2</span>, <span class="string">'three'</span>]</span><br><span class="line">]; <span class="comment">// 陣列裡有陣列</span></span><br><span class="line"><span class="keyword">const</span> arr4 = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'Tsuifei'</span>, <span class="attr">type</span>: <span class="string">'object'</span>, <span class="attr">luckyNumber</span>: [<span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">42</span>] &#125;, <span class="comment">// 非同型陣列</span></span><br><span class="line">  [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'Philippe'</span>, <span class="attr">type</span>: <span class="string">'object'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'Ayda'</span>, <span class="attr">type</span>: <span class="string">'object'</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">'three'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'array can contain function too'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 陣列長度</span></span><br><span class="line">arr1.length; <span class="comment">// 1</span></span><br><span class="line">arr4.length; <span class="comment">// 5</span></span><br><span class="line">arr4[<span class="number">1</span>].length; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加陣列長度</span></span><br><span class="line">arr1[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">arr1; <span class="comment">// [1,2,3,undefined,5] 直接指定，中間無值所以undefined</span></span><br><span class="line">arr1.length; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>length 的妙用<br>數組的 length 不是只讀的。所以我們可以通過 length 完成<br>【1】從數組末尾移除項<br>【2】在數組末尾添加新項<br>【3】清空數組</p><p>/<em>*\</em><br>_ 從數組末尾移除項<br>_ **/<br>var colors = [“red”, “blue”, “green”]; // 創建一個包含 3 個字符串的數組<br>colors.length = 2;<br>alert(colors[2]); // undefined</p><pre><code>/*** * 在數組末尾添加新項 * **/var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 創建一個包含3個字符串的數組colors[colors.length] = &quot;black&quot;; // (在位置3)添加一種顏色colors[colors.length] = &quot;brown&quot;; // (在位置4)再添加一種顏色/*** * 清空數組 * **/var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 創建一個包含3個字符串的數組colors.length = 0;console.log(colors); // []圖篇來源：https://unsplash.com/s/photos/seat</code></pre><h4 id="真清除-尾巴斷了"><a href="#真清除-尾巴斷了" class="headerlink" title="真清除 尾巴斷了"></a>真清除 尾巴斷了</h4><p>length 除了可以拿來查看陣列的長短，還可以拿來刪除陣列尾部的元素。只要直接指定想要的長度，截至想保留的長度，就可以輕鬆刪掉尾部的元素了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">a.length; <span class="comment">// 9</span></span><br><span class="line">a.length = <span class="number">5</span>;</span><br><span class="line">a; <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">a.length; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>創建與宣告陣列 Array</title>
      <link href="/tsuifei.github.io/JS_ironMan04_create-and-declare-arrays/"/>
      <url>/tsuifei.github.io/JS_ironMan04_create-and-declare-arrays/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-04"><a href="#Day-04" class="headerlink" title="Day 04"></a>Day 04</h6><p>這次的鐵人賽，參考書籍有可拿來當枕頭的大犀牛「Javascript 大全」和「你所不知道的 JS」系列為主要參考，學習前端以來深深覺得有些書，程度不到來讀，真的很吃力，本人就是如此。但既然知道這些書都是許多大神推薦的書，那麼就試著了解，不懂的地方透過實作和請教前輩得到答案，也是頗好的學習方式，但本人不才，如有解釋錯誤的地方，還請各位海函啊。</p><p>前一篇我們有提到陣列可以做什麼，是不是對陣列有個比較清楚的概念？有些參考書籍會把陣列形容成有很多個格子的抽屜或盒子，這樣去解釋陣列也是頗具體的，但要記得一般來說，每個格子都會有連續的編號，也就是前幾篇提到的索引值(index)是「有序」的這件事情。但到底有序是不是絕對呢？記得曾經看過，把陣列的索引值改成字串的數字作法，例如：let arr = []; arr[“5”] = 42 會有什麼結果呢？我們先賣個關子。</p> <a id="more"></a><p>當我們宣告一個陣列時，也同時在創建一個陣列，如果沒有考慮後續的處理問題，創建陣列是非常簡單的，但如果要讓陣列在後續可以很順利地被處理與運用，就不得不謹慎的考慮陣列裡的元素是什麼型別的問題了。</p><h2 id="字面值宣告陣列"><a href="#字面值宣告陣列" class="headerlink" title="字面值宣告陣列"></a>字面值宣告陣列</h2><p>最簡單的創建陣列方式是使用陣列的字面值(array literal)，也就是用一對中括號 []，把值放在[]中，並以逗號區隔陣列中的值(元素)，再指定給一個變數。</p><h3 id="空陣列"><a href="#空陣列" class="headerlink" title="空陣列"></a>空陣列</h3><p>什麼都沒放，當然也可以。通常是先設一個空陣列，再將要放進去的值已不同的方法放入，列如 push();。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyArray = [];</span><br></pre></td></tr></table></figure><h3 id="同型陣列"><a href="#同型陣列" class="headerlink" title="同型陣列"></a>同型陣列</h3><p>陣列裡面的值都是同類型的資料，這種陣列最好做後續的處理，處理過後的結果也最穩定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrNumber = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">24</span>, <span class="number">42</span>];</span><br></pre></td></tr></table></figure><h3 id="非同型陣列"><a href="#非同型陣列" class="headerlink" title="非同型陣列"></a>非同型陣列</h3><p>什麼資料型別都有的陣列， <del>不知道是什麼意圖</del> 或許可以用物件來裝會比較清楚一些，不然只有你知道每個元素的意義。有沒發現陣列的結尾也有一個逗點，在 JavaScript 裡是被允許的，但並不會因為有這個逗點，而讓陣列的長度變長，或者是多一個空值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrMixValue = [<span class="string">'Hi'</span>, <span class="number">4.2</span>, <span class="literal">true</span>, <span class="string">'24'</span>];</span><br></pre></td></tr></table></figure><h3 id="包含運算式的陣列"><a href="#包含運算式的陣列" class="headerlink" title="包含運算式的陣列"></a>包含運算式的陣列</h3><p>陣列裡的值不一定是要常數，陣列裡面的元素也可以是任意的運算式，例如，某一個商品的定價是 42，我們想知道這個商品打七折、八折、九折的價錢，並把它放在陣列裡， <del>或許</del>就可以用這個方法，但是，有時會有些意想不到的結果，這部分可以另外去查看 JavaScript 是如何處理運算子與數字的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unit = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">let</span> rebateList = [unit, unit * <span class="number">0.7</span>, unit * <span class="number">0.8</span>, unit * <span class="number">0.9</span>];</span><br><span class="line"><span class="comment">//  [42, 29.4, 33.6, 37.800000000000004]</span></span><br></pre></td></tr></table></figure><h3 id="逗點造成的稀疏陣列"><a href="#逗點造成的稀疏陣列" class="headerlink" title="逗點造成的稀疏陣列"></a>逗點造成的稀疏陣列</h3><p>如果在宣告陣列時，夾雜了多個分隔的痘點，逗號和逗號之間沒有值，都會被視為是 undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrNumber = [<span class="number">2</span>, <span class="number">4</span>, , <span class="number">24</span>, , <span class="number">42</span>];</span><br></pre></td></tr></table></figure><h3 id="含有-undefined-的陣列"><a href="#含有-undefined-的陣列" class="headerlink" title="含有 undefined 的陣列"></a>含有 undefined 的陣列</h3><p>如果宣告陣列時，介於兩個逗號之間沒有值或空的，這個陣列就會成為稀疏陣列，這些空的元素會被填入 undefined，變成所謂的空插槽(empty slots)，這些空的位置看似被填入了 undefined，但是在瀏覽器的開發工具 Console 使用同樣的語法，填入的卻是 Empty 而不是 undefined。在「你所不知道的 JS - 導讀，型別語文法」裡也有寫到這樣的現象，說明了在這裡產生的 undefined 和 arr[1] = undefined 不同，使用方法的結果也較不穩定，需要特別注意。</p><h3 id="包含物件和陣列的陣列"><a href="#包含物件和陣列的陣列" class="headerlink" title="包含物件和陣列的陣列"></a>包含物件和陣列的陣列</h3><p>在大全裡，有一個範例是陣列被宣告時，陣列裡的值如下，加好多料，有陣列也有物件，這真的超過本人的理解範圍，也真的不建議這麼寫。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vrayMix = [</span><br><span class="line">  [<span class="number">0</span>, &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;],</span><br><span class="line">  [<span class="number">1</span>, &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="建構式宣告"><a href="#建構式宣告" class="headerlink" title="建構式宣告"></a>建構式宣告</h2><p>另一種創建陣列的方式是使用 JavaScript 內建的建構式 Array() ，把建構式直接指定給變數，就成了陣列。<br>創建陣列有三種方法：</p><h3 id="不帶引數就是空陣列"><a href="#不帶引數就是空陣列" class="headerlink" title="不帶引數就是空陣列"></a>不帶引數就是空陣列</h3><p>1.不帶引數的呼叫，這裡的引數指的是 new Array()括號內所放的值，結果同等於空陣列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// -&gt; []</span></span><br></pre></td></tr></table></figure><h3 id="給長度仍然是空的"><a href="#給長度仍然是空的" class="headerlink" title="給長度仍然是空的"></a>給長度仍然是空的</h3><p>2.在內建的建構式 Array() 裡帶一個值數值，而這個值也會成為這個陣列的長度，且裡面的值都會是空值 undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>); <span class="comment">// -&gt; [empty × 5]</span></span><br></pre></td></tr></table></figure><h3 id="陣列內容就在括弧裡"><a href="#陣列內容就在括弧裡" class="headerlink" title="陣列內容就在括弧裡"></a>陣列內容就在括弧裡</h3><p>3.把要宣告的陣列內容，直接以引數的方式帶入建構式，感覺建構式的括號裡可以包山包海，放不同的型別資料也可以。但是放入時記得要把陣列的中括號[]拿掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">'hi'</span>, <span class="number">42</span>); <span class="comment">// -&gt;  [Array(3), "hi", 42]</span></span><br></pre></td></tr></table></figure><h2 id="總結：要用哪一種？"><a href="#總結：要用哪一種？" class="headerlink" title="總結：要用哪一種？"></a>總結：要用哪一種？</h2><p>看了「Javascript 大全」和「你所不知道的 JS」系列，都是建議盡量少用建構式的方式去宣告或創建陣列，原因不是很清楚，但比較下來「字面值」宣告陣列的方式明顯比「建構式」宣告來的直覺與簡單。</p><p>建構式的陣列宣告與一般的陣列宣告本質上是相同的，唯一一點不同的是，如果宣告時我們只給一個參數，那麼字面值會把第一個參數當作是陣列裡第一個元素值，而建構式則會把第一個參數當作是陣列的長度，且只能給整數不能給小數點，不然會報錯，這點不可不注意。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">8</span>]; <span class="comment">// [8]  length: 1</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">8</span>); <span class="comment">// [empty x 8] length: 1</span></span><br></pre></td></tr></table></figure><h3 id="JS-很奇怪捏"><a href="#JS-很奇怪捏" class="headerlink" title="JS 很奇怪捏"></a>JS 很奇怪捏</h3><p>在文章的開頭，有提到把陣列的索引值改成字串的數字作法，例如：let arr = []; arr[“5”] = 42 會有什麼結果呢？答案是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr[<span class="string">'5'</span>] = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// (6) [empty × 5, 42]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>當我們這樣宣告時，JavaScript 並不會報錯，而直接把字串的數字轉成陣列長度，然後加上我們把 42 指定給它，JavaScript 直接把 42 放進陣列，長度因此變成 6，有猜對嗎？</p><p>但這只有字串的數字會有這種現象，如果是純字串，那麼字串就會被轉換成 key，而指定的值則會轉換成為 key:value 的形式。<br>因為 Javascript 的陣列不能用字串作為索引值。 當一個 Javascript 陣列是只能以數字作為索引值的，所以當我們設定以字串作為索引值的時候，實際上是在設置物件的屬性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr[<span class="string">'Hi'</span>] = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [Hi: 42]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>介紹了四天的陣列，有沒覺得膩？小菜才吃了四碟，明天我們就來介紹陣列唯一的屬性 length 與其他較輕鬆的話題吧！</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陣列可以做什麼、裝什麼有差嗎？</title>
      <link href="/tsuifei.github.io/JS_ironMan03_What-can-the-array-do/"/>
      <url>/tsuifei.github.io/JS_ironMan03_What-can-the-array-do/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-03"><a href="#Day-03" class="headerlink" title="Day 03"></a>Day 03</h6><blockquote><p>Que peut faire avec un Array ?<br>陣列是最早期和重要的資料結構之一，有許多程式都會用到陣列。我們也會拿陣列來實作許多其他的資料結構，像是列表（list）以及字串（string）。</p></blockquote><p>或許是陣列排序的特性，有如電腦中記憶體的一維陣列結構，而索引就像是記憶體的位址是連續的，因此編譯器通常可以針對陣列操作進行最佳化處理。代表順序的索引(index)會有其對應的值(元素)，利用這種特性，我們可以輕易的找到某個指定的索引，再來對值做處理。且在一個陣列裡，我們可以放大量的資料，所以當我們要對這一大串的資料做處理，就可以以「批次」的方式，快速地進行處理。</p><a id="more"></a><h3 id="陣列如何處理一大筆資料？"><a href="#陣列如何處理一大筆資料？" class="headerlink" title="陣列如何處理一大筆資料？"></a>陣列如何處理一大筆資料？</h3><p>昨天我們有稍微的提到，在陣列裡我們可以塞下許多不同類型的資料，雖然一般而言，我們會建議陣列裡放的資料最好具有相同資料型別，要對裡面的元素處理也比較單純，但就像我們買了一個承重量只有 500g 的紙袋，也會遇到ㄧ定要撐到爆的時候，有些時候我們也會在陣列裡放下許多類型的資料 <del>（什麼心態啊～）</del>。但為了批次處理，還是盡量讓陣列裡的資料結構的元素同型別吧，不然得要經過層層的預處理，反而失去陣列可以批次處理的方便特性。</p><p>為什麼在陣列裡的元素，具有相同資料型別很重要，來看看 Javascript 會怎麼處理這些不同型別的資料就知道。比如說，一個陣列裡，元素皆是數字(Number)，如何把這個陣列裡的數字相加得到總和？只要一個 for 迴圈就可輕易辦到，但如果其中一個陣列元素，長得和其他人不一樣，那麼會有什麼結果呢？</p><p>Javascript 弱型別語言的特性，常會給我們神奇的傑克！我們來看以下的這些例子，以 for 迴圈來相加陣列裡面的數字，看看如果在陣列裡夾雜了其他型別的元素，會有什麼結果：</p><h3 id="都是數字，加的很高興"><a href="#都是數字，加的很高興" class="headerlink" title="都是數字，加的很高興"></a>都是數字，加的很高興</h3><p>第一個是正常的陣列，裡面的元素皆是數字(number)。<br>相加陣列裡的數字，總和是 6。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  sum = sum + a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h3 id="陣列裡有「偽數字」的字串"><a href="#陣列裡有「偽數字」的字串" class="headerlink" title="陣列裡有「偽數字」的字串"></a>陣列裡有「偽數字」的字串</h3><p>陣列裡夾著一個「偽數字」的字串，會是 33 ，因為加到這個字串的時候加法就失效了，只好把字串 3 硬加上去站隔壁，就成了 33 了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'3'</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  sum = sum + a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 33</span></span><br></pre></td></tr></table></figure><h3 id="陣列裡有「偽數字」的字串放前面"><a href="#陣列裡有「偽數字」的字串放前面" class="headerlink" title="陣列裡有「偽數字」的字串放前面"></a>陣列裡有「偽數字」的字串放前面</h3><p>但是如果把「偽數字」的字串放在陣列的第一個，JavaScript 會把其他的數字也當成是字串處理，結果就是把原本 sum 初始化的 0 繼續和其他數字(已變成字串) 堆疊排排站。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = [<span class="string">'1'</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">  sum = sum + b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 0123</span></span><br></pre></td></tr></table></figure><h3 id="其他的運算子才不吃這套"><a href="#其他的運算子才不吃這套" class="headerlink" title="其他的運算子才不吃這套"></a>其他的運算子才不吃這套</h3><p>把其他數字自動轉換成字串的狀況，只會出現在 + 的運算子上 <del>（好偏心）</del>，如果是減、乘、除呢？答案是 JavaScript 會自動把字串轉成數字，「偽數字」的字串依放在陣列的位置不同，而有不同的結果，這點還蠻讓人驚訝的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">'1'</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  sum = sum * a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h3 id="陣列裡參雜字串，叫它如何是好？"><a href="#陣列裡參雜字串，叫它如何是好？" class="headerlink" title="陣列裡參雜字串，叫它如何是好？"></a>陣列裡參雜字串，叫它如何是好？</h3><p>JavaScript 會先相加前面的數字，加到字串時發現無法加了，也無法轉數字，就只好用停在那裡，請字串站旁邊。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'Hi'</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  sum = sum + a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 3Hi</span></span><br></pre></td></tr></table></figure><h3 id="可以來點更扯的放陣列"><a href="#可以來點更扯的放陣列" class="headerlink" title="可以來點更扯的放陣列"></a>可以來點更扯的放陣列</h3><p>這一定是個失誤，會把另一個陣列放進去累加，然而 JavaScript 很不領情的只接受第一個元素，其他的就放生了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  sum = sum + a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 31,2,3</span></span><br></pre></td></tr></table></figure><h3 id="未被定義的壞了一鍋粥"><a href="#未被定義的壞了一鍋粥" class="headerlink" title="未被定義的壞了一鍋粥"></a>未被定義的壞了一鍋粥</h3><p>在陣列裡放了個 undefined，就什麼也不用加了，直接告訴我們，你不是數字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">undefined</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  sum = sum + a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="雖然是空，但還有剩"><a href="#雖然是空，但還有剩" class="headerlink" title="雖然是空，但還有剩"></a>雖然是空，但還有剩</h3><p>再來試試看空值的 null，結果是有比較正常，JavaScript 直接把 null 當成 0，而且無論是放在陣列的頭或尾，都會把 null 當成 0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  sum = sum + a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="布林值原來也可以拿來算數"><a href="#布林值原來也可以拿來算數" class="headerlink" title="布林值原來也可以拿來算數"></a>布林值原來也可以拿來算數</h3><p>因為對 JavaScript 而言，false 的另一個含義是 0，而 true 則代表 1，也因此 1+2+1=4 。當然如果是 false 總和就會是 3。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  sum = sum + a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 4 true=1</span></span><br></pre></td></tr></table></figure><p>以上做了那麼多的測試，只是想告訴大家如果陣列的型別不一，處理起來有多麼多的彩蛋，尤其是 JavaScript 弱型別的特色，即使型別不同拿來運算，也不會報錯，實在是蠻可怕的，所以趁此機會了解一下 Javascript 的古怪，也是挺好的，不是嗎？</p><p>況且今天測試的也只是資料型別 Primitive 原始型別裡的 Number 而已，等到我們遇到了複合型(composite)或參考型(reference)的資料類型，就要要開始燒腦了。恰巧 JavaScript 的 Array 陣列就是燒腦的型別，但 Array 也是用來存取大量數據的好工具，所以還是很值得好好學習的。</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array 陣列是什麼</title>
      <link href="/tsuifei.github.io/JS_ironMan02_What-is-the-array/"/>
      <url>/tsuifei.github.io/JS_ironMan02_What-is-the-array/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-02"><a href="#Day-02" class="headerlink" title="Day 02"></a>Day 02</h6><blockquote><p>C’est quoi un Array</p></blockquote><h5 id="測試環境已-Chrome-瀏覽器為主，通常會在-VS-code-打好碼，再丟到-Chrome-的-Console-跑。"><a href="#測試環境已-Chrome-瀏覽器為主，通常會在-VS-code-打好碼，再丟到-Chrome-的-Console-跑。" class="headerlink" title="測試環境已 Chrome 瀏覽器為主，通常會在 VS code 打好碼，再丟到 Chrome 的 Console 跑。"></a>測試環境已 Chrome 瀏覽器為主，通常會在 VS code 打好碼，再丟到 Chrome 的 Console 跑。</h5><p>在討論陣列之前，可以先來想像一下，如果今天天氣超級好，我們洗了很多衣服，曬乾之後的衣服充滿陽光的氣息，我們把這些衣服整包的丟到床上，一邊開著電視，一邊開始折衣服，再將所有的上衣折好放成一疊、長褲折好一疊、襪子捲好放成一堆，再一一放入衣櫃裡，我們分門別類地把這些衣服摺好時，這一疊的衣服就有陣列的概念了。</p><p>一般來說，陣列在程式語言裡的定義是：陣列(Array)是一組相同型態的連續變數，它們使用同一個變數名稱，而另外用一個索引值來指定使用第幾個變數。且陣列本質上是有序的，索引是從零開始計算的。</p><a id="more"></a><p>在<a href="https://zh.wikipedia.org/zh-tw/%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">維基百科</a>裡，對於陣列的說明是：</p><blockquote><p>在電腦科學中，陣列資料結構（英語：array data structure），簡稱陣列（英語：Array），是由相同類型的元素（element）的集合所組成的資料結構，分配一塊連續的記憶體來儲存。利用元素的索引（index）可以計算出該元素對應的儲存位址。</p></blockquote><h3 id="簡單的說，陣列就是一個「有序」、「有索引」、「有值」的一個「集合」。"><a href="#簡單的說，陣列就是一個「有序」、「有索引」、「有值」的一個「集合」。" class="headerlink" title="簡單的說，陣列就是一個「有序」、「有索引」、「有值」的一個「集合」。"></a>簡單的說，陣列就是一個「有序」、「有索引」、「有值」的一個「集合」。</h3><p>但在 JavaScript ，我們如何定義它？依據 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">NDM</a> 的解釋：</p><blockquote><p>陣列的值的有序序列。有別於其他的語言，JavaScript 並沒有明確的陣列資料類型。取而代之，提供了 Array 物件，可以直接實體化或使用陣列的字面表達記法。</p></blockquote><p>JavaScript 果然是個很奇特的語言，不只沒限制放在陣列裡的資料型別，也就是說在陣列裡，要放數字、字串、陣列甚至是物件都可以，簡直是百寶箱了。不只這樣，JavaScript 還幫我們做好了陣列 Array 的物件供我們應用，以及許多陣列的方法，讓我們可以輕易的操控陣列，這些方法將在後續一一來介紹。</p><h2 id="陣列-Array-的真面目"><a href="#陣列-Array-的真面目" class="headerlink" title="陣列 Array 的真面目"></a>陣列 Array 的真面目</h2><p>JavaScript 的資料型別有數字(Number)、字串(String)、布林(Boolean)、空(null)、未定義(undefined)、符號(Symbol)、陣列(Array)、物件(Object)。雖然字面上 JavaScript 的型別有這麼多種，但是其實骨子裡 JavaScript 在這些型別裡又分組，甚至，有些還喬裝成別組，是不是很錯亂？</p><p>想要各型別現出原形，得用 JavaScript 裡的關鍵運算子 typeof 來照妖，猜猜陣列 Array 的真面目是什麼？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">typeof</span> arr; <span class="comment">// "object" 是物件</span></span><br></pre></td></tr></table></figure><p>怎麼回事？居然是”object”物件！關於陣列或 JavaScript 的各型別，我們在之後也會陸續提到。</p><h2 id="陣列長什麼樣子"><a href="#陣列長什麼樣子" class="headerlink" title="陣列長什麼樣子"></a>陣列長什麼樣子</h2><p>JavaScript 陣列的基本長相為下圖，是由一對中括號 [ ] 組成， [ ] 裡面為陣列元素，每個元素以逗號分開，通常我們會將一組陣列，賦值給一個變數。再以這個變數來做各種處理。</p><img src="https://lh3.google.com/u/0/d/1nGDgv3Yig9uGJRuuXZyes5ijhNCP7Pp0=w1434-h1624-iv1" width="70%" height="70%"><p>以下是幾個陣列的範例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 變數 = [ 元素, 元素, 元素, ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrDeux = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrObj = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'Ayda'</span>, <span class="attr">city</span>: <span class="string">'Paris'</span>, <span class="attr">luckyNumbers</span>: [<span class="number">24</span>, <span class="number">42</span>, <span class="number">15</span>] &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>有沒有被陣列能裝載的東西嚇到，看得出最後一個陣列像什麼嗎？有沒有覺得似曾相似？似乎，陣列不像我們想像的那樣單純，明天我們再繼續了解囉。</p><blockquote><p>如有需要改進的地方，拜託懇求請告知，我會盡量快速度修改，感謝您～</p></blockquote><h4 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h4><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Obsolete_Pages/Obsolete_Pages/Obsolete_Pages/%E9%99%A3%E5%88%97%E7%9A%84%E9%81%8B%E7%94%A8" target="_blank" rel="noopener">陣列的運用 - JavaScript | MDN</a></p><p><a href="https://zh.wikipedia.org/zh-tw/%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">陣列 - 維基百科，自由的百科全書</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 鐵人賽 參賽緣由</title>
      <link href="/tsuifei.github.io/JS_ironMan01_foreword/"/>
      <url>/tsuifei.github.io/JS_ironMan01_foreword/</url>
      
        <content type="html"><![CDATA[<h6 id="Day-01"><a href="#Day-01" class="headerlink" title="Day 01"></a>Day 01</h6><blockquote><p>人生總是要做些沒做過的事，例如寫鐵人賽</p></blockquote><p>從來沒想過自己會參加這種接力賽，因為自認自己的恆毅力常常被自己的記憶力擊潰，有許多事自己做著做著就忘記了，即使做著筆記，也會常常記著記著就忘記自己記在哪裡了，金害！但是，人生總是要做些沒做過的事，例如寫鐵人賽，而且很幸運的可以跟好想工作室的夥伴一起參加，有人陪伴再好也不過。</p><p>本人曾經做過一段很長時間的平面設計，也忘了在那個還在做手工稿的年代，自己怎麼學會用電腦完稿的。接著網路還在撥接的年代，開始自學 HTML 和 CSS 從靜態網頁做到動畫網頁 Flash，接著用 PHP 做動態網頁，就這樣一路下來，幾年前的前端大變革，本人也差不多老了，but, but 總不能因為新的時代的來臨，而不去迎接它，於是在兩年前，因在職多年的傳統公司轉型沒成功翻身，公司瀕臨破產，於是就活生生地被資遣了。當時不知戲到底要不要繼續演下去，但還是很愛 WEB 這一塊，於是不小心把頭洗下去，那就繼續學習吧！</p><a id="more"></a><p>也很感謝好想工作室與一起學習的夥伴，互相學習彼此切磋的力量太強大了，也因為在好想，讓我的轉職變得更有意義。</p><p>覺得 JavaScript 真的只能用女大十八變來形容，想當年它常被拿來做走馬燈，或一閃一閃極度干擾視覺的按鈕，沒想到短短的這幾年，已經變成了瀏覽器的當家花旦，只有它能搞定在瀏覽器上的異步要求，甚至跨界跨到後端去了！但它似乎不是那麼好搞定，那麼就藉由這次的機會好好的認識它。</p><p>這次寫鐵人賽的主題會圍繞在如題的 JavaScript Array 陣列上，什麼？！ Array 寫 30 天？這樣小菜一碟也敢端出來？各位看官，別看只是小菜，每天變化出新花樣也是不容易的，況且小菜做得好，那麼拼湊一桌好菜就有希望了。期望自己能把小菜功夫先練好，那才能繼續往前菜邁進啊～ 除了寫陣列的各個面向和方法，也會穿插較輕鬆的話題，學習經驗或者是和開發者相關議題的內容，小菜吃太久，偶爾還是要換一下口味。</p><p>學習程式會是一趟漫長的旅程，不管是哪一門程式語言，在學習之路上都沒有迅速的捷徑，每個人都有自己的節奏與進程，唯有不間斷的慢慢累積經驗與學習，不斷的思考，才能慢慢的往前行。一起加油吧。</p><p>最後僅此獻給各位：<br><img src="./images/day01a.jpg" alt="image">)</p><p>:::info<br>如有錯誤需改進的地方，拜託懇求跟我說。我會以最快速度修改，感謝您～<br>:::</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
            <tag> Iron man 30 鐵人賽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 奇怪的部分:函數呼叫與執行堆</title>
      <link href="/tsuifei.github.io/JSstrange_call-function-execution-stack/"/>
      <url>/tsuifei.github.io/JSstrange_call-function-execution-stack/</url>
      
        <content type="html"><![CDATA[<p>這一系列為 Anthony Alicea 的 「JavaScript 全攻略：克服 JS 的奇怪部分」課程筆記。<br>JavaScript 在呼叫函式的時候，到底發生了什麼事？是如何被執行的？<br>了解這些重不重要？應該很重要，就像一部車，如果不知道結構，要修理它恐怕很難吧？抱著這總心態，既然要學 JavaScript，那就好好瞭解它的運作原理吧。</p><p>我們先來想像一下，以下這段碼，在被編譯的時候，是怎麼進行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><a id="more"></a><p>當我們呼叫<code>a()</code>函數時，第一個被創造的是全域執行環境(Global Execution)。語法解析器會分析程式，然後編譯程式，接著創造全域執行環境與全域變數 <code>this</code>。如果是在瀏覽器，就會創造<code>windows</code>這個物件，然後將這些函數放進記憶體中。這裡的<code>this</code> 等同全域物件或瀏覽器裡的 window。</p><p>在創造的第一個階段，是把<code>a()</code>和<code>b()</code>都先放在記憶體裡，然後程式碼會逐行被執行。雖然是先放在記憶體裡，但 JS 不會執行函數中的程式，因為它們還沒被呼叫。</p><p>當編譯器遇到最下面這個<code>a()</code>時，<code>a()</code>函數被呼叫了，這時候<code>a()</code>會被放進執行堆（execution stack）中。這個執行堆會一個一個疊起來，誰在最上面的就是正在執行的東西。</p><p>所以每此 JavaScript 呼叫函數，就會創造一個新的執行環境，然後被放進執行堆中，一個新的執行環境被創造，就像全域執行環境一樣，會有它自己的記憶體空間給變數和函數。</p><p>這個過程會歷經創造階段，然後逐行執行函數中的程式。但是一但我們呼叫另一個函數，它就會停止執行程式，然後，再創造另一個執行環境，然後繼續執行。</p><p>如果函式裡沒有程式需要被執行，如<code>b()</code>，JavaScript 仍會創造一個執行環境，然後如上述般，逐行執行程式。</p><p>當<code>b()</code>結束後，因為它在執行堆的最上面，所以它會離開執行堆，然後是<code>a()</code>，最後回到最下面的全域執行環境。<br><img src="/images/js_stack01.jpg" alt></p><p>程式執行中實際排列的順序並不重要，在函數中剩下的程式碼順序也不會影響執行先後<br>，假設我們把<code>a()</code>放到<code>b()</code>前面，然後在函數裡多了一些程式（如下），這並不會影響執行，因為雖然<code>a()</code>看起來在<code>b()</code>前面，但這些函數在創造階段就已經在記憶體中了，也就是在全域執行環境被初始化時就在了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">  <span class="keyword">var</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d;</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="keyword">var</span> d;</span><br></pre></td></tr></table></figure><p>我們所看到下面被函數呼叫的<code>var c</code>和<code>var d</code>也都在記憶體中了。</p><p>他們的執行順序是，首先<code>a()</code>函數會被呼叫，因此<code>a()</code>會被放入執行堆，同時進入<code>a()</code>的執行環境。接著，它會變成目前執行的程式，而最後一行的 <code>var d</code> 在 <code>a ()</code>下面所以不會被呼叫。</p><p>因為 JavaScript 是同步且一次執行一行，現在執行的程式就是目前的執行環境，也就是執行堆最上面的那個。所以當<code>a()</code>在最上面時 它會進入函式逐行執行，在 a 函式中呼叫<code>b()</code>函數，<code>b()</code>會創造出自己的執行環境，然後進入執行堆最上面，再逐行執行它裡面的程式，等執行完最後一行之後，再跳回去繼續執行<code>a()</code>函數裡的其他程式。</p><p>為什麼？ 因為當我們結束<code>b()</code>函數後，<code>b()</code>的執行環境就會離開執行堆，所以現在在最上面的是誰？是<code>a()</code>。然後繼續執行剛剛在<code>b()</code>後面的<code>var c</code></p><p>當<code>a()</code>執行完畢後 a()會離開執行堆，接著下一行還沒被執行的程式，也就是在全域執行環境中，最後的<code>var d</code></p><p>這就是 JavaScript 執行的順序。每當函數被呼叫，一個新的執行環境就被創造給函數，同時，<code>this</code> 變數被創造給這個函數，而裡面的變數在創造階段就已經建立了，<br>然後程式碼會被逐行的執行。但每當函數被呼叫，即使是被自己呼叫，一個新的執行環境就會進入執行堆，然後當執行完畢後，離開執行堆。所以無論最上面是什麼，那個就是正在執行的程式。–&gt;正在執行的永遠在執行堆的最上面。</p><p>逐行的、同步的這個觀念是非常重要，了解程式執行的逐一步驟，才會預防一些不知名的問題。</p><h6 id="單字"><a href="#單字" class="headerlink" title="單字"></a>單字</h6><p>invoke the function 或是 function invocation, 意思是執行這個函數</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> Strange JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Strange JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 判別是否為陣列 Array 的方法</title>
      <link href="/tsuifei.github.io/JS-Confirm-whether-is-Array/"/>
      <url>/tsuifei.github.io/JS-Confirm-whether-is-Array/</url>
      
        <content type="html"><![CDATA[<p>陣列在 JS 裡的原生型別是 object，這點可以由 typeof 來確認。但如果要確認某一元素的原型是陣列，或是在物件裡的某一元素是陣列，又該怎麼判別？<br>如果元素不是陣列，就無法使用陣列專用的函式或做些陣列的處理，因此才會有確認某元素的原型是陣列的需求。</p><h5 id="1-isArray"><a href="#1-isArray" class="headerlink" title="1.isArray"></a>1.isArray</h5><p>最簡單的陣列判斷語法 isArray，用的是內建 Array 物件中的 isArray，是個 ES5 的標準方法:<br><code>Array.isArray(variable)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">Array</span>.isArray(a); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="2-constructor"><a href="#2-constructor" class="headerlink" title="2.constructor"></a>2.constructor</h5><p>使用<code>constructor</code>，這是在 Chrome 瀏覽器中效能最佳的判斷方法，它是直接用物件的建構式來判斷:<br><code>variable.constructor === Array</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="string">'2'</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]];</span><br><span class="line">a.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="判別物件中的陣列"><a href="#判別物件中的陣列" class="headerlink" title="判別物件中的陣列"></a>判別物件中的陣列</h4><h5 id="3-constructor-Array"><a href="#3-constructor-Array" class="headerlink" title="3.constructor === Array"></a>3.constructor === Array</h5><p>如果要判別物件中的其中屬性是否為陣列，可以先判斷這個屬性是否存在，如下(foo 指的是物件屬性):<br><code>variable.foo &amp;&amp; variable.foo.constructor === Array</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  foo: [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'f'</span>],</span><br><span class="line">  ho: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  hi: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">b.foo &amp;&amp; b.foo.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">b.ho &amp;&amp; b.ho.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">b.hi &amp;&amp; b.hi.constructor === <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>例外: 當使用在一個繼承自陣列的陣列會失效</p><h5 id="4-instanceof"><a href="#4-instanceof" class="headerlink" title="4.instanceof"></a>4.instanceof</h5><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="noopener">instanceof</a> 也是用物件的相關判別方法來判斷，instanceof 運算符是用於判斷是否為某個物件的實例，優點為語法簡潔清楚。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oArrayObject = <span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">oArrayObject <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也適用於其他型別的判別</span></span><br><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello world'</span>);</span><br><span class="line">oStringObject <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>例外: 處理不同 window 或 iframe 時的變數會失效</p><h5 id="5-toString-call"><a href="#5-toString-call" class="headerlink" title="5.toString.call"></a>5.toString.call</h5><p>==推薦使用==<br>網路上推薦這種方式判別的頗多，原因應該是這種方式是所有情況都可以正確判斷的一種，且可適用各種狀況，也可以判斷陣列以外的其他特別物件，唯一缺點是效率最差。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(variable) === <span class="string">'[object Array]'</span>;</span><br></pre></td></tr></table></figure><p>據說在 JavaScript: The Definitive Guide, 6th Edition 書中有提到，Array.isArray 其實就是用這個方式實作的。</p><p>另外，網路上也有人寫成一支判斷陣列終極解決方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayFn</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 包成函式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.isArray === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(obj); <span class="comment">// 如果瀏覽器支援就用 isArray() 方法</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否則就使用 toString 方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">isArrayFn(arr); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="用哪一種？"><a href="#用哪一種？" class="headerlink" title="用哪一種？"></a>用哪一種？</h3><p>這幾個方式的選擇，網路上的前輩建議是==只要學最後一種==就行了(如果不考慮舊瀏覽器就用第一種)，它可以正確判斷並應用在各種情況，有時候正確比效能快更為重要，更何況它其實是萬用的，除了陣列之外也可以用於其它的判斷情況。雖然它的語法對初學者來說，可能無法在此時完全理解，不過就先知道要這樣用就行了。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS Array Slice</title>
      <link href="/tsuifei.github.io/JS_Array-Slice/"/>
      <url>/tsuifei.github.io/JS_Array-Slice/</url>
      
        <content type="html"><![CDATA[<p>slice() 中文直譯為切片，即是從陣列複製一份出來。<br>有時我們想要處理陣列資料，又不想動到原始資料，因為一但動到原始資料就無法回復原本的樣子，甚至要比對都無從比對，這時 slice()就常派上用場。<br>這點感覺有點像 git，先把資料 pull 一份下來的動作一樣。</p><a id="more"></a><h5 id="語法：arr-slice-begin-end-，參數一是從哪裡切，參數二是切到哪裡，如果要全部複製則可填-0，如有第二參數，它的索引值為指定的前一個"><a href="#語法：arr-slice-begin-end-，參數一是從哪裡切，參數二是切到哪裡，如果要全部複製則可填-0，如有第二參數，它的索引值為指定的前一個" class="headerlink" title="語法：arr.slice([begin[, end]]) ，參數一是從哪裡切，參數二是切到哪裡，如果要全部複製則可填 0，如有第二參數，它的索引值為指定的前一個"></a>語法：arr.slice([begin[, end]]) ，參數一是從哪裡切，參數二是切到哪裡，如果要全部複製則可填 0，如有第二參數，它的索引值為指定的前一個</h5><p>MDN:<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="noopener">slice();</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> amis = [<span class="string">'Ayda'</span>, <span class="string">'Phi'</span>, <span class="string">'Alex'</span>, <span class="string">'Chris'</span>, <span class="string">'Tracy'</span>, <span class="string">'Thomas'</span>, <span class="string">'Jean'</span>];</span><br></pre></td></tr></table></figure><h4 id="沒給參數和參數零的結果是一樣的"><a href="#沒給參數和參數零的結果是一樣的" class="headerlink" title="沒給參數和參數零的結果是一樣的"></a>沒給參數和參數零的結果是一樣的</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> amis2 = amis.slice();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'沒參數： '</span> + amis2); <span class="comment">// Ayda,Phi,Alex,Chris,Tracy,Thomas,Jean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> amis3 = amis.slice(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'參數0： '</span> + amis3); <span class="comment">// Ayda,Phi,Alex,Chris,Tracy,Thomas,Jean</span></span><br></pre></td></tr></table></figure><h4 id="只給一個參數，會從給的-index-開始切"><a href="#只給一個參數，會從給的-index-開始切" class="headerlink" title="只給一個參數，會從給的 index 開始切"></a>只給一個參數，會從給的 index 開始切</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> amis4 = amis.slice(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'只給一個參數： '</span> + amis4); <span class="comment">// Alex,Chris,Tracy,Thomas,Jean</span></span><br></pre></td></tr></table></figure><h4 id="給負數參數，會從最後面開始取"><a href="#給負數參數，會從最後面開始取" class="headerlink" title="給負數參數，會從最後面開始取"></a>給負數參數，會從最後面開始取</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> amis5 = amis.slice(<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'給負數參數： '</span> + amis5); <span class="comment">// Thomas,Jean</span></span><br></pre></td></tr></table></figure><h4 id="給兩個參數，"><a href="#給兩個參數，" class="headerlink" title="給兩個參數，"></a>給兩個參數，</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> amis6 = amis.slice(<span class="number">2</span>, <span class="number">-2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'給兩個參數： '</span> + amis6); <span class="comment">// Alex,Chris,Tracy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二參數的索引值為指定的前一個</span></span><br><span class="line"><span class="keyword">var</span> amis7 = amis.slice(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'給兩個參數： '</span> + amis7); <span class="comment">// Alex,Chris</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'原始陣列不變： '</span> + amis); <span class="comment">// Ayda,Phi,Alex,Chris,Tracy,Thomas,Jean</span></span><br></pre></td></tr></table></figure><p>在使用 slice() 的時候並不需要再用另一個變數去接結果，因為使用 slice()時，就會自動的在新的記憶體位址產生。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(amis.slice(<span class="number">2</span>, <span class="number">4</span>)); <span class="comment">// Alex,Chris</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS_Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 三種字串轉數字的方法</title>
      <link href="/tsuifei.github.io/JS_Converting-strings-to-numbers/"/>
      <url>/tsuifei.github.io/JS_Converting-strings-to-numbers/</url>
      
        <content type="html"><![CDATA[<h5 id="Converting-strings-to-numbers-with-vanilla-JavaScript"><a href="#Converting-strings-to-numbers-with-vanilla-JavaScript" class="headerlink" title="Converting strings to numbers with vanilla JavaScript"></a>Converting strings to numbers with vanilla JavaScript</h5><p>透過瀏覽器輸入的內容，要拿來做運算用的時候，必須先轉成數字，否則運算出來結果一定會讓人出乎意料。列如要使用者輸入兩個數字，然後將其相加，再將結果顯示於畫面，如果不做轉型，則會 1 + 1 = 11, 4 + 2 = 42,而不是我們想要的 2 和 6。</p><a id="more"></a><h2 id="字串轉數字"><a href="#字串轉數字" class="headerlink" title="字串轉數字"></a>字串轉數字</h2><p>42 和 ‘42’ 都是數字，但對 JS 來說卻是不同的。<br>我們可以以嚴格模式的比較運算子，透過以下的方式得知，兩者的不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="string">'42'</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">if</span> (num1 === num2) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>以下有幾個方式將字串轉成數字，但不同的方式有不同的特色與優缺點。</p><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><p>將字串轉數字，回傳整數(whole number)。第一參數為字串，第二參數(進位)，如不給第二參數，則會以預設十進位轉數字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'42px'</span>;</span><br><span class="line"><span class="keyword">var</span> integer = <span class="built_in">parseInt</span>(num1, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(integer); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>比較有趣的是，如果把開頭是數字，之後接字母的字串丟入處理，parseInt 也會回傳數字的部份。如果字串開頭沒有數字，則會回傳 NaN。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'42px'</span>); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'Hello paris'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'px42'</span>, <span class="number">10</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h3><p>可以將放入的字串，回傳成帶有小數點(point number)的數字，如果有遇到非數字，則會只取數字，如果無法轉成數字，則會返回 NaN。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'4.2isInFrance'</span>;</span><br><span class="line"><span class="keyword">var</span> pointNumber = <span class="built_in">parseFloat</span>(text);</span><br><span class="line"><span class="built_in">console</span>.log(pointNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他例子</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'234.234des'</span>); <span class="comment">// 234.234</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'234.f234fff'</span>); <span class="comment">// 234</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'f234.f234fff'</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p>放入字串就會回傳數字，但是不容許混雜數字以外的字元，可以是小數點。屬於較嚴僅的字串轉數字的方式，只要字串裡有數字以外的字元都會傳回 NaN。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'42'</span>); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'24.42'</span>); <span class="comment">// 24.42</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'-24.42'</span>); <span class="comment">// -24.42</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'-0'</span>); <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'is42'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'24.42isASchool'</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>透過以上幾個字串轉數字的方式比較，以後就知道，用哪個方式轉成數字比較保險了。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS-[JS101] 練習</title>
      <link href="/tsuifei.github.io/JS_JS101-Exercise/"/>
      <url>/tsuifei.github.io/JS_JS101-Exercise/</url>
      
        <content type="html"><![CDATA[<h2 id="判斷條件練習"><a href="#判斷條件練習" class="headerlink" title="判斷條件練習"></a>判斷條件練習</h2><h3 id="練習一：判斷是否及格"><a href="#練習一：判斷是否及格" class="headerlink" title="練習一：判斷是否及格"></a>練習一：判斷是否及格</h3><p>請你自己寫出一段程式碼，是判斷一個叫做 score 的變數是否及格（超過或剛好 60 分），如果及格的話就輸出 pass，否則輸出 fail。<br>進階練習：<br>除了判斷是否及格以外，也請你對滿分做出特別判斷，如果是 100 分的話就輸出 you are no1!</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pass</span>(<span class="params">score</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (score &lt; <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'不及格，但沒關係，再接再厲！'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score === <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你真是好棒棒！'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">100</span> || score &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'咦，沒這樣的分數耶'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> score !== <span class="built_in">Number</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'輸入的不是數字型態'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'恭喜，及格了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">pass(<span class="number">100</span>); <span class="comment">// 程式內是用 console.log，所以呼叫函式時就不需用 console.log</span></span><br></pre></td></tr></table></figure><h3 id="練習二：BMI-計算"><a href="#練習二：BMI-計算" class="headerlink" title="練習二：BMI 計算"></a>練習二：BMI 計算</h3><p>假設體重是 70，身高是 180(1.8m)，BMI 就是 70/(1.8*1.8) = 21。<br>現在請你寫出一個簡單的 BMI 計算器，用兩個變數代表體重跟身高，算出 BMI 之後判斷 BMI 是落在哪個範圍內並輸出相對應的字串。<br>體重過輕：BMI &lt; 18.5<br>正常範圍：18.5 &lt;= BMI &lt; 24<br>過重：24 &lt;= BMI &lt; 27<br>輕度肥胖：27 &lt;= BMI &lt; 30<br>中度肥胖：30 &lt;= BMI &lt; 35<br>重度肥胖：35 &lt;= BMI</p><p>這題原本做時一直多一個 undefined ，後來請教 hu 大才理解，console.log() 是印出，return 是回傳，印出是印出、回傳是回傳。如果在程式裡使用 console.log()，那麼呼叫程式時就不需用 console.log()，如果程式內是用 return 那麼呼叫函式時就要用 console.log() 來印出在螢幕上。<br>一般建議用 return ，function 裡面不要出現 console.log 讓程式保持乾淨。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testBMI2</span>(<span class="params">weight, height</span>) </span>&#123;</span><br><span class="line">  height = height * <span class="number">0.01</span>;</span><br><span class="line">  <span class="keyword">var</span> bmi = weight / (height * height);</span><br><span class="line">  bmi = <span class="built_in">parseFloat</span>(bmi).toFixed(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bmi &lt; <span class="number">18.5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'BMI為：'</span> + bmi + <span class="string">' 您的體重過輕'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bmi &gt;= <span class="number">18.5</span> &amp;&amp; bmi &lt; <span class="number">24</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'BMI為：'</span> + bmi + <span class="string">' 您的體重正常'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bmi &gt;= <span class="number">24</span> &amp;&amp; bmi &lt; <span class="number">27</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'BMI為：'</span> + bmi + <span class="string">' 您的體重過重'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bmi &gt;= <span class="number">27</span> &amp;&amp; bmi &lt; <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'BMI為：'</span> + bmi + <span class="string">' 您的體重為輕度肥胖'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bmi &gt;= <span class="number">30</span> &amp;&amp; bmi &lt; <span class="number">35</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'BMI為：'</span> + bmi + <span class="string">' 您的體重過輕為中度肥胖'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bmi &gt;= <span class="number">35</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'BMI為：'</span> + bmi + <span class="string">' 您的體重過輕為重度肥胖'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'輸入資料不正確'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(testBMI2(<span class="string">'s'</span>, <span class="number">162</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS101 </tag>
            
            <tag> ExerciceJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SASS 環境部署與基礎</title>
      <link href="/tsuifei.github.io/SASS_deployment-environment-and-fundamental/"/>
      <url>/tsuifei.github.io/SASS_deployment-environment-and-fundamental/</url>
      
        <content type="html"><![CDATA[<h2 id="SASS-重點"><a href="#SASS-重點" class="headerlink" title="SASS 重點"></a>SASS 重點</h2><ul><li>Variables 變數</li><li>Nesting 巢狀</li><li>Partials / Imports</li><li>Functions &amp; Mixins 函式 &amp; 巢狀</li><li>Conditionale 條件式</li><li>Operators &amp; Calculations 必較與計算子</li><li>Color Functions 顏色函式<a id="more"></a><h2 id="使用-NodeJs-佈署-SASS-環境"><a href="#使用-NodeJs-佈署-SASS-環境" class="headerlink" title="使用 NodeJs 佈署 SASS 環境"></a>使用 NodeJs 佈署 SASS 環境</h2></li></ul><h3 id="在資料夾裡面安裝-SASS-編譯器：node-sass"><a href="#在資料夾裡面安裝-SASS-編譯器：node-sass" class="headerlink" title="在資料夾裡面安裝 SASS 編譯器：node sass"></a>在資料夾裡面安裝 SASS 編譯器：node sass</h3><p>1.先確認有安裝 npm 2.輸入 <code>npm init -y</code> 初始化並給予預設值 3.檔案夾裡會有一個自動生成的 package.json 4.在終端機安裝 node sass ：<code>npm install node-sass</code> 5.在檔案夾裡會生成 node_modules，同時在 package.json 裡也會自動增加 node-sass 的版本號 6.打開它修改預設檔案生成位置，修改 script，將 test 拿掉，改成：<br><code>&quot;sass&quot;: &quot;node-sass -w scss/ -o dist/css/ --recursive&quot;</code><br>-w 監控 scss 檔案夾，-o output 編譯輸出至 dist/css 這個檔案夾。 7.至根目錄，增加 scss 和 dist 等檔案夾，並在 scss 檔案夾裡增加 scss 檔案：<code>main.scss</code> 8.先在終端機執行 <code>npm run sass</code> 指令，啟動 sass 監聽 9.在 <code>main.scss</code>寫些簡單的 sass，儲存後，會顯示編譯完成，並且在 dist 自動生成 css 檔案夾和<code>main.css</code>。 10.想退出監聽模式可 <code>control + c</code> 結束監聽。</p><p>(6)也可加入其他參數</p><p>啟動監聽後，在每次更新存檔時會自動更新網頁，如有修改後網頁沒變化，可跳出 sass 再重啟，通常可解決此問題。</p><h2 id="SASS-變數"><a href="#SASS-變數" class="headerlink" title="SASS 變數"></a>SASS 變數</h2><p>將變數統一整理到 <code>_variables.scss</code> 裡，並在<code>main.scss</code> 裡以<code>@import &#39;variables&#39;</code> 引入。<br>常用的變數名：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$primary-color</span></span><br><span class="line"><span class="variable">$secondary-color</span></span><br><span class="line"><span class="variable">$light-color</span></span><br><span class="line"><span class="variable">$dark-color</span></span><br><span class="line"><span class="variable">$font-stack</span></span><br></pre></td></tr></table></figure><h2 id="SASS-自帶的函式"><a href="#SASS-自帶的函式" class="headerlink" title="SASS 自帶的函式"></a>SASS 自帶的函式</h2><p>lighten(顏色;百分比); sass 會自動計算顏色深淺。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$primary-color</span>:<span class="number">#00cc99</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">  background_color:lighten(<span class="variable">$primary-color</span>, <span class="number">45%</span>); <span class="comment">/* 自動計算顏色變淺 */</span></span><br><span class="line">&#125;</span><br><span class="line">darken(<span class="variable">$primary-color</span>, 15%);</span><br><span class="line"><span class="comment">/* 自動計算顏色變深 */</span></span><br></pre></td></tr></table></figure><h2 id="SASS-巢狀"><a href="#SASS-巢狀" class="headerlink" title="SASS 巢狀"></a>SASS 巢狀</h2><p>在 sass 的巢狀結構裡，我們可以使用更簡潔的方式來表示結構：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;section class=&quot;section section-a&quot;&gt;</span><br><span class="line">    &lt;h2&gt;Hello Paris&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit.&lt;/p&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">  &lt;section class=&quot;section section-b&quot;&gt;</span><br><span class="line">    &lt;h2&gt;Hello taipei&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit.&lt;/p&gt;</span><br><span class="line">  &lt;/section&gt;</span><br></pre></td></tr></table></figure><p>scss 可以用巢狀的<code>&amp;-a</code>表示是指向哪一個<code>section</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.section</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;-<span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$light-color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;-<span class="selector-tag">b</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$secondary-color</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$light-color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==要避免過度巢狀，多用在偽元素、狀態、hover…。==<br>例 : &amp;:hover { … ; &amp;.active { … ; &amp;:after { …</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  backgroung-<span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    backgroung-<span class="attribute">color</span>: darken(<span class="variable">$primary-color</span>, <span class="number">15%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;<span class="selector-class">.active</span> &#123;</span><br><span class="line">    backgroung-<span class="attribute">color</span>: darken(<span class="variable">$primary-color</span>, <span class="number">15%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mixin-精華"><a href="#Mixin-精華" class="headerlink" title="Mixin 精華"></a>Mixin 精華</h2><p>使用情境，按鈕很多想做不同色彩。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$primary-color</span>: <span class="number">#00cc99</span>;</span><br><span class="line"><span class="keyword">@mixin</span> btnColor(<span class="variable">$color</span>) &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$color</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: darken(<span class="variable">$color</span>, <span class="number">15%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 創見一個btn 並用傳入的顏色給予背景色 */</span></span><br><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> btnColor(<span class="variable">$primary-color</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Extend"><a href="#Extend" class="headerlink" title="Extend"></a>Extend</h2><p>Sass 的 @extend 可以將相同的樣式整理在一起，在其他語言來說是非常帥氣的技法，但在 CSS 中請警慎使用。</p><p>OOCSS 概念，在撰寫 CSS 時要盡可能符合兩個原則，==結構與樣式分離、容器與內容分離==，所以到這邊為止還是要貫徹這個概念，當使用 @extend 時如果會造成這個缺陷時，請避免使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;btn-light&quot;&gt;Read more&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;btn-dark&quot;&gt;Read more&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%btn-read-more &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.27rem</span> <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  &amp;-light &#123;</span><br><span class="line">    <span class="keyword">@extend</span> %btn-read-more;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$light-color</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$dark-color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;-dark &#123;</span><br><span class="line">    <span class="keyword">@extend</span> %btn-read-more;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$dark-color</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$light-color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果認為以上寫法較容易導致混亂，也可寫成這樣：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn-light</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %btn-read-more;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$light-color</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$dark-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-dark</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %btn-read-more;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$dark-color</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$light-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mixin-amp-Extend-比較與應用"><a href="#Mixin-amp-Extend-比較與應用" class="headerlink" title="Mixin &amp; Extend 比較與應用"></a>Mixin &amp; Extend 比較與應用</h2><p>究竟 Mixin 與 extend 的使用時機該如何抉擇？基本上來說，<br>@mixin 是將程式碼帶入到對應的 class 去，同時可帶入變數。<br>@extend 則是藉由 class 合併，並吃到共通樣式，但==無法帶入變數==。<br><a href="https://ithelp.ithome.com.tw/articles/10128359" target="_blank" rel="noopener">30 天掌握 Sass 語法 - (7)利用 Sass「@extend」，讓你無痛合併 CSS 樣式</a></p><h2 id="運算式："><a href="#運算式：" class="headerlink" title="運算式："></a>運算式：</h2><p>會先乘除、後加減</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$width: 200px;</span><br><span class="line">$height: 400px;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: $width / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">height</span>: ($height - <span class="number">4</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Function-函式"><a href="#Function-函式" class="headerlink" title="Function 函式"></a>Function 函式</h2><p>可自創函式來處理許多繁瑣的事，例如自動辨別在深色底使用淺色字，反之，或是需要前贅詞讓瀏覽器相容的部份，也可一併用 function 處理。<br>方法：產生<code>_functions</code> 再以<code>@import</code>在主 scss 裡引入。<br>例一：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _functions</span></span><br><span class="line"><span class="comment">// Set Text Color 自動偵測字體顏色該深or淺</span></span><br><span class="line"><span class="keyword">@function</span> set-text-color(<span class="variable">$color</span>) &#123;</span><br><span class="line">  <span class="keyword">@if</span> (lightness(<span class="variable">$color</span>) &gt; <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="keyword">@return</span> <span class="number">#000</span>;</span><br><span class="line">  &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="keyword">@return</span> <span class="number">#fff</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Transform mixin 轉換小動畫</span></span><br><span class="line"><span class="comment">// 因 css transform 最好有前贅詞讓瀏覽器相容，可統一整理在這裡就不需要每次都寫</span></span><br><span class="line"><span class="keyword">@mixin</span> transform(<span class="variable">$property</span>) &#123;</span><br><span class="line">  --webkit-<span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">  -ms-<span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.scss</span></span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  &amp;-light &#123;</span><br><span class="line">    <span class="keyword">@extend</span> %btn-read-more;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$light-color</span>;</span><br><span class="line">    <span class="attribute">color</span>: set-text-color(<span class="variable">$light-color</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hover 動畫效果</span></span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="keyword">@include</span> transform(rotate(-<span class="number">10deg</span>));</span><br><span class="line">      <span class="comment">// 讓背景變深或淺</span></span><br><span class="line">      <span class="attribute">background-color</span>: darken(<span class="variable">$light-color</span>, <span class="number">15%</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HSL function 是常用到的函式，HSL 是色彩學中的色相、明度、彩度。<a href="https://color.adobe.com/create/color-wheel/" target="_blank" rel="noopener">adobe 色相環</a></p><h2 id="規劃-Sass-結構-import-的用法"><a href="#規劃-Sass-結構-import-的用法" class="headerlink" title="規劃 Sass 結構 @import 的用法"></a>規劃 Sass 結構 @import 的用法</h2><p>@import 的的功用在於可以將 CSS 檔案進行切割，如果是單純要被匯入整合 Sass 檔，而並沒有要轉出成 CSS 檔案，在檔案名稱前面加個下底線『_』，例：_button.css 就不會被編譯了。</p><p>基本的設計：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> mixin //放置所有Sass全域變數與Mixin</span><br><span class="line">  <span class="keyword">@import</span> reset // reset.css</span><br><span class="line">  <span class="keyword">@import</span> extnd // 拿來合併樣式，都放<span class="keyword">@extend</span>用的檔案</span><br><span class="line">  <span class="keyword">@import</span> layout //共同框架</span><br><span class="line">  <span class="keyword">@import</span> index //首頁</span><br><span class="line">  <span class="keyword">@import</span> page //內頁</span><br><span class="line">  <span class="keyword">@import</span> xxx;</span><br></pre></td></tr></table></figure><p>@import 最前面先放全域變數與 ==mixin==，原因是因為前面@import 有寫到變數的地方找不到值，所以自然系統沒辦法編譯出來。</p><p>接著 ==reset== 檔案，<br>網頁排版須先將所有瀏覽器預設樣式都統一，所以用 reset 統一。放在 mixin 前或後沒有差，因 mixin 都是變數而已，可以依照自己習慣放置。但也可能會在 reset 裡面導入全域變數，所以放第二有它的道理。</p><p>@extend 與@mixin 並不會實際產生 code，只有呼叫才會合併與匯出</p><p>第三個 ==extend== 是拿來合併 css 樣式用的，在設計網頁時，會發現有些樣式應可以抽出來進行合併動作，所以就會統一放在要合併的位置，就統一來放置@extend 的語法。</p><p>==layout== 是網頁版型的共通設計，也就是無論哪一頁都會有的樣式，如：表頭、表尾<br>接著是不同頁面性質與區塊的分割，==index== 首頁、==page== 內頁，依單元數量視情況來切割，Sass @import 的主要用就是希望你可以把 CSS 進行切割，這樣在編輯 CSS 時就可以聚焦於某功能來進行瀏覽，將檔案歸類完善，找 CSS 相對也會方便許多。</p><h3 id="國外-Sass-Way-介紹的-Sass-結構"><a href="#國外-Sass-Way-介紹的-Sass-結構" class="headerlink" title="國外 Sass Way 介紹的 Sass 結構"></a>國外 Sass Way 介紹的 Sass 結構</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stylesheets/</span><br><span class="line">|</span><br><span class="line">|-- modules/              # Common modules</span><br><span class="line">|   |-- _all.scss         # Include to get all modules 將所有 modules 引入到這裡(A)</span><br><span class="line">|   |-- _utility.scss     # Module name</span><br><span class="line">|   |-- _colors.scss      # Etc...</span><br><span class="line">|   ...</span><br><span class="line">|</span><br><span class="line">|-- partials/             # Partials</span><br><span class="line">|   |-- _base.sass        # imports for all mixins + global project variables 將所有 partials 引入到這裡(B)</span><br><span class="line">|   |-- _buttons.scss     # buttons</span><br><span class="line">|   |-- _figures.scss     # figures</span><br><span class="line">|   |-- _grids.scss       # grids</span><br><span class="line">|   |-- _typography.scss  # typography</span><br><span class="line">|   |-- _reset.scss       # reset</span><br><span class="line">|   ...</span><br><span class="line">|</span><br><span class="line">|-- vendor/               # CSS or Sass from other projects</span><br><span class="line">|   |-- _colorpicker.scss</span><br><span class="line">|   |-- _jquery.ui.core.scss</span><br><span class="line">|   ...</span><br><span class="line">|</span><br><span class="line">`-- main<span class="selector-class">.scss</span>            # primary Sass file 將(<span class="selector-tag">A</span>)、(<span class="selector-tag">B</span>) 引入這裡，與其他的partials</span><br></pre></td></tr></table></figure><p>此份規劃的 Sass 架構還有分資料夾，將各類功能與模組分得更細：<br>==modules== 主要是放各種元素的模組，<br>== partials== 則是放置主結構的 CSS，<br>== vendor==則是統一放別人寫好的 Sass Framework，<br>所以 Sass 的主檔案就會這樣子去寫@import：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modules and Variables</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">'partials/base'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partials</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">'partials/reset'</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">'partials/typography'</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">'partials/buttons'</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">'partials/figures'</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">'partials/grids'</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Third-party</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">'vendor/colorpicker'</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">'vendor/jquery.ui.core'</span>;</span><br></pre></td></tr></table></figure><h3 id="組件化的變數抽離"><a href="#組件化的變數抽離" class="headerlink" title="組件化的變數抽離"></a>組件化的變數抽離</h3><p>在每一個區塊的 sass 裡，雖然已經使用了引入的變數，但為了組件的可重複性，也就是說，例如 header 或 footer 可以拿去給別的專案用，就可以再把每個 sass 裡的變數提取出來，以便日後只要改最上頭的變數列表即可。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$footer_font_color</span>: lighten(<span class="variable">$dark-color</span>, <span class="number">15%</span>);</span><br><span class="line"><span class="variable">$footer_background_color</span>: darken(<span class="variable">$light-color</span>, <span class="number">15%</span>);</span><br><span class="line"><span class="variable">$footer_link_color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$footer_font_color</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2rem</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$footer_background_color</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="variable">$font-base</span>;</span><br><span class="line">  <span class="selector-class">.link</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$footer_link_color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="參考網站"><a href="#參考網站" class="headerlink" title="參考網站"></a>參考網站</h2><p><a href="https://sass-lang.com/guide" target="_blank" rel="noopener">SASS 官網</a> | <a href="https://paper.dropbox.com/doc/Sass-Bootstrap--AepLvl6rTzh_ryoWRR5ADMXtAg-yuK4SQmHw4CzC96uX8ylZ" target="_blank" rel="noopener">六角筆記 範例</a><br><a href="https://dwatow.github.io/2018/03-12-node-sass/" target="_blank" rel="noopener">node-sass 初探 - 《Chris 技術筆記》</a><br><a href="https://hackmd.io/vgVp2KlzR6mYQvLu74wvgw" target="_blank" rel="noopener">Askie 筆記</a> | <a href="https://hackmd.io/ZMQqAUxBQzGLuuw0en8MBA" target="_blank" rel="noopener">初見 SCSS 一天開竅起手式</a><br><a href="https://www.codecademy.com/learn/learn-sass" target="_blank" rel="noopener">線上課程</a> | <a href="https://www.kancloud.cn/kancloud/sass-guidelin/" target="_blank" rel="noopener">簡中查閱</a> | <a href="https://medium.com/@chihsuan/%E5%A6%82%E4%BD%95%E5%AF%AB%E5%87%BA%E6%9B%B4%E5%A5%BD%E7%9A%84-css-scss-%E7%A8%8B%E5%BC%8F%E7%A2%BC-bab4396b1a01" target="_blank" rel="noopener">如何寫出更好的 CSS/SCSS 程式碼？</a> | <a href="https://www.youtube.com/watch?v=mgZRZ91h5yk&t=12s" target="_blank" rel="noopener">Sass 基礎運用介紹</a><br><a href="https://www.youtube.com/watch?v=FVx8WvZQV10" target="_blank" rel="noopener">六角學院 - SASS 之 @function、@extend、@mixin</a> | <a href="https://wcc723.github.io/sass/2013/08/26/sass-hsl-funtion/" target="_blank" rel="noopener">卡斯柏 Sass HSL function</a><br><a href="https://www.udemy.com/modern-html-css-from-the-beginning/learn/lecture/13875728#overview" target="_blank" rel="noopener">Udemy Modern HTML &amp; CSS From The Beginning (Including Sass)</a></p>]]></content>
      
      
      <categories>
          
          <category> SASS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> SASS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 迴圈 Loop 裡的 return</title>
      <link href="/tsuifei.github.io/JS_Return-in-the-loop/"/>
      <url>/tsuifei.github.io/JS_Return-in-the-loop/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>可能在 42 學 C 的時候，學校規定只能用 while 迴圈，所以已經習慣 While 一行行跑的步驟，自從開始用 for 之後，雖然碼比較簡潔，但自己千萬沒想到對它的誤解這磨深…..。以為是只要條件符合就直接 i++ 了，但其實並不是！！是如果條件符合，會先去跑我們要叫它做的事，然後再 i++ 。視覺上看是條件符合後就 i++ 是個大雷，切記。<br>==也就是說只要條件符合＋ return，就會跳出 loop==</p><a id="more"></a><p>[ 第一題 ]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test1()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>而 while 迴圈的寫法，真的就一行行跑，i &lt;= 10 條件符合再去做該做的事，做完該做的事再 i++ ，但當我們回傳時就會終止程式，當然也就不會跑下一行 i++</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test2()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>==很重要，所以再說一次==</p><h3 id="注意一旦-return-程式就會因-return-而終止跳出程式"><a href="#注意一旦-return-程式就會因-return-而終止跳出程式" class="headerlink" title="注意一旦 return 程式就會因 return 而終止跳出程式"></a>注意一旦 return 程式就會因 return 而終止跳出程式</h3><p>這題的結果是回傳 123 便終止結束<br>[ 第二題 ]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==很重要，所以再說一次==</p><h3 id="一旦-return-程式就會因此終止跳出程式，if-也是"><a href="#一旦-return-程式就會因此終止跳出程式，if-也是" class="headerlink" title="一旦 return 程式就會因此終止跳出程式，if 也是"></a>一旦 return 程式就會因此終止跳出程式，if 也是</h3><p>[ 第三題 ]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">3</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test());</span><br></pre></td></tr></table></figure><p>這題回傳是 3 ，即使條件是 i &lt;= 10 ，但遇到( i % 3 === 0 ) 3 除 3 無餘數就回傳 i ，程式因此終止。<br>第 1 圈 i=1 除 3= 有餘數 no return i++ = i=2<br>第 2 圈 i=2 除 3= 有餘數 no return i++ = i=3<br>第 3 圈 i=3 除 3= 無餘數 return i = 3 結束</p><p>[ 第四題 ]<br>經過上三題的觀念釐清，這題總算試著用腦袋跟著程式跑而猜出會跑出 6 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">5</span> &amp;&amp; i % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test());</span><br></pre></td></tr></table></figure><p>huli 大好用心，這幾題就是要釐清 return 扮演的角色：回傳值後 離開！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JS Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 三元運算符(ternary conditional operator)與比較運算符(Comparison operator)</title>
      <link href="/tsuifei.github.io/JS_ternary-conditional-operator-and-Comparison-operator/"/>
      <url>/tsuifei.github.io/JS_ternary-conditional-operator-and-Comparison-operator/</url>
      
        <content type="html"><![CDATA[<h2 id="相等比較運算-與-的不同"><a href="#相等比較運算-與-的不同" class="headerlink" title="相等比較運算 == 與 === 的不同"></a>相等比較運算 == 與 === 的不同</h2><p>兩個等號通常是拿來比較兩邊的==值==是否不同<br>三個等號除了判斷==值==是否相同，也會判斷==型別==是否相同。</p><p>兩個等於會引發諸多問題的原因是 JS 常會暗地裡幫我們將資料轉型別，所以常常莫名的就通過判斷。以至於很容易就會出現誤判型別而導致出現錯誤。在使用判斷比較時盡量或只使用三個等於會比較精確與安全。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下的結果都是true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> == <span class="string">'0'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span> == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> == <span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span> == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> == <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> == <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log([] == <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>產生 1 == true 的原因是在 Boolean 時，1 即表示 true，也就是 Boolean(1)理所當然 JS 就會把它視為相同。相反地 Boolean(0) 等於 false.</p><p>如果將 false 轉成數字型 Number(false) // 0 ，也可得到 0。</p><p>空字串也是如此，當我們把空字串轉成數字時 Number([]) // 0 也會得到 0。</p><p>將所有上述比較全換成三個等號，結果全都成了 false：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下的結果都是 false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> === <span class="string">'0'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span> === <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> === <span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span> === <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> === <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> === <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> === <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> === <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log([] === <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>由此可見，用三個等號來判斷兩變得值，還是比較準確與保險。看圖表來表示更清楚！三個等號比兩個等號規律多了，除非可以全背下兩個等號的變化，不然還是用三個等號來判斷比較保險。</p><p><img src="https://i.imgur.com/f0T10zg.png" alt></p><p><img src="https://i.imgur.com/6eGZaB8.png" alt></p><p><img src="https://i.imgur.com/b2Iyiqw.png" alt></p><h3 id="唯一特例-NaN-不是-NaN"><a href="#唯一特例-NaN-不是-NaN" class="headerlink" title="唯一特例 NaN 不是 NaN"></a>唯一特例 NaN 不是 NaN</h3><p>在 JavaScript 裡如果左右兩邊都是一樣且用三個等號來比較，結果通常是 True 但是 Nan 和自己相比，無論使用兩個或三個等號都是 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> !== <span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lettre = <span class="string">'abc'</span>;</span><br><span class="line">lettre / <span class="number">10</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>NaN -&gt; 不是數字。何時會用到 NaN ?<br>如果把數字和不是數字做運算，便會返回 NaN 。</p><p>如果想知道一個變數是不是 NaN 可使用 <code>isNaN()</code> 來判斷是不是 NaN。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是<code>isNaN()</code>也會悄悄幫你改型別。 明明 a 就不是數字…。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'a'</span>;</span><br><span class="line"><span class="built_in">isNaN</span>(a); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>(a); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果用 typeof 來看 NaN 會得到 number，也就是說，當我們用 isNaN() ，其實這個函式會先將()裡面用 Number()轉換。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>圖表出處：<a href="https://dorey.github.io/JavaScript-Equality-Table/" target="_blank" rel="noopener">一目了然的比較表</a></p><h2 id="JS-三元運算子"><a href="#JS-三元運算子" class="headerlink" title="JS 三元運算子"></a>JS 三元運算子</h2><p>「三元運算子」 又稱為「條件運算子」，也就是拿來處理條件判斷用的。<br>條件成立(true)-&gt; 回傳第一個, 條件不成立(false)-&gt;回傳第二個</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 true 這個條件成立，就返回 100，否則就回傳 50</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">100</span> &lt; <span class="number">1000</span> ? <span class="number">100</span> : <span class="number">50</span>;</span><br><span class="line"><span class="comment">// 100 小於 1000 嗎？ 是 (true) -&gt; 回傳 100</span></span><br></pre></td></tr></table></figure><p>如何將一般的 if else 轉成三元運算子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">var</span> title;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (age &gt;= <span class="number">45</span>) &#123;</span><br><span class="line">    title = <span class="string">'Middle-aged'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    title = <span class="string">'Adult'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  title = <span class="string">'Minor'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(title);</span><br></pre></td></tr></table></figure><p>三元運算子較簡短，但可讀性不高，應避免使用可讀性不高的寫法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title = age &gt;= <span class="number">18</span> ? (age &gt;= <span class="number">45</span> ? <span class="string">'Middle-aged'</span> : <span class="string">'Adult'</span>) : <span class="string">'Minor'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(title);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 複製 By reference 與 By value 的不同</title>
      <link href="/tsuifei.github.io/JS_%E8%A4%87%E8%A3%BDBy-reference%E8%88%87By-value%E7%9A%84%E4%B8%8D%E5%90%8C/"/>
      <url>/tsuifei.github.io/JS_%E8%A4%87%E8%A3%BDBy-reference%E8%88%87By-value%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<p>在實作時常會聽到 call by reference 還是 call by value，這兩個有什麼不同？最簡易的解釋方法是：<br>call by reference : 呼叫變數的記憶體位置<br>call by value : 呼叫變數的值</p><p>事實上除了這兩種，還有一種叫 call by Sharing，在傳遞參數時會用到，之後再來介紹。</p><a id="more"></a><h3 id="Object-物件-Object-Array"><a href="#Object-物件-Object-Array" class="headerlink" title="Object(物件): Object, Array"></a>Object(物件): Object, Array</h3><p>Objet 和 Array 在 Javascript 屬於複合型(composite)或參考型(reference)的原始資料類型，<br>在呼叫、複製或傳參數的時候，是參考記憶體的位置而不是值，這點要特別注意。</p><h3 id="複製資料的時候"><a href="#複製資料的時候" class="headerlink" title="複製資料的時候"></a>複製資料的時候</h3><p>複製資料的時候 是用 By valur 或是 By reference 呢？</p><h4 id="By-valur"><a href="#By-valur" class="headerlink" title="By valur"></a>By valur</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'something'</span>;</span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// 這時 b 應該是 something</span></span><br><span class="line">b = <span class="string">'somebody'</span>; <span class="comment">// 再次將其他值賦予給 b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// something</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// somebody</span></span><br></pre></td></tr></table></figure><p>a 和 b 如期的印出我們賦予的值。我們可成功無誤的修改 b 的值。</p><p>Primitive type(基本型別)：Number, String, Boolean, Null, Undefined</p><h4 id="By-reference-參考值"><a href="#By-reference-參考值" class="headerlink" title="By reference(參考值)"></a>By reference(參考值)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Tracy'</span>,</span><br><span class="line">  city: <span class="string">'Tainan'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = person;</span><br><span class="line">person2.name = <span class="string">'Philippe'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// name: "Philippe"</span></span><br><span class="line"><span class="built_in">console</span>.log(person2); <span class="comment">// name: "Philippe"</span></span><br></pre></td></tr></table></figure><p>上面的範例在修改 person2 這個 object 裡的 name 屬性時，也會同時改到原來參考的 person 的 name 屬性，是不是很恐怖？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 陣列</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1;</span><br><span class="line">arr2[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>因為 Array 也是參考型(reference)的原始資料類型所以也會像 Object 一樣，在修改時也會更改到原始參考值 by reference。</p><p>如何複製一個物件而不要更動到參考值？以下是方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Jacques"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法一-使用-assign：先給一個空-來裝複製過來的物件"><a href="#方法一-使用-assign：先給一個空-來裝複製過來的物件" class="headerlink" title="方法一 使用 assign：先給一個空{} 來裝複製過來的物件"></a>方法一 使用 assign：先給一個空{} 來裝複製過來的物件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.saaign(&#123;&#125;, person);</span><br></pre></td></tr></table></figure><h3 id="方法二-使用-JSON-文字化"><a href="#方法二-使用-JSON-文字化" class="headerlink" title="方法二 使用 JSON 文字化"></a>方法二 使用 JSON 文字化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(person));</span><br><span class="line"><span class="comment">// 這時兩筆資料已無關連</span></span><br><span class="line">person2.name = <span class="string">'Gisèle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name:"Jacques"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person2); <span class="comment">// &#123;name:"Gisèle"&#125;</span></span><br></pre></td></tr></table></figure><p>JSON.stringify(); 是文字化、JSON.parse(); 是解析文字，兩函式處理下來等於複製了一份 person 到 person2</p><h3 id="使用-Object-assign-處理-object-的缺點"><a href="#使用-Object-assign-處理-object-的缺點" class="headerlink" title="使用 Object.assign()處理 object 的缺點"></a>使用 Object.assign()處理 object 的缺點</h3><p>如果遇上多層結構的 Object，就無法使用 assign()來處理，因為它只能處理一層的結構而無法處理兩層，也就是說這種方法只能用在 Array 上。在第二層裡的原始資料仍然會被更動到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Ayda'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    id: <span class="number">24</span>,</span><br><span class="line">    city: <span class="string">'Paris'</span>,</span><br><span class="line">    job: <span class="string">'artist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.assign(&#123;&#125;, person);</span><br><span class="line">person2.data.id = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(person2); <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改成用第二種方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(person));</span><br><span class="line">person3.data.id = <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// 42,原本 24 被Object.assign()改成 42</span></span><br><span class="line"><span class="built_in">console</span>.log(person3); <span class="comment">// 66</span></span><br></pre></td></tr></table></figure><p>function 也是一種特殊的 Object 資料型別。<br>參考：<a href="https://hackmd.io/m0alSWZBQ4aKROtyQVeejw?view" target="_blank" rel="noopener">小龜前輩：參數傳遞方式</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git / GitHub 實際操作</title>
      <link href="/tsuifei.github.io/Git-GitHub-%E5%AF%A6%E9%9A%9B%E6%93%8D%E4%BD%9C/"/>
      <url>/tsuifei.github.io/Git-GitHub-%E5%AF%A6%E9%9A%9B%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="在本地使用-git-版本控制"><a href="#在本地使用-git-版本控制" class="headerlink" title="在本地使用 git 版本控制"></a>在本地使用 git 版本控制</h2><h4 id="init-初始化"><a href="#init-初始化" class="headerlink" title="init 初始化"></a>init 初始化</h4><ul><li>在要使用版本控制的檔案夾裡輸入 init 初始化，以 ls -la 可看到隱藏的 .git  檔案夾</li><li>使用 git status 觀察版本狀態</li></ul><h4 id="git-add-加入版本控制檔案"><a href="#git-add-加入版本控制檔案" class="headerlink" title="git add 加入版本控制檔案"></a>git add 加入版本控制檔案</h4><ul><li>使用 git add [fileName] 加入要版本控制的檔案，或是使用 git add . 表示全部加入</li><li>使用 git status 會發現有兩區域： staged (加入)/ untracked (沒加入)版本控制，可使用 git rm —cached [fileName] 將已加入的檔案移出至 untracked。</li><li>要 add 才能 commit<a id="more"></a></li></ul><h4 id="git-commit-新建一個版本"><a href="#git-commit-新建一個版本" class="headerlink" title="git commit 新建一個版本"></a>git commit 新建一個版本</h4><ul><li>使用 git commit 新建一個版本，或出 vim 文字編輯器 ( i insert / :q 退出)，會出現 commit 是空的(empty)訊息。</li><li>以 git commit -m  “[訊息]”<br>git commit 如出現錯誤，跳出設定帳號跟姓名的畫面，請輸入以下指令</li></ul><ol><li>git config –global user.name “your name”</li><li>git config –global user.email “youremail”</li></ol><h4 id="git-log-歷史紀錄"><a href="#git-log-歷史紀錄" class="headerlink" title="git log 歷史紀錄"></a>git log 歷史紀錄</h4><ul><li>使用 git log 會出現所有 commit 的歷史紀錄編號，q 離開 log</li></ul><h4 id="git-checkout-回到過去某個版本狀態"><a href="#git-checkout-回到過去某個版本狀態" class="headerlink" title="git checkout 回到過去某個版本狀態"></a>git checkout 回到過去某個版本狀態</h4><ul><li>使用 git log —online 會出現 commit 短版本列表，前 7 碼為版本簡碼，後面是 commit 時輸入的訊息。</li><li>使用 git checkout [版本碼] 即可回到要去的版本時間點，用 git log 觀察這個版本時間點之後的版本都會看不見。</li><li>使用 git checkout master 回去現在的時間點版本，再用 git log 觀察就可看到所有版本。</li></ul><h4 id="gitignore-忽略檔案"><a href="#gitignore-忽略檔案" class="headerlink" title=".gitignore 忽略檔案"></a>.gitignore 忽略檔案</h4><p>在檔案夾裡增加一個 .gitignore 檔案，裡面寫上不要加入版本控制裡的檔案，這樣 git 就不會每次提醒，例如連線資料、test、log 等系統自動產生的檔案。</p><ul><li>touch .gitignore 產生檔案</li><li>vim .gitignore 編輯檔案</li><li>Git commit -am “commit message” 可直接 add+commit 但只會加入曾經加入的，而不會加入新的檔案。所以每次有新檔案時最好使用 git add [fileName] 加入，或用 git add . 全部加入再 commit。</li></ul><h3 id="小筆記"><a href="#小筆記" class="headerlink" title="小筆記"></a>小筆記</h3><p>git checkout -b [分支名] 可直接開分支並切換過去<br>git -d [分支名] 把分支刪除<br>git diff 可看上一次做的變動，q 退出</p><h2 id="在本地端開分支-branch-–-gt-合併主版本-merge"><a href="#在本地端開分支-branch-–-gt-合併主版本-merge" class="headerlink" title="在本地端開分支 branch –&gt; 合併主版本 merge"></a>在本地端開分支 branch –&gt; 合併主版本 merge</h2><h4 id="設分支-branch"><a href="#設分支-branch" class="headerlink" title="設分支 branch"></a>設分支 branch</h4><ul><li>用 git branch -v 看有哪些 branch 主分支為 master，也會顯示這支分支最後一個 commit</li><li>原本在 master，創另一個分支 ：git branch [分支名]</li><li>切換到那個分支：git checkout [分支名]</li><li>刪除分支：git branch -d [分支名]</li><li>切換分支 ：git checkout [分支名]</li><li>用 git branch -v 查看現在在哪個分支(顯示綠色)</li></ul><h3 id="merge-branch-to-master-將分支合併到主支幹"><a href="#merge-branch-to-master-將分支合併到主支幹" class="headerlink" title="merge branch to master 將分支合併到主支幹"></a>merge branch to master 將分支合併到主支幹</h3><ul><li>git [分支] merge : 把某一分支合併過來 master</li><li>git branch -d [分支] : 合併後即可把原本的分支刪除</li></ul><h4 id="合併時發生衝突-conflict"><a href="#合併時發生衝突-conflict" class="headerlink" title="合併時發生衝突 conflict"></a>合併時發生衝突 conflict</h4><ul><li>主支和分支同時修改時，分支要合併至主支時，會產生  auto-merging [fileName] CONFLICT (content) : Merge conflict in [fileName] automatic merge failed; fix conflicts and then commit the result.</li><li>用 git status 查看會以 both modified : [fileName] 顯示有問題的檔案</li><li>進入有問題的 [fileName] 手動修改，=====為兩版本分隔，&lt;&lt;&lt;&lt;&lt; [分支名]。將其中一個刪除與更正存檔，再 commit 一次，再合併。</li><li>git status 顯示 resolve conflicts 表示衝突解決。</li></ul><h4 id="注意-小觀念"><a href="#注意-小觀念" class="headerlink" title="注意 + 小觀念"></a>注意 + 小觀念</h4><p>Git : 版本控制的程式<br>GitHub : 放 git repository 的存儲庫<br>有用 git 不一定要用 GitHub，但用 GitHub 就一定要會用到 git<br>忘記切回 test 分支，所以後來無法順利 merge 到 master 分支，雖然後來看似解決，但還真不知道自己是怎麼解決的，就是試了幾個間，跟著打就好了．．．這樣其實有點可怕，下次再注意！</p><h2 id="把本地端-code-放上-GitHub"><a href="#把本地端-code-放上-GitHub" class="headerlink" title="把本地端 code 放上 GitHub"></a>把本地端 code 放上 GitHub</h2><h3 id="Create-a-new-repository-在-github-開一個新的存儲庫"><a href="#Create-a-new-repository-在-github-開一個新的存儲庫" class="headerlink" title="Create a new repository 在 github 開一個新的存儲庫"></a>Create a new repository 在 github 開一個新的存儲庫</h3><ul><li>填入 Repository name 和 Description，就好有使用技術關鍵字</li><li>選擇 Public 或 Private</li><li>Initialize this repository whit a README 可以先不選</li><li>Add .gitignore 和 a license 都選預設 None</li></ul><h4 id="方法ㄧ-在本地端還沒有-code-可使用這種方法"><a href="#方法ㄧ-在本地端還沒有-code-可使用這種方法" class="headerlink" title="方法ㄧ) 在本地端還沒有 code 可使用這種方法"></a>方法ㄧ) 在本地端還沒有 code 可使用這種方法</h4><p>…or create a new repository on the command line<br>echo “# github.io-“ &gt;&gt; README.md<br>git init<br>git add README.md<br>git commit -m “first commit”<br>git remote add origin [<a href="https://github.com/tsuifei/倉庫位址.git]" target="_blank" rel="noopener">https://github.com/tsuifei/倉庫位址.git]</a><br>git push -u origin master</p><h4 id="方法二-在本地端已經有-code-用這種把-code-push-到-github-的方法。"><a href="#方法二-在本地端已經有-code-用這種把-code-push-到-github-的方法。" class="headerlink" title="方法二) 在本地端已經有 code 用這種把 code push 到 github 的方法。"></a>方法二) 在本地端已經有 code 用這種把 code push 到 github 的方法。</h4><p>…or push an existing repository from the command line<br>從本地 push 到遠端<br>git remote add origin [<a href="https://github.com/tsuifei/倉庫位址.git]" target="_blank" rel="noopener">https://github.com/tsuifei/倉庫位址.git]</a><br>git push -u origin master 把 code push 到 github 的這個 master 主支上   通常這之後會要你的 github 的帳號和密碼，有輸入才算與遠端相通   單字 : remote 遠端 / origin 代號<br>-u -&gt; set-upstream</p><h4 id="方法三-以引入的方式將-code-放進來"><a href="#方法三-以引入的方式將-code-放進來" class="headerlink" title="方法三) 以引入的方式將 code 放進來"></a>方法三) 以引入的方式將 code 放進來</h4><p>…or import code from another repository<br>You can initialize this repository with code from a Subversion, Mercurial, or TFS project.</p><h2 id="把本地端最新的版本推上-GitHub"><a href="#把本地端最新的版本推上-GitHub" class="headerlink" title="把本地端最新的版本推上 GitHub"></a>把本地端最新的版本推上 GitHub</h2><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><ul><li>本地端 : 把檔案 commit 之後， 使用 git push origin master 推到主支上</li><li>Github 端 : 重新整理頁面後 branch 會更新，commits 數量也會增加</li><li>如果只有 commit 沒 push，Github 端不會變動</li><li>可開分支 再 git push origin [分支名] ，再到 Github 端看就有兩個 branch</li></ul><h2 id="把-Github-端上最新版本-拉下本地端"><a href="#把-Github-端上最新版本-拉下本地端" class="headerlink" title="把 Github 端上最新版本 拉下本地端"></a>把 Github 端上最新版本 拉下本地端</h2><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><ul><li>先到要拉下來的位置</li><li>執行 git pull origin master</li><li>如有 conflict 可依上述 merge 的衝突解決方式處理。</li></ul><h2 id="把其他人-Github-端上的-code-拉下本地端"><a href="#把其他人-Github-端上的-code-拉下本地端" class="headerlink" title="把其他人 Github 端上的 code 拉下本地端"></a>把其他人 Github 端上的 code 拉下本地端</h2><h4 id="git-clone-42-就是用這種方法"><a href="#git-clone-42-就是用這種方法" class="headerlink" title="git clone (42 就是用這種方法)"></a>git clone (42 就是用這種方法)</h4><ul><li>先到要拉下來的位置</li><li>執行 git colne [<a href="https://github.com/tsuifei/倉庫位址.git]" target="_blank" rel="noopener">https://github.com/tsuifei/倉庫位址.git]</a> 可自行取名</li><li>git clone 之後可以 commit 因為在本地端，且專案是別人的，所以如果執行 push 會因無權限而無法執行</li></ul><h3 id="將別人的專案變成自己的"><a href="#將別人的專案變成自己的" class="headerlink" title="將別人的專案變成自己的"></a>將別人的專案變成自己的</h3><ul><li>使用 Fork 功能，再使用 clone 方式將專案拉下至本地端</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="直接在-Github-端-commit-修改檔案"><a href="#直接在-Github-端-commit-修改檔案" class="headerlink" title="直接在 Github 端 commit 修改檔案"></a>直接在 Github 端 commit 修改檔案</h3><ul><li>選要修改的檔案，按 icon 筆(Edit this file)</li><li>直接在檔案下方下 commit 選擇要 commit 的支，通常選(commit directly to the master branch)</li></ul><h2 id="Git-問題處理集合"><a href="#Git-問題處理集合" class="headerlink" title="Git 問題處理集合"></a>Git 問題處理集合</h2><h4 id="Git-提示-fatal-remote-origin-already-exists-錯誤解決辦法"><a href="#Git-提示-fatal-remote-origin-already-exists-錯誤解決辦法" class="headerlink" title="Git 提示 fatal: remote origin already exists 錯誤解決辦法"></a>Git 提示 fatal: remote origin already exists 錯誤解決辦法</h4><p>使用 git 上傳至遠程 github 倉庫的時候出現提示錯誤：fatal: remote origin already exists.<br>1、先刪除遠端 Git 倉庫<br>$ git remote rm origin</p><p>2、再增加遠端 Git 倉庫<br>$ git remote add origin [<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:遠端位址]</p><p>如果執行 git remote rm origin 有出現錯誤訊息的話，可以手動修改 gitconfig 文件的內容<br>$ vi .git / config<br>把[remote “origin”] 那一行刪掉就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git / GitHub練習心得</title>
      <link href="/tsuifei.github.io/git-github%E7%B7%B4%E7%BF%92%E5%BF%83%E5%BE%97/"/>
      <url>/tsuifei.github.io/git-github%E7%B7%B4%E7%BF%92%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>照著程式導師實驗計畫的操作，學會如何設置本端和遠端之間的更新與開分支，合併等方法，程序有點小複雜，但對於版本控管的確是輕度多了，只是還沒和其他人合作控管，這部分須多操控。<br>.gitignore 的設置在設 github 前就應該處理，不然之後刪來刪去很麻煩，記得不要上傳 node_modules/不然會很龐大。</p><a id="more"></a><h3 id="小筆記"><a href="#小筆記" class="headerlink" title="小筆記"></a>小筆記</h3><p>設分支練習：</p><ol><li>原本在 master，創另一個分支 ：git branch [分支名]</li><li>切換到那個分支：git checkout [分支名]</li><li>用 git status 查在哪個分支</li><li>用 git branch -v 看有哪些 branch</li><li>push 到新的 branch 上：git push origin [branch 名]</li></ol><h3 id="在-github-上-merge-合併："><a href="#在-github-上-merge-合併：" class="headerlink" title="在 github 上 merge 合併："></a>在 github 上 merge 合併：</h3><ol><li>在 github 上的標籤頁 pull requests 上點 Create pull request → 會顯示兩邊的不同</li><li>再點 Create pull request 之後，等 Merge pull request 出現，點下確認即可</li><li>Merge 後切換到 Master 就會看到更新結果。</li><li>用 git pull origin master 把已經 merge 好得檔案拉到本地端</li></ol><p>要改東西一定要新開 branch 再 merge 到 master 本支</p><blockquote><p>忘記切回 test 分支，所以後來無法順利 merge 到 master 分支，雖然後來看似解決，但還真不知道自己是怎麼解決的，就是試了幾個鍵，跟著打就好了．．．這樣其實有點可怕，下次再注意！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 回呼函式 Callbacks、Promises 物件、Async/Await 非同步流程控制</title>
      <link href="/tsuifei.github.io/JS_%E5%9B%9E%E5%91%BC%E5%87%BD%E5%BC%8F-Callbacks%E3%80%81Promises-%E7%89%A9%E4%BB%B6%E3%80%81Async-Await-%E9%9D%9E%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/tsuifei.github.io/JS_%E5%9B%9E%E5%91%BC%E5%87%BD%E5%BC%8F-Callbacks%E3%80%81Promises-%E7%89%A9%E4%BB%B6%E3%80%81Async-Await-%E9%9D%9E%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Javascript 近幾年來受歡迎的原因，有一大部分是因為 JS 可以處理非同步（異步）的問題，也因為可以非同步，所以處理速度快，且可帶給瀏覽者更好的體驗，所以了解如何控制非同步也成了前端重要的技能之一。</p><a id="more"></a><h2 id="無非同步的程式"><a href="#無非同步的程式" class="headerlink" title="無非同步的程式"></a>無非同步的程式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testNoAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// testNoAsync(); // 7</span></span><br></pre></td></tr></table></figure><h2 id="問題的起源，非同步程式"><a href="#問題的起源，非同步程式" class="headerlink" title="問題的起源，非同步程式"></a>問題的起源，非同步程式</h2><p>寫程式如果遇到要處理非同步的程式，就會變得複雜了起來，為什麼會複雜？<br>預設想要延遲執行，卻出現 undefined 程式會一直往下跑， return 的部分不會回傳會被忽略….。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedAdd0</span>(<span class="params">n1, n2, delayTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 設定排程，延遲一段時間後執行</span></span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">  &#125;, delayTime);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>); <span class="comment">// 仔細觀察出現的順序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = delayedAdd0(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 1, undefined, 2 (不會出現return結果)</span></span><br></pre></td></tr></table></figure><h2 id="第一個解決方式-callback-回呼函式"><a href="#第一個解決方式-callback-回呼函式" class="headerlink" title="第一個解決方式 : callback 回呼函式"></a>第一個解決方式 : callback 回呼函式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedAdd1</span>(<span class="params">n1, n2, delayTime, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// callback 函式</span></span><br><span class="line">  <span class="comment">// 設定排程，延遲一段時間後執行</span></span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 延遲一段時間，計算加法，呼叫callback函式</span></span><br><span class="line">    callback(n1 + n2);</span><br><span class="line">  &#125;, delayTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  delayedAdd1(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2000</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">test1(); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h2 id="第二個解決方式-Promise-物件"><a href="#第二個解決方式-Promise-物件" class="headerlink" title="第二個解決方式 : Promise 物件"></a>第二個解決方式 : Promise 物件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedAdd2</span>(<span class="params">n1, n2, delayTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 建立 Promise 物件 :  new promise(執行函式)</span></span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 兩個系統給的參數</span></span><br><span class="line">    <span class="comment">// 要做的工作放到promise的函式裡</span></span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(n1 + n2); <span class="comment">// 工作完成，呼叫 resolve 函式，並把結果透過參數傳遞進去，如果工作出現問題就呼叫 reject ex. reject(n1+n2);</span></span><br><span class="line">    &#125;, delayTime);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 把 promise 傳遞出來</span></span><br><span class="line">  <span class="keyword">return</span> p; <span class="comment">// 或直接以 return 去接以上的結果 回傳回去而不需要變數 p</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// resolve 會對應 .then / reject 會對應 .catch 但.catch可以忽略不寫</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise = delayedAdd2(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">  promise</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error'</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="需求-需要運行兩次的-promise-然後將結果相乘"><a href="#需求-需要運行兩次的-promise-然後將結果相乘" class="headerlink" title="需求: 需要運行兩次的 promise 然後將結果相乘"></a>需求: 需要運行兩次的 promise 然後將結果相乘</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise1 = delayedAdd2(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">let</span> promise2 = delayedAdd2(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="comment">// 多個 promise 都完成後才繼續工作.</span></span><br><span class="line">  <span class="comment">// 把 promises 放入陣列裡</span></span><br><span class="line">  <span class="built_in">Promise</span>.all([promise1, promise2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用 reduce() 處理相乘</span></span><br><span class="line">    <span class="keyword">let</span> answer = results.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total, value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> total * value;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(answer);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">test2a();</span><br></pre></td></tr></table></figure><h2 id="第三個解決方式-使用-Async-Await-簡化-Promise-。"><a href="#第三個解決方式-使用-Async-Await-簡化-Promise-。" class="headerlink" title="第三個解決方式 : 使用 Async/Await 簡化 Promise 。"></a>第三個解決方式 : 使用 Async/Await 簡化 Promise 。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Async/Await 背後的邏輯就是和 Promise 是一樣的。</span></span><br><span class="line"><span class="comment">// 使用 Async/Await 的大前提是仍要建立一個 Promise 物件 將它回傳</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedAdd3</span>(<span class="params">n1, n2, delayTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 建立 Promise 物件 : new promise(執行函式)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 兩個系統給的參數</span></span><br><span class="line">    <span class="comment">// 要做的工作放到promise的函式裡</span></span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(n1 + n2); <span class="comment">// 工作完成，呼叫 resolve 函式，並把結果透過參數傳遞進去，如果工作出現問題就呼叫 reject</span></span><br><span class="line">    &#125;, delayTime);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 語法糖，函式前面加 async， async / await 需要一起使用</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await 後面接函式. 上面的 resolve 會直接由 result 接收</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> delayedAdd2(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="需求-需要運行兩次的-promise-然後將結果相乘-1"><a href="#需求-需要運行兩次的-promise-然後將結果相乘-1" class="headerlink" title="需求 需要運行兩次的 promise 然後將結果相乘"></a>需求 需要運行兩次的 promise 然後將結果相乘</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test3a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await 後面接函式. 上面的 resolve 會直接由 result 接收</span></span><br><span class="line">  <span class="keyword">let</span> result1 = <span class="keyword">await</span> delayedAdd2(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">let</span> result2 = <span class="keyword">await</span> delayedAdd2(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">let</span> answer = result1 * result2;</span><br><span class="line">  <span class="built_in">console</span>.log(answer);</span><br><span class="line">&#125;</span><br><span class="line">test3a();</span><br></pre></td></tr></table></figure><p><a href="https://www.youtube.com/watch?v=NOprCnnjHm0" target="_blank" rel="noopener">參考 1 彭彭的課程</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="noopener">參考 2 code</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript IIFE 立即呼叫函式</title>
      <link href="/tsuifei.github.io/JS_What-is-an-IIFE-in-JavaScript/"/>
      <url>/tsuifei.github.io/JS_What-is-an-IIFE-in-JavaScript/</url>
      
        <content type="html"><![CDATA[<p>IIFE 是立即被呼叫的函式的簡寫，全名為 Immediately Invoked Function Expression。在 ES6 之前，JavaScript 變數有效範圍的最小單位以 function 為分界。<br>IIFE 的好處，就是可以減少「全域變數」的產生，同時也避免了變數名稱衝突的機會。</p><h2 id="IIFE-語法"><a href="#IIFE-語法" class="headerlink" title="IIFE 語法"></a>IIFE 語法</h2><p>將一個正常的函式包在()裡，後面加個()就成了匿名函式。<br>後面的()表示立即執行，也可帶參數。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 做一些事...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IIFE函式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 做一些事....</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>IIFE 函式前面一定要有; 不然會有錯誤<br>範例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  Console.log(bar);</span><br><span class="line">&#125;)(foo);</span><br></pre></td></tr></table></figure><p>匿名函數的參數(foo)就是 var foo 的這個變數，如果匿名函數有兩個參數， 後面的() 也可帶兩個參數</p><p>一般呼叫函式的方式可以是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doSomething(<span class="number">123</span>);</span><br><span class="line"><span class="comment">// 匿名函式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 做一些事...</span></span><br><span class="line">&#125;)(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>使用匿名函式即是馬上使用，也就是宣告他的同時也呼叫它，自然就不需要給名字了。所以就成了以下不需名字的函式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 做一些事...</span></span><br><span class="line">&#125;)(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>在回圈內呼叫 function 會需要用 IIFE 來把參數的值保留起來，如果有看過 jQuery 的原始碼，會發現有這段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><p>jQuery 也用了相同的手法將 window 和 indefined 保留起來。<br>ES6 以後新增了 let 與 const 的變數型態，且改以 { } 作為它的 Scope。換句話說，將範例中的 for 的 var 改為以 let 宣告就可以做到保留 i 在執行迴圈當下的「值」的效果：</p><h4 id="經典迴圈非同步問題"><a href="#經典迴圈非同步問題" class="headerlink" title="經典迴圈非同步問題"></a>經典迴圈非同步問題</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目的：每一秒列出一個 i<br>但會列印出１０個１０，因為當進入列印迴圈時，i 已經跑到１０了<br>解決如何因非同步而無法印出１－１０的方法：使用 IIFE 和閉包<br>使用 IIFE</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>參考：<a href="https://ithelp.ithome.com.tw/articles/10192739" target="_blank" rel="noopener">立即被呼叫的函式 (Immediately Invoked Function Expression, IIFE)</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Github 上安裝 Hexo 記錄</title>
      <link href="/tsuifei.github.io/%E5%9C%A8-Github-%E4%B8%8A%E5%AE%89%E8%A3%9D-Hexo-%E8%A8%98%E9%8C%84/"/>
      <url>/tsuifei.github.io/%E5%9C%A8-Github-%E4%B8%8A%E5%AE%89%E8%A3%9D-Hexo-%E8%A8%98%E9%8C%84/</url>
      
        <content type="html"><![CDATA[<p>在學員的鼓勵下，決定試試安裝輕量級 blog Hexo。隨然玩 Wordpress 已經很久了，但 WP 的架構越來越龐大更新速度快，整個檔案也越來越龐大了，且 WP 需要資料庫的配合。但 Hexo 不但不需要，且還可以部屬在 Github 上，超方便的！雖然設定與修改比較繁瑣，但也有它的樂趣，且既然是與程式有關的文章和內容，那何不把他們放在一起。</p><p>將 Hexo 自動生成的靜態頁面、搭配 github 的 page 功能，推上 github 後就可達到輕量 blog 的基本功能，如果想要一些功能如搜尋、留言，則要自行設定或安裝外掛，比較方便的是找個完善的主題，就不需這些繁複的設置，但最好對 Hexo 架構有一定的了解，否則一有問題仍須花很多時間查詢。</p><a id="more"></a><p>這裡使用的佈景主題是 Hexo 的預設主題：landscape，希望慢慢修改成自己喜歡的樣子即可，功能仍不是很完善，期待自己慢慢把它做的更完整一點。</p><h2 id="Hexo-建立文章的方式"><a href="#Hexo-建立文章的方式" class="headerlink" title="Hexo 建立文章的方式"></a>Hexo 建立文章的方式</h2><p>一般我們都會使用 hexo new <code>&lt;title&gt;</code>來建立新文章，這種方法會將新文章建立在 source/_posts 目錄下，當使用 hexo generate 編譯 markdown 文件時，就會將其 HTML 結果編譯在 public 目錄下，之後 hexo deploy 再將把 public 目錄下所有文章一起部署到 GitHub，這是我們熟悉的 Hexo 流程。</p><p>這種建立文章方式的缺點是：如果同時編輯多篇文章，只要其中一篇文章尚未編輯完成，也會隨著 hexo deploy 通通一起部署到 GitHub，也就是 GitHub 可能會看到我們尚未完成的文章。以下會介紹先將文章存成草稿的步驟。</p><h2 id="如何安裝"><a href="#如何安裝" class="headerlink" title="如何安裝"></a>如何安裝</h2><p>條件：node.js 環境 ＋ git<br><a href="https://hexo.io/zh-tw/docs/" target="_blank" rel="noopener">官網文件</a></p><p>先在本地端安裝好需要檔案，安裝後檔案夾內會有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><code>_config.yml</code> :<br>網站<a href="https://hexo.io/zh-tw/docs/configuration" target="_blank" rel="noopener">配置</a>檔案，可以在此配置大部分的設定。</p><p><code>package.json</code> :<br>應用程式資料。EJS, Stylus 和 Markdown renderer 已預設安裝，可以稍後移除。</p><p><code>scaffolds</code> :<br>鷹架 資料夾。當建立新文章時，Hexo 會根據 scaffold 來建立檔案。</p><p><code>source</code> :<br>原始檔案資料夾是放置內容的地方。檔案 / 資料夾名稱開頭為 _ (底線) 和隱藏檔案會被忽略，除了 _posts 資料夾以外。Markdown 和 HTML 檔案會被處理並放到 public 資料夾，而其他檔案會被拷貝過去。</p><p><code>themes</code> :<br>主題 資料夾。Hexo 會根據主題來產生靜態檔案。</p><h2 id="Hexo-指令"><a href="#Hexo-指令" class="headerlink" title="Hexo 指令"></a>Hexo 指令</h2><p><a href="https://hexo.io/zh-tw/docs/commands" target="_blank" rel="noopener">指令明細</a><br><code>$ hexo init [folder]</code><br>建立一個新的網站。如果沒有設定 folder 的話，Hexo 會在目前的資料夾建立網站。</p><h2 id="如何產生文章"><a href="#如何產生文章" class="headerlink" title="如何產生文章"></a>如何產生文章</h2><h3 id="建立文章-hexo-new-layout-lt-title-gt"><a href="#建立文章-hexo-new-layout-lt-title-gt" class="headerlink" title="建立文章 : hexo new [layout] &lt;title&gt;"></a>建立文章 : <code>hexo new [layout] &lt;title&gt;</code></h3><p><code>$ hexo new [layout] &lt;title&gt;</code><br>Hexo 的 layout 有三種：草稿 draft、頁面 page 和文章 post。也可以自定義 layout.<br>如果沒有設定 layout 的話，則會使用 <code>_config.yml</code> 中的 <code>default_layout</code> 設定代替，原始預設為 post。<br>檔案名稱可以中文，如果標題包含空格的話，請使用引號括起來。<br>建立文章後 hexo 會在 source 裡的 _posts 生成新的 .md。</p><h3 id="產生靜態文章-hexo-g"><a href="#產生靜態文章-hexo-g" class="headerlink" title="產生靜態文章 : hexo g"></a>產生靜態文章 : <code>hexo g</code></h3><p><code>$ hexo generate</code><br>產生靜態檔案。<br>|選項 | 描述 |<br>| ——– | ——– |<br>| -g, –generate | 部署網站前先產生靜態檔案 |</p><h3 id="本地伺服器-hexo-s"><a href="#本地伺服器-hexo-s" class="headerlink" title="本地伺服器 : hexo s"></a>本地伺服器 : <code>hexo s</code></h3><p><code>$ hexo server</code><br>啟動伺服器，預設是 <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a><br>| 選項| 描述|<br>| ——– | ——– |<br>| -p, –port | 覆蓋連接埠設定 |<br>| -s, –static | 只使用靜態檔案 |<br>| -l, –log | 啟動記錄器，或覆蓋記錄格式 |</p><h3 id="部署到-github-hexo-d"><a href="#部署到-github-hexo-d" class="headerlink" title="部署到 github : hexo d"></a>部署到 github : <code>hexo d</code></h3><p><code>$ hexo deploy</code><br>部署網站。<br>| 選項 | 描述 |<br>| ——– | ——– |<br>| -d, –deploy | 產生完成即部署網站 |<br>| -w, –watch | 產生完成即部署網站 |</p><p><code>$ hexo render &lt;file&gt; [file2] ...</code><br>渲染檔案。</p><table><thead><tr><th>選項</th><th>描述</th></tr></thead><tbody><tr><td>-o, –output</td><td>輸出位置</td></tr></tbody></table><p><a href="https://hexo.io/zh-tw/docs/commands" target="_blank" rel="noopener">其他指令</a> ｜ <a href="https://hexo.io/zh-tw/docs/migration" target="_blank" rel="noopener">侯塞雷還可以轉移！</a></p><p>==注意==<br>如果有使用部分搜尋外掛，會使用 xml 格式搜尋，丟文章上去時先檢查是否有正確規格化為 XML 格式，以免出錯查不出來，所以可先去<a href="https://tool.oschina.net/codeformat/xml" target="_blank" rel="noopener">此網站檢查</a></p><h2 id="常用-Hexo-指令"><a href="#常用-Hexo-指令" class="headerlink" title="常用 Hexo 指令"></a>常用 Hexo 指令</h2><p>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br>hexo clean ：清除快取檔案 (db.json) 和已產生的靜態檔案 (public)。</p><h3 id="可一起使用：hexo-g-amp-amp-hexo-s-amp-amp-hexo-d-amp-amp-hexo-new-文章名稱"><a href="#可一起使用：hexo-g-amp-amp-hexo-s-amp-amp-hexo-d-amp-amp-hexo-new-文章名稱" class="headerlink" title="可一起使用：hexo g &amp;&amp; hexo s &amp;&amp; hexo d &amp;&amp; hexo new [文章名稱]"></a>可一起使用：<code>hexo g &amp;&amp; hexo s &amp;&amp; hexo d &amp;&amp; hexo new [文章名稱]</code></h3><h2 id="如何更換主題"><a href="#如何更換主題" class="headerlink" title="如何更換主題"></a>如何更換主題</h2><p>可上<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">Hexo 官網 Themes</a>直接找自己喜歡的主題，進入主題後，找到<code>install</code>這項，複製 git clone 的網址如，以 Themes 名為 light 為例：<br><code>git clone https://github.com/hexojs/hexo-theme-light.git themes/light</code></p><p>Clon 完畢後，到根目錄的 <code>_config.yml</code> 去設定對應的 Themes 主題名稱： <code>theme: light</code></p><h2 id="如何自動備份"><a href="#如何自動備份" class="headerlink" title="如何自動備份"></a>如何自動備份</h2><p>可以在同一專案上再開一條 Git 分支，專門儲存原始檔案，或是使用 <a href="https://askiebaby.github.io/macos-command-backup-update-hexo-blog/" target="_blank" rel="noopener">Askie 推薦的一鍵備份</a>，但須另開專案。</p><h2 id="如何文章分類"><a href="#如何文章分類" class="headerlink" title="如何文章分類"></a>如何文章分類</h2><h3 id="第一種方法：手動加入"><a href="#第一種方法：手動加入" class="headerlink" title="第一種方法：手動加入"></a>第一種方法：手動加入</h3><p>使用 <code>$ hexo n &lt;name&gt;</code>新建頁面，打開此默認頁面是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: name</span><br><span class="line">date: 2019-08-05 11:15:00</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>但裡面並沒有分類的資訊，可直接在 <code>tags:</code>上加 <code>categories:</code> 存檔後，重新執行 <code>hexo n &#39;name&#39;</code>，重新打開頁面裡頭就有分類了。</p><h3 id="第二種方法："><a href="#第二種方法：" class="headerlink" title="第二種方法："></a>第二種方法：</h3><p>scaffolds 目錄下，是新建頁面的模板，執行新建命令時，是根據這裡的模板頁來完成的，所以可在這裡根據自己的需求增加一些默認的分類值。<br>在寫文章時，如果我們的分類是程式，那麼在也面裡的分類就會是<code>categories:程式</code>，它的訪問路徑即是：<code>*/categories/程式</code></p><p>如果想把路徑明和分類明分別設置，可打開根目錄的<code>_config.yml</code>，找到以下位置或增加以下這段做修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">程式: programming</span><br><span class="line">生活: life</span><br><span class="line">其他: other</span><br><span class="line">tag_map:</span><br></pre></td></tr></table></figure><p><code>category_map:</code>是設置分類的地方，每行一個分類，冒號前面是分類名稱，後面是訪問路徑。可以提前在這裡設置好一些分類，當編輯的文章填寫了對應的分類名時，就會自動的按照對應的路徑來訪問。</p><h3 id="設定分類標籤在頁面裡"><a href="#設定分類標籤在頁面裡" class="headerlink" title="設定分類標籤在頁面裡"></a>設定分類標籤在頁面裡</h3><p>在編輯文章的時候，tags:後面是設置標籤的地方，如果有多個標籤的話，可以用下面兩種辦法來設置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tages:</span><br><span class="line">-標籤1</span><br><span class="line">-標籤2</span><br><span class="line">...</span><br><span class="line">- 標籤n</span><br><span class="line"></span><br><span class="line">// 或是</span><br><span class="line">tages:</span><br><span class="line">-標籤1</span><br><span class="line">-標籤2</span><br><span class="line">...</span><br><span class="line">- 標籤n</span><br></pre></td></tr></table></figure><h2 id="如何設定分類-menu"><a href="#如何設定分類-menu" class="headerlink" title="如何設定分類 menu"></a>如何設定分類 menu</h2><p>在 Hexo 默認菜單只有 Home 和 Archives 兩項，如何增加新的項目到 menu 裡？<br>打開 themes 裡主題的配置文件：<code>_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu :</span><br><span class="line">  Home: /</span><br><span class="line">  Archives: /archives</span><br><span class="line">  About: / about</span><br></pre></td></tr></table></figure><p><code>menu :</code> 表示 Nav，在底下加上的 <code>About: /about</code> 表示顯示的 Nav 項目/路徑。Nav 項目可為中文，路徑也可設置其他 url。<br>記得建立一個 nav 的項目就要執行建立 Nav 項目的指令：<br><code>hexo n page &#39;about&#39;</code> hexo 就會自動生成這個分類的分類頁，在 source 目錄裡會生成一個對應的目錄，此目錄裡的<code>index.md</code> 就是顯示這個分類列表的頁面。</p><p>參考：<a href="http://ijiaober.github.io/2014/08/05/hexo/hexo-04/" target="_blank" rel="noopener">Hexo 使用攻略：（四）Hexo 的分类和标签设置</a></p><h2 id="如何增加站內搜尋功能"><a href="#如何增加站內搜尋功能" class="headerlink" title="如何增加站內搜尋功能"></a>如何增加站內搜尋功能</h2><p>以<a href="https://app.swiftype.com/" target="_blank" rel="noopener">swiftype.com</a>服務來設定站內服務，<br>先至 swiftype 申請帳號，再把生成的碼丟入網頁中。<br><a href="https://juejin.im/post/5bbdc8d8e51d450e5e0cb269" target="_blank" rel="noopener">參考教學 使用 Swiftype 给 Hexo 搭建的博客添加站内搜索功能</a></p><h2 id="如何將文章存成草稿-draft"><a href="#如何將文章存成草稿-draft" class="headerlink" title="如何將文章存成草稿 draft"></a>如何將文章存成草稿 draft</h2><p>必須先在 source/ 底下建立一個 _drafts 目錄，以存放草稿。</p><h3 id="建立文章草稿"><a href="#建立文章草稿" class="headerlink" title="建立文章草稿"></a>建立文章草稿</h3><p><code>$ hexo new draft &lt;title&gt;</code><br>Hexo 另外提供 draft 機制，原理是將新文章將建立在 source/_drafts 目錄下，因此 hexo generate 並不會將其編譯到 public 目錄下，所以 hexo deploy 也不會將其部署到 GitHub。</p><h3 id="本機預覽草稿"><a href="#本機預覽草稿" class="headerlink" title="本機預覽草稿"></a>本機預覽草稿</h3><p><code>$ hexo S --draft</code><br>雖然 hexo generate 不會編譯 source/_drafts 目錄下的文章，但 Hexo 的 Hexo server 另外提供<code>--draft</code>的參數，這讓我們只要搭配<code>hexo-browsersyncplugins</code>，就可以做到一邊編輯 markdown 文章，一邊使用瀏覽器預覽的目的。</p><h3 id="將草稿發佈為正式文章"><a href="#將草稿發佈為正式文章" class="headerlink" title="將草稿發佈為正式文章"></a>將草稿發佈為正式文章</h3><p><code>$ hexo P &lt;filename&gt;</code><br>其中<code>&lt;filename&gt;</code>為不包含 md 後綴的文章名稱。它的原理只是將文章從 source/_drafts 移動到 source/_posts 而已。</p><h3 id="將正式文章發佈為草稿"><a href="#將正式文章發佈為草稿" class="headerlink" title="將正式文章發佈為草稿"></a>將正式文章發佈為草稿</h3><p>之後的 hexo generate 與 hexo deploy 的用法就完全一樣了。<br>若日後想將正式文章轉為為草稿，只需手動將文章從 source/_posts 目錄移動到 source/_drafts 目錄即可。</p><p>向 Google 申請 Blog Search: <a href="https://search.google.com/search-console/welcome" target="_blank" rel="noopener">Google Search Console</a></p><h2 id="增加邊欄"><a href="#增加邊欄" class="headerlink" title="增加邊欄"></a>增加邊欄</h2><p>進入 themes\layout_widget 目錄中，建立 about.ejs 文件，模仿其他文件中的模版，輸入以下內容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (site.tags.length)&#123; %&gt;</span><br><span class="line">  &lt;div class=&quot;widget-wrap&quot;&gt;</span><br><span class="line">    &lt;h3 class=&quot;widget-title&quot;&gt;About&lt;/h3&gt;</span><br><span class="line">    &lt;div class=&quot;widget&quot;&gt;</span><br><span class="line">      Email：xxx@xxx.com&lt;br /&gt;</span><br><span class="line">      Site：www.</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>打開 themes_config.yml，找到#Sidebar，在最後面添加- about。刷新頁面。<br>Ref:<a href="https://wizardforcel.gitbooks.io/markdown-simple-world/hexo-tutor-4.html" target="_blank" rel="noopener">Hexo 入門指南</a></p><h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://hexo.io/zh-tw/docs/configuration.html" target="_blank" rel="noopener">Hexo 檔案配置</a><br><a href="https://coffee0127.github.io/blog/2016/08/09/hexo-configuration/" target="_blank" rel="noopener">在 landscape 主題安裝一些功能</a></p><p><a href="https://kennyliblog.nctu.me/2019/06/24/Google-search-Hexo-Blog/" target="_blank" rel="noopener">讓 Google 能搜尋到自己的 Hexo Blog</a></p><p><a href="http://kuangqi.me/tricks/enable-table-of-contents-on-hexo/" target="_blank" rel="noopener">为 Hexo 博客添加目录</a></p><p>發現 Hexo 新貼文後，GitHub 的首頁綠點卻沒出現，於是依照此篇重新設定 ssh，已重新更新。<br><a href="https://lizhijun.site/2018/02/04/Hexo+Github%E6%90%AD%E5%BB%BAyilia%E4%B8%BB%E9%A2%98%E7%9A%84%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">Hexo+Github 搭建 yilia 主題的博客</a></p><h3 id="紀錄"><a href="#紀錄" class="headerlink" title="紀錄"></a>紀錄</h3><p>19/10/2020 增加分類、Tag、404 頁面。放棄更新。</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Other </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript ES6 箭頭函式 Arrow function</title>
      <link href="/tsuifei.github.io/JS_ES6-%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F-Arrow-function/"/>
      <url>/tsuifei.github.io/JS_ES6-%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F-Arrow-function/</url>
      
        <content type="html"><![CDATA[<p>箭頭函式是 ES6 的新語法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原本的寫法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或是</span></span><br><span class="line"><span class="keyword">var</span> double = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 語法</span></span><br><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="箭頭函式的簡寫規則"><a href="#箭頭函式的簡寫規則" class="headerlink" title="箭頭函式的簡寫規則"></a>箭頭函式的簡寫規則</h3><p>1.如果參數只有一個，可省略參數的括號(x)=&gt; x，0 或多個都不可省略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.函式本體如果只有一行，且只有 return 一個值，可省略大花括號和 return，直接把本體接在=&gt;後面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="This-是什麼？和箭頭函式的關係"><a href="#This-是什麼？和箭頭函式的關係" class="headerlink" title="This 是什麼？和箭頭函式的關係"></a>This 是什麼？和箭頭函式的關係</h3><p>this 指的是函式的情境(context)，某人去 101 大樓往下跳，但跳下去沒事，因為在爬樓梯，他只有跳一格的樓梯，當然沒事，但是跳這個動作很明確，就像是函式的定義一樣。<br>但是你在什麼樣的情境下跳，會影響他的結果，這個情境就是 Context 。<br>例如：一個跳的函式，裡面內容是固定的，但裡面的 this 就要看他執行時的情境而定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jump</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javascript 裡函式的執行基本上可分為三種： 1.直接執行： 函式裡的 this 是 window (global)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jump();</span><br><span class="line"><span class="comment">// window 物件</span></span><br></pre></td></tr></table></figure><p>2.作為一個物件的方法來執行:裡面的 this 就是物件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line">a.jump = jump;</span><br><span class="line">a.jump();</span><br><span class="line"><span class="comment">// 執行結果是物件 &#123;jump:f..&#125;</span></span><br></pre></td></tr></table></figure><p>3.假設頁面上有一個 button，點它就會執行 jump()，<br>如果一個函式以 Dom 監聽函式來執行，函式裡面的 this 就會指向所監聽的元素 Dom。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;btn&quot;&gt;</span><br><span class="line">btn</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jump</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">btn.sddEventListener(<span class="string">'click'</span>, jump);</span><br><span class="line"><span class="comment">// button DOM</span></span><br></pre></td></tr></table></figure><h3 id="用箭頭-This-會改變"><a href="#用箭頭-This-會改變" class="headerlink" title="用箭頭 This 會改變"></a>用箭頭 This 會改變</h3><p>如果以箭頭函式攥寫 Dom 的監聽函式，This 就會改變成指向 window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jump = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">btn.sddEventListener(<span class="string">'click'</span>, jump);</span><br><span class="line"><span class="comment">// window</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line">a.jump = jump; <span class="comment">// window</span></span><br><span class="line">a.jump(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>只要是箭頭函式，無論如何執行它，裡面的 this 都會指向 window，這就是箭頭函式的特性，它沒有自己的情境(Context)，它的內部 context 就等於它宣告的時候，它外面的 this。</p><p>React 會大量的用到 This 所以一定要弄懂。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 秘技 Rename Refactoring 重新命名＋Formatting重新整理程式碼</title>
      <link href="/tsuifei.github.io/VS-Code_%E7%A7%98%E6%8A%80-Rename-Refactoring-%E9%87%8D%E6%96%B0%E5%91%BD%E5%90%8D%EF%BC%8BFormatting%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E7%A8%8B%E5%BC%8F%E7%A2%BC/"/>
      <url>/tsuifei.github.io/VS-Code_%E7%A7%98%E6%8A%80-Rename-Refactoring-%E9%87%8D%E6%96%B0%E5%91%BD%E5%90%8D%EF%BC%8BFormatting%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E7%A8%8B%E5%BC%8F%E7%A2%BC/</url>
      
        <content type="html"><![CDATA[<p>在 VS Code 隱藏了一些相當好用的功能，在每次重啟 VS Code 時，就會有一些基本的講解，沒仔細看還真的很容易忽略。<br>這個功能主要在幫助增快原始的重構，可從以下位置找到這個說明功能。</p><ul><li>help -&gt; Interactive Playground -&gt;<a id="more"></a></li></ul><h2 id="重構工具"><a href="#重構工具" class="headerlink" title="重構工具"></a>重構工具</h2><h3 id="Rename-Refactoring-重新命名"><a href="#Rename-Refactoring-重新命名" class="headerlink" title="Rename Refactoring (重新命名)"></a>Rename Refactoring (重新命名)</h3><p>選中要修改的某一個名稱，按 fn+F2 即可重新輸入新的命名， enter 之後會發現所有用此函式名的地方，都會換成新名字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reference the function</span></span><br><span class="line"><span class="keyword">new</span> Book(<span class="string">'War of the Worlds'</span>, <span class="string">'H G Wells'</span>);</span><br><span class="line"><span class="keyword">new</span> Book(<span class="string">'The Martian'</span>, <span class="string">'Andy Weir'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a book.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Book</span>(<span class="params">title, author</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.title = title;</span><br><span class="line">  <span class="keyword">this</span>.author = author;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Refactoring-via-Extraction-透過提取重構函式"><a href="#Refactoring-via-Extraction-透過提取重構函式" class="headerlink" title="Refactoring via Extraction (透過提取重構函式)"></a>Refactoring via Extraction (透過提取重構函式)</h3><p>可將程式中某一部分提去出來自成一函式。<br>選取要提取出來成函式的部份，按 command + . 會出現選單：<br>1.Extract to inner function in function ‘findFirstEvenNumber’(提取函式中的內部函數尋找找’findFirstEvenNumber’函式)<br>2.Extract to function in global scope(提取全局範圍內的功能)<br>3.Extract to constant in enclosing scope(在封閉範圍內提取常量)</p><p>例如選 2.會將選取提取出的碼轉成一函式，並需賦予函式名稱，即可成函式，輸入新函式名之後會自動替換，原題取出來的函式位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstEvenNumber</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> el === <span class="string">'number'</span> &amp;&amp; el % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> el;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Formatting-重新整理程式碼"><a href="#Formatting-重新整理程式碼" class="headerlink" title="Formatting (重新整理程式碼)"></a>Formatting (重新整理程式碼)</h3><p>shift + option + F 可重新整理程式碼的排列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = [<span class="string">'🚗'</span>, <span class="string">'🚙'</span>, <span class="string">'🚕'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> car <span class="keyword">of</span> cars) &#123;</span><br><span class="line">  <span class="comment">// Drive the car</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`This is the car <span class="subst">$&#123;car&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或是開啟 sstting 預設: editor.formatOnSave = true，即可啟動存檔就會自動編排的功能。</p>]]></content>
      
      
      <categories>
          
          <category> VSCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
