<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git / GitHub 實際操作</title>
      <link href="/tsuifei.github.io/2019/07/09/Git-GitHub-%E5%AF%A6%E9%9A%9B%E6%93%8D%E4%BD%9C/"/>
      <url>/tsuifei.github.io/2019/07/09/Git-GitHub-%E5%AF%A6%E9%9A%9B%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="在本地使用git版本控制"><a href="#在本地使用git版本控制" class="headerlink" title="在本地使用git版本控制"></a>在本地使用git版本控制</h2><h4 id="init-初始化"><a href="#init-初始化" class="headerlink" title="init  初始化"></a>init  初始化</h4><ul><li>在要使用版本控制的檔案夾裡輸入 init 初始化，以ls -la可看到隱藏的 .git 檔案夾</li><li>使用 git status 觀察版本狀態</li></ul><h4 id="git-add-加入版本控制檔案"><a href="#git-add-加入版本控制檔案" class="headerlink" title="git add 加入版本控制檔案"></a>git add 加入版本控制檔案</h4><ul><li>使用 git add [fileName] 加入要版本控制的檔案，或是使用 git add . 表示全部加入</li><li>使用 git status 會發現有兩區域： staged (加入)/ untracked (沒加入)版本控制，可使用 git rm —cached [fileName] 將已加入的檔案移出至 untracked。</li><li>要 add 才能 commit</li></ul><h4 id="git-commit-新建一個版本"><a href="#git-commit-新建一個版本" class="headerlink" title="git commit 新建一個版本"></a>git commit 新建一個版本</h4><ul><li>使用 git commit 新建一個版本，或出vim文字編輯器 ( i insert  / :q 退出)，會出現 commit 是空的(empty)訊息。</li><li>以 git commit -m  “[訊息]”<br>git commit 如出現錯誤，跳出設定帳號跟姓名的畫面，請輸入以下指令</li></ul><ol><li>git config –global user.name “your name”</li><li>git config –global user.email “youremail”</li></ol><h4 id="git-log-歷史紀錄"><a href="#git-log-歷史紀錄" class="headerlink" title="git log 歷史紀錄"></a>git log 歷史紀錄</h4><ul><li>使用 git log 會出現所有 commit 的歷史紀錄編號，q 離開 log</li></ul><h4 id="git-checkout-回到過去某個版本狀態"><a href="#git-checkout-回到過去某個版本狀態" class="headerlink" title="git checkout 回到過去某個版本狀態"></a>git checkout 回到過去某個版本狀態</h4><ul><li>使用 git log —online 會出現 commit 短版本列表，前7碼為版本簡碼，後面是 commit 時輸入的訊息。</li><li>使用 git checkout [版本碼] 即可回到要去的版本時間點，用 git log 觀察這個版本時間點之後的版本都會看不見。</li><li>使用 git checkout master 回去現在的時間點版本，再用 git log 觀察就可看到所有版本。</li></ul><h4 id="gitignore-忽略檔案"><a href="#gitignore-忽略檔案" class="headerlink" title=".gitignore 忽略檔案"></a>.gitignore 忽略檔案</h4><p>在檔案夾裡增加一個 .gitignore 檔案，裡面寫上不要加入版本控制裡的檔案，這樣 git 就不會每次提醒，例如連線資料、test、log等系統自動產生的檔案。</p><ul><li>touch .gitignore 產生檔案</li><li>vim .gitignore 編輯檔案</li><li>Git commit -am “commit message” 可直接 add+commit 但只會加入曾經加入的，而不會加入新的檔案。所以每次有新檔案時最好使用 git add [fileName] 加入，或用 git add .  全部加入再 commit。</li></ul><h3 id="小筆記"><a href="#小筆記" class="headerlink" title="小筆記"></a>小筆記</h3><p>git checkout -b [分支名]  可直接開分支並切換過去<br>git -d [分支名]  把分支刪除<br>git diff 可看上一次做的變動，q 退出</p><h2 id="在本地端開分支-branch-–-gt-合併主版本-merge"><a href="#在本地端開分支-branch-–-gt-合併主版本-merge" class="headerlink" title="在本地端開分支  branch  –&gt; 合併主版本 merge"></a>在本地端開分支  branch  –&gt; 合併主版本 merge</h2><h4 id="設分支-branch"><a href="#設分支-branch" class="headerlink" title="設分支 branch"></a>設分支 branch</h4><ul><li>用git branch -v 看有哪些 branch 主分支為 master，也會顯示這支分支最後一個 commit </li><li>原本在 master，創另一個分支 ：git branch [分支名]</li><li>切換到那個分支：git checkout [分支名]</li><li>刪除分支：git branch -d [分支名]</li><li>切換分支 ：git checkout [分支名]</li><li>用 git branch -v 查看現在在哪個分支(顯示綠色)</li></ul><h3 id="merge-branch-to-master-將分支合併到主支幹"><a href="#merge-branch-to-master-將分支合併到主支幹" class="headerlink" title="merge branch to master 將分支合併到主支幹"></a>merge branch to master 將分支合併到主支幹</h3><ul><li>git [分支] merge : 把某一分支合併過來 master </li><li>git branch -d [分支] : 合併後即可把原本的分支刪除</li></ul><h4 id="合併時發生衝突-conflict"><a href="#合併時發生衝突-conflict" class="headerlink" title="合併時發生衝突 conflict"></a>合併時發生衝突 conflict</h4><ul><li>主支和分支同時修改時，分支要合併至主支時，會產生  auto-merging [fileName] CONFLICT (content) : Merge conflict in [fileName] automatic merge failed; fix conflicts and then commit the result.</li><li>用 git status 查看會以 both modified :  [fileName] 顯示有問題的檔案</li><li>進入有問題的 [fileName] 手動修改，=====為兩版本分隔，&lt;&lt;&lt;&lt;&lt; [分支名]。將其中一個刪除與更正存檔，再 commit 一次，再合併。</li><li>git status 顯示 resolve conflicts 表示衝突解決。 </li></ul><h4 id="注意-小觀念"><a href="#注意-小觀念" class="headerlink" title="注意 + 小觀念"></a>注意 + 小觀念</h4><p>Git : 版本控制的程式<br>GitHub :  放 git repository 的存儲庫<br>有用 git 不一定要用 GitHub，但用 GitHub 就一定要會用到 git<br>忘記切回test分支，所以後來無法順利 merge 到 master 分支，雖然後來看似解決，但還真不知道自己是怎麼解決的，就是試了幾個間，跟著打就好了．．．這樣其實有點可怕，下次再注意！</p><h2 id="把本地端-code-放上-GitHub"><a href="#把本地端-code-放上-GitHub" class="headerlink" title="把本地端 code 放上 GitHub"></a>把本地端 code 放上 GitHub</h2><h3 id="Create-a-new-repository-在-github-開一個新的存儲庫"><a href="#Create-a-new-repository-在-github-開一個新的存儲庫" class="headerlink" title="Create a new repository 在 github 開一個新的存儲庫"></a>Create a new repository 在 github 開一個新的存儲庫</h3><ul><li>填入 Repository name 和 Description，就好有使用技術關鍵字</li><li>選擇 Public 或 Private</li><li>Initialize this repository whit a README 可以先不選</li><li>Add .gitignore 和 a license 都選預設 None</li></ul><h4 id="方法ㄧ-在本地端還沒有code-可使用這種方法"><a href="#方法ㄧ-在本地端還沒有code-可使用這種方法" class="headerlink" title="方法ㄧ) 在本地端還沒有code 可使用這種方法"></a>方法ㄧ) 在本地端還沒有code 可使用這種方法</h4><p>…or create a new repository on the command line<br>echo “# github.io-“ &gt;&gt; README.md<br>git init<br>git add README.md<br>git commit -m “first commit”<br>git remote add origin [<a href="https://github.com/tsuifei/倉庫位址.git]" target="_blank" rel="noopener">https://github.com/tsuifei/倉庫位址.git]</a><br>git push -u origin master</p><h4 id="方法二-在本地端已經有-code-用這種把-code-push-到-github-的方法。"><a href="#方法二-在本地端已經有-code-用這種把-code-push-到-github-的方法。" class="headerlink" title="方法二) 在本地端已經有 code 用這種把 code push 到 github 的方法。"></a>方法二) 在本地端已經有 code 用這種把 code push 到 github 的方法。</h4><p>…or push an existing repository from the command line<br>從本地push到遠端<br>git remote add origin [<a href="https://github.com/tsuifei/倉庫位址.git]" target="_blank" rel="noopener">https://github.com/tsuifei/倉庫位址.git]</a><br>git push -u origin master  把 code push 到github的這個 master 主支上 通常這之後會要你的 github 的帳號和密碼，有輸入才算與遠端相通 單字 : remote 遠端 / origin 代號<br>-u -&gt; set-upstream </p><h4 id="方法三-以引入的方式將-code-放進來"><a href="#方法三-以引入的方式將-code-放進來" class="headerlink" title="方法三) 以引入的方式將 code 放進來"></a>方法三) 以引入的方式將 code 放進來</h4><p>…or import code from another repository<br>You can initialize this repository with code from a Subversion, Mercurial, or TFS project.</p><h2 id="把本地端最新的版本推上-GitHub"><a href="#把本地端最新的版本推上-GitHub" class="headerlink" title="把本地端最新的版本推上 GitHub"></a>把本地端最新的版本推上 GitHub</h2><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><ul><li>本地端 : 把檔案 commit 之後， 使用git push origin master 推到主支上  </li><li>Github 端 : 重新整理頁面後 branch 會更新，commits 數量也會增加</li><li>如果只有 commit 沒 push，Github 端不會變動</li><li>可開分支 再 git push origin [分支名] ，再到Github 端看就有兩個 branch</li></ul><h2 id="把Github-端上最新版本-拉下本地端"><a href="#把Github-端上最新版本-拉下本地端" class="headerlink" title="把Github 端上最新版本 拉下本地端"></a>把Github 端上最新版本 拉下本地端</h2><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><ul><li>先到要拉下來的位置</li><li>執行 git pull origin master</li><li>如有 conflict 可依上述 merge 的衝突解決方式處理。</li></ul><h2 id="把其他人-Github-端上的code-拉下本地端"><a href="#把其他人-Github-端上的code-拉下本地端" class="headerlink" title="把其他人 Github 端上的code 拉下本地端"></a>把其他人 Github 端上的code 拉下本地端</h2><h4 id="git-clone-42-就是用這種方法"><a href="#git-clone-42-就是用這種方法" class="headerlink" title="git clone (42 就是用這種方法)"></a>git clone (42 就是用這種方法)</h4><ul><li>先到要拉下來的位置</li><li>執行 git colne [<a href="https://github.com/tsuifei/倉庫位址.git]" target="_blank" rel="noopener">https://github.com/tsuifei/倉庫位址.git]</a> 可自行取名</li><li>git clone 之後可以commit 因為在本地端，且專案是別人的，所以如果執行 push 會因無權限而無法執行</li></ul><h3 id="將別人的專案變成自己的"><a href="#將別人的專案變成自己的" class="headerlink" title="將別人的專案變成自己的"></a>將別人的專案變成自己的</h3><ul><li>使用 Fork 功能，再使用 clone 方式將專案拉下至本地端 </li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="直接在-Github-端-commit-修改檔案"><a href="#直接在-Github-端-commit-修改檔案" class="headerlink" title="直接在 Github 端 commit 修改檔案"></a>直接在 Github 端 commit 修改檔案</h3><ul><li>選要修改的檔案，按icon筆(Edit this file)</li><li>直接在檔案下方下 commit 選擇要commit 的支，通常選(commit directly to the master branch)</li></ul><h2 id="Git-問題處理集合"><a href="#Git-問題處理集合" class="headerlink" title="Git 問題處理集合"></a>Git 問題處理集合</h2><h4 id="Git-提示-fatal-remote-origin-already-exists-錯誤解決辦法"><a href="#Git-提示-fatal-remote-origin-already-exists-錯誤解決辦法" class="headerlink" title="Git 提示 fatal: remote origin already exists 錯誤解決辦法"></a>Git 提示 fatal: remote origin already exists 錯誤解決辦法</h4><p>使用 git 上傳至遠程 github 倉庫的時候出現提示錯誤：fatal: remote origin already exists.<br>1、先刪除遠端Git倉庫<br>$ git remote rm origin</p><p>2、再增加遠端 Git 倉庫<br>$ git remote add origin [<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:遠端位址]</p><p>如果執行 git remote rm origin 有出現錯誤訊息的話，可以手動修改 gitconfig 文件的內容<br>$ vi .git / config<br>把[remote “origin”] 那一行刪掉就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git/GitHub練習心得</title>
      <link href="/tsuifei.github.io/2019/07/09/git-github%E7%B7%B4%E7%BF%92%E5%BF%83%E5%BE%97/"/>
      <url>/tsuifei.github.io/2019/07/09/git-github%E7%B7%B4%E7%BF%92%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>照著程式導師實驗計畫的操作，學會如何設置本端和遠端之間的更新與開分支，合併等方法，程序有點小複雜，但對於版本控管的確是輕度多了，只是還沒和其他人合作控管，這部分須多操控。<br>.gitignore 的設置在設github前就應該處理，不然之後刪來刪去很麻煩，記得不要上傳node_modules/不然會很龐大。</p><h3 id="小筆記"><a href="#小筆記" class="headerlink" title="小筆記"></a>小筆記</h3><p>設分支練習：</p><ol><li>原本在master，創另一個分支 ：git branch [分支名] </li><li>切換到那個分支：git checkout [分支名] </li><li>用git status查在哪個分支</li><li>用git branch -v 看有哪些branch</li><li>push 到新的branch上：git push origin [branch名]</li></ol><h3 id="在github上merge合併："><a href="#在github上merge合併：" class="headerlink" title="在github上merge合併："></a>在github上merge合併：</h3><ol><li>在github上的標籤頁pull requests上點Create pull request → 會顯示兩邊的不同</li><li>再點Create pull request 之後，等Merge pull request出現，點下確認即可</li><li>Merge後切換到Master就會看到更新結果。</li><li>用git pull origin master 把已經merge好得檔案拉到本地端</li></ol><p>要改東西一定要新開branch再merge到master本支</p><blockquote><p>忘記切回test分支，所以後來無法順利merge到master分支，雖然後來看似解決，但還真不知道自己是怎麼解決的，就是試了幾個鍵，跟著打就好了．．．這樣其實有點可怕，下次再注意！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 回呼函式 Callbacks、Promises 物件、Async/Await 非同步流程控制</title>
      <link href="/tsuifei.github.io/2019/07/05/JS-%E5%9B%9E%E5%91%BC%E5%87%BD%E5%BC%8F-Callbacks%E3%80%81Promises-%E7%89%A9%E4%BB%B6%E3%80%81Async-Await-%E9%9D%9E%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/tsuifei.github.io/2019/07/05/JS-%E5%9B%9E%E5%91%BC%E5%87%BD%E5%BC%8F-Callbacks%E3%80%81Promises-%E7%89%A9%E4%BB%B6%E3%80%81Async-Await-%E9%9D%9E%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Javascript 近幾年來受歡迎的原因，有一大部分是因為 JS 可以處理非同步（異步）的問題，也因為可以非同步，所以處理速度快，且可帶給瀏覽者更好的體驗，所以了解如何控制非同步也成了前端重要的技能之一。</p><h2 id="無非同步的程式"><a href="#無非同步的程式" class="headerlink" title="無非同步的程式"></a>無非同步的程式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1, n2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1+n2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testNoAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = add(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// testNoAsync(); // 7</span></span><br></pre></td></tr></table></figure><h2 id="問題的起源，非同步程式"><a href="#問題的起源，非同步程式" class="headerlink" title="問題的起源，非同步程式"></a>問題的起源，非同步程式</h2><p>寫程式如果遇到要處理非同步的程式，就會變得複雜了起來，為什麼會複雜？<br>預設想要延遲執行，卻出現undefined 程式會一直往下跑， return的部分不會回傳會被忽略….。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedAdd0</span>(<span class="params">n1, n2, delayTime</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 設定排程，延遲一段時間後執行</span></span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> n1+n2;</span><br><span class="line">  &#125;, delayTime);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>); <span class="comment">// 仔細觀察出現的順序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = delayedAdd0(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 1, undefined, 2 (不會出現return結果)</span></span><br></pre></td></tr></table></figure><h2 id="第一個解決方式-callback-回呼函式"><a href="#第一個解決方式-callback-回呼函式" class="headerlink" title="第一個解決方式 : callback 回呼函式"></a>第一個解決方式 : callback 回呼函式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedAdd1</span>(<span class="params">n1, n2, delayTime, callback</span>)</span>&#123; <span class="comment">// callback 函式</span></span><br><span class="line">  <span class="comment">// 設定排程，延遲一段時間後執行</span></span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 延遲一段時間，計算加法，呼叫callback函式</span></span><br><span class="line">    callback(n1+n2);</span><br><span class="line">  &#125;, delayTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  delayedAdd1(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2000</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">test1(); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h2 id="第二個解決方式-Promise-物件"><a href="#第二個解決方式-Promise-物件" class="headerlink" title="第二個解決方式 : Promise 物件"></a>第二個解決方式 : Promise 物件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedAdd2</span>(<span class="params">n1, n2, delayTime</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 建立 Promise 物件 :  new promise(執行函式)</span></span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123; <span class="comment">// 兩個系統給的參數</span></span><br><span class="line">    <span class="comment">// 要做的工作放到promise的函式裡</span></span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(n1+n2); <span class="comment">// 工作完成，呼叫 resolve 函式，並把結果透過參數傳遞進去，如果工作出現問題就呼叫 reject ex. reject(n1+n2);</span></span><br><span class="line">      </span><br><span class="line">    &#125;, delayTime);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 把 promise 傳遞出來</span></span><br><span class="line">  <span class="keyword">return</span> p; <span class="comment">// 或直接以 return 去接以上的結果 回傳回去而不需要變數 p </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// resolve 會對應 .then / reject 會對應 .catch 但.catch可以忽略不寫</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise = delayedAdd2(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">  promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Error"</span>, error)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="需求-需要運行兩次的-promise-然後將結果相乘"><a href="#需求-需要運行兩次的-promise-然後將結果相乘" class="headerlink" title="需求: 需要運行兩次的 promise 然後將結果相乘"></a>需求: 需要運行兩次的 promise 然後將結果相乘</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise1 = delayedAdd2(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">let</span> promise2 = delayedAdd2(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="comment">// 多個 promise 都完成後才繼續工作.</span></span><br><span class="line">  <span class="comment">// 把 promises 放入陣列裡</span></span><br><span class="line">  <span class="built_in">Promise</span>.all([promise1, promise2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 用 reduce() 處理相乘</span></span><br><span class="line">    <span class="keyword">let</span> answer = results.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total, value</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> total * value;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(answer);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">test2a();</span><br></pre></td></tr></table></figure><h2 id="第三個解決方式-使用-Async-Await-簡化-Promise-。"><a href="#第三個解決方式-使用-Async-Await-簡化-Promise-。" class="headerlink" title="第三個解決方式 : 使用 Async/Await 簡化 Promise 。"></a>第三個解決方式 : 使用 Async/Await 簡化 Promise 。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Async/Await 背後的邏輯就是和 Promise 是一樣的。</span></span><br><span class="line"><span class="comment">// 使用 Async/Await 的大前提是仍要建立一個 Promise 物件 將它回傳</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedAdd3</span>(<span class="params">n1, n2, delayTime</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 建立 Promise 物件 : new promise(執行函式)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123; <span class="comment">// 兩個系統給的參數</span></span><br><span class="line">    <span class="comment">// 要做的工作放到promise的函式裡</span></span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    resolve(n1+n2); <span class="comment">// 工作完成，呼叫 resolve 函式，並把結果透過參數傳遞進去，如果工作出現問題就呼叫 reject</span></span><br><span class="line">    &#125;, delayTime);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 語法糖，函式前面加 async， async / await 需要一起使用</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// await 後面接函式. 上面的 resolve 會直接由 result 接收</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> delayedAdd2(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h3 id="需求-需要運行兩次的-promise-然後將結果相乘-1"><a href="#需求-需要運行兩次的-promise-然後將結果相乘-1" class="headerlink" title="需求 需要運行兩次的 promise 然後將結果相乘"></a>需求 需要運行兩次的 promise 然後將結果相乘</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test3a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// await 後面接函式. 上面的 resolve 會直接由 result 接收</span></span><br><span class="line">  <span class="keyword">let</span> result1 = <span class="keyword">await</span> delayedAdd2(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">let</span> result2 = <span class="keyword">await</span> delayedAdd2(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">let</span> answer = result1 * result2;</span><br><span class="line">  <span class="built_in">console</span>.log(answer);</span><br><span class="line">&#125;</span><br><span class="line">test3a();</span><br></pre></td></tr></table></figure><p><a href="https://www.youtube.com/watch?v=NOprCnnjHm0" target="_blank" rel="noopener">參考1 彭彭的課程</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="noopener">參考2 code</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript IIFE 立即呼叫函式</title>
      <link href="/tsuifei.github.io/2019/07/04/JS-IIFE-%E7%AB%8B%E5%8D%B3%E5%91%BC%E5%8F%AB%E5%87%BD%E5%BC%8F/"/>
      <url>/tsuifei.github.io/2019/07/04/JS-IIFE-%E7%AB%8B%E5%8D%B3%E5%91%BC%E5%8F%AB%E5%87%BD%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>IIFE 是立即被呼叫的函式的簡寫，全名為 Immediately Invoked Function Expression。在 ES6 之前，JavaScript 變數有效範圍的最小單位以 function 為分界。<br>IIFE 的好處，就是可以減少「全域變數」的產生，同時也避免了變數名稱衝突的機會。</p><h2 id="IIFE語法"><a href="#IIFE語法" class="headerlink" title="IIFE語法"></a>IIFE語法</h2><p>將一個正常的函式包在()裡，後面加個()就成了匿名函式。<br>後面的()表示立即執行，也可帶參數。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 做一些事...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IIFE函式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 做一些事....</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'foo'</span>; <span class="comment">// 注意：IIFE函式前面一定要有分號; 不然會產生錯誤</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">bar</span>) </span>&#123;</span><br><span class="line">    Console.log(bar)</span><br><span class="line">&#125;)(foo)</span><br></pre></td></tr></table></figure><p>匿名函數的參數(foo)就是 var foo 的這個變數，如果匿名函數有兩個參數， 後面的() 也可帶兩個參數</p><p>一般呼叫函式的方式可以是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doSomething(123);</span><br><span class="line">// 匿名函式</span><br><span class="line">(function doSomething (i)&#123;</span><br><span class="line">  // 做一些事...</span><br><span class="line">&#125;)(123);</span><br></pre></td></tr></table></figure><p>使用匿名函式即是馬上使用，也就是宣告他的同時也呼叫它，自然就不需要給名字了。所以就成了以下不需名字的函式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function (i)&#123;</span><br><span class="line">  // 做一些事...</span><br><span class="line">&#125;)(123);</span><br></pre></td></tr></table></figure><h3 id="經典迴圈非同步問題"><a href="#經典迴圈非同步問題" class="headerlink" title="經典迴圈非同步問題"></a>經典迴圈非同步問題</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, i * <span class="number">1000</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目的：每一秒列出一個 i<br>但結果會”同時”列印出 10 個 10，而不會一秒一秒印，因為當進入列印迴圈時，i 已經跑到 10 了。<br>解決如何因非同步而無法印出 1-10 的方法，就是使用IIFE和閉包<br>使用IIFE：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j)</span><br><span class="line">        &#125;, j * <span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在回圈內呼叫 function 會需要用 IIFE 來把參數的值保留起來，如果有看過 jQuery 的原始碼，會發現有這段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined</span>)</span>&#123;</span><br><span class="line"> <span class="comment">// ....</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><p>jQuery 也用了相同的手法將 window 和 indefined 保留起來。<br>ES6 以後新增了 let 與 const 的變數型態，且改以 { } 作為它的 Scope。換句話說，將範例中的 for 的 var 改為以 let 宣告就可以做到保留 i 在執行迴圈當下的「值」的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>參考：<a href="https://ithelp.ithome.com.tw/articles/10192739" target="_blank" rel="noopener">立即被呼叫的函式 (Immediately Invoked Function Expression, IIFE)</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Github 上安裝 Hexo 記錄</title>
      <link href="/tsuifei.github.io/2019/07/03/%E5%9C%A8-Github-%E4%B8%8A%E5%AE%89%E8%A3%9D-Hexo-%E8%A8%98%E9%8C%84/"/>
      <url>/tsuifei.github.io/2019/07/03/%E5%9C%A8-Github-%E4%B8%8A%E5%AE%89%E8%A3%9D-Hexo-%E8%A8%98%E9%8C%84/</url>
      
        <content type="html"><![CDATA[<p>在學員的鼓勵下，決定試試安裝輕量級 blog Hexo。隨然玩 Wordpress 已經很久了，但 WP 的架構越來越龐大更新速度快，整個檔案也越來越龐大了，且 WP 需要資料庫的配合。但 Hexo 不但不需要，且還可以部屬在 Github 上，超方便的！雖然設定與修改比較繁瑣，但也有它的樂趣，且既然是與程式有關的文章和內容，那何不把他們放在一起。</p><p>將 Hexo 自動生成的靜態頁面、搭配 github 的 page 功能，推上 github 後就可達到輕量 blog 的基本功能，如果想要一些功能如搜尋、留言，則要自行設定或安裝外掛，比較方便的是找個完善的主題，就不需這些繁複的設置，但最好對 Hexo 架構有一定的了解，否則一有問題仍須花很多時間查詢。</p><p>這裡使用的佈景主題是 Hexo 的預設主題：landscape，希望慢慢修改成自己喜歡的樣子即可，功能仍不是很完善，期待自己慢慢把它做的更完整一點。</p><h2 id="如何安裝"><a href="#如何安裝" class="headerlink" title="如何安裝"></a>如何安裝</h2><p>條件：node.js 環境 ＋ git<br><a href="https://hexo.io/zh-tw/docs/" target="_blank" rel="noopener">官網文件</a></p><p>先在本地端安裝好需要檔案，安裝後檔案夾內會有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><code>_config.yml</code> :<br>網站<a href="https://hexo.io/zh-tw/docs/configuration" target="_blank" rel="noopener">配置</a>檔案，可以在此配置大部分的設定。</p><p><code>package.json</code> :<br>應用程式資料。EJS, Stylus 和 Markdown renderer 已預設安裝，可以稍後移除。</p><p><code>scaffolds</code> :<br>鷹架 資料夾。當建立新文章時，Hexo 會根據 scaffold 來建立檔案。</p><p><code>source</code> :<br>原始檔案資料夾是放置內容的地方。檔案 / 資料夾名稱開頭為 _ (底線) 和隱藏檔案會被忽略，除了 _posts 資料夾以外。Markdown 和 HTML 檔案會被處理並放到 public 資料夾，而其他檔案會被拷貝過去。</p><p><code>themes</code> :<br>主題 資料夾。Hexo 會根據主題來產生靜態檔案。</p><h2 id="Hexo-指令"><a href="#Hexo-指令" class="headerlink" title="Hexo 指令"></a>Hexo 指令</h2><p><a href="https://hexo.io/zh-tw/docs/commands" target="_blank" rel="noopener">指令明細</a><br><code>$ hexo init [folder]</code><br>建立一個新的網站。如果沒有設定 folder 的話，Hexo 會在目前的資料夾建立網站。</p><h2 id="如何產生文章"><a href="#如何產生文章" class="headerlink" title="如何產生文章"></a>如何產生文章</h2><h3 id="建立文章-hexo-new-layout-lt-title-gt"><a href="#建立文章-hexo-new-layout-lt-title-gt" class="headerlink" title="建立文章 : hexo new [layout] &lt;title&gt;"></a>建立文章 : <code>hexo new [layout] &lt;title&gt;</code></h3><p><code>$ hexo new [layout] &lt;title&gt;</code><br>Hexo 的 layout 有三種：草稿 draft、頁面 page 和文章 post。也可以自定義 layout.<br>如果沒有設定 layout 的話，則會使用 <code>_config.yml</code> 中的 <code>default_layout</code> 設定代替，原始預設為 post。<br>檔案名稱可以中文，如果標題包含空格的話，請使用引號括起來。<br>建立文章後 hexo 會在 source 裡的 _posts 生成新的 .md。</p><h3 id="產生靜態文章-hexo-g"><a href="#產生靜態文章-hexo-g" class="headerlink" title="產生靜態文章 : hexo g"></a>產生靜態文章 : <code>hexo g</code></h3><p><code>$ hexo generate</code><br>產生靜態檔案。<br>|選項    | 描述 |<br>| ——– | ——– |<br>| -g, –generate    | 部署網站前先產生靜態檔案 |</p><h3 id="本地伺服器-hexo-s"><a href="#本地伺服器-hexo-s" class="headerlink" title="本地伺服器 : hexo s"></a>本地伺服器 : <code>hexo s</code></h3><p><code>$ hexo server</code><br>啟動伺服器，預設是 <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a><br>| 選項|    描述|<br>| ——– | ——– |<br>| -p, –port    | 覆蓋連接埠設定 |<br>| -s, –static    | 只使用靜態檔案 |<br>| -l, –log    | 啟動記錄器，或覆蓋記錄格式 |</p><h3 id="部署到-github-hexo-d"><a href="#部署到-github-hexo-d" class="headerlink" title="部署到 github : hexo d"></a>部署到 github : <code>hexo d</code></h3><p><code>$ hexo deploy</code><br>部署網站。<br>| 選項 | 描述 |<br>| ——– | ——– |<br>| -d, –deploy    | 產生完成即部署網站     |<br>| -w, –watch | 產生完成即部署網站 |</p><h3 id="可一起使用：hexo-g-hexo-s-hexo-d-hexo-new-文章名稱"><a href="#可一起使用：hexo-g-hexo-s-hexo-d-hexo-new-文章名稱" class="headerlink" title="可一起使用：hexo g hexo s hexo d hexo new [文章名稱]"></a>可一起使用：<code>hexo g hexo s hexo d hexo new [文章名稱]</code></h3><p><code>$ hexo render &lt;file&gt; [file2] ...</code><br>渲染檔案。</p><table><thead><tr><th>選項</th><th>描述</th></tr></thead><tbody><tr><td>-o, –output</td><td>輸出位置</td></tr></tbody></table><p><a href="https://hexo.io/zh-tw/docs/commands" target="_blank" rel="noopener">其他指令</a> ｜ <a href="https://hexo.io/zh-tw/docs/migration" target="_blank" rel="noopener">侯塞雷還可以轉移！</a></p><p>==注意==<br>如果有使用部分搜尋外掛，會使用 xml 格式搜尋，丟文章上去時先檢查是否有正確規格化為XML格式，以免出錯查不出來，所以可先去<a href="https://tool.oschina.net/codeformat/xml" target="_blank" rel="noopener">此網站檢查</a></p><h2 id="常用-Hexo-指令"><a href="#常用-Hexo-指令" class="headerlink" title="常用 Hexo 指令"></a>常用 Hexo 指令</h2><p>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br>hexo clean ：清除快取檔案 (db.json) 和已產生的靜態檔案 (public)。</p><h2 id="如何更換主題"><a href="#如何更換主題" class="headerlink" title="如何更換主題"></a>如何更換主題</h2><p>可上<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">Hexo 官網 Themes</a>直接找自己喜歡的主題，進入主題後，找到<code>install</code>這項，複製git clone的網址如，以Themes 名為 light 為例：<br><code>git clone https://github.com/hexojs/hexo-theme-light.git themes/light</code></p><p>Clon 完畢後，到根目錄的 <code>_config.yml</code> 去設定對應的 Themes 主題名稱： <code>theme: light</code></p><h2 id="如何自動備份"><a href="#如何自動備份" class="headerlink" title="如何自動備份"></a>如何自動備份</h2><p>可以在同一專案上再開一條 Git 分支，專門儲存原始檔案，或是使用 <a href="https://askiebaby.github.io/macos-command-backup-update-hexo-blog/" target="_blank" rel="noopener">Askie 推薦的一鍵備份</a>，但須另開專案。</p><h2 id="如何文章分類"><a href="#如何文章分類" class="headerlink" title="如何文章分類"></a>如何文章分類</h2><h3 id="第一種方法：手動加入"><a href="#第一種方法：手動加入" class="headerlink" title="第一種方法：手動加入"></a>第一種方法：手動加入</h3><p>使用 <code>$ hexo n &lt;name&gt;</code>新建頁面，打開此默認頁面是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: name</span><br><span class="line">date: 2019-08-05 11:15:00 </span><br><span class="line">tags: </span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>但裡面並沒有分類的資訊，可直接在 <code>tags:</code>上加 <code>categories:</code> 存檔後，重新執行 <code>hexo n &#39;name&#39;</code>，重新打開頁面裡頭就有分類了。</p><h3 id="第二種方法："><a href="#第二種方法：" class="headerlink" title="第二種方法："></a>第二種方法：</h3><p>scaffolds目錄下，是新建頁面的模板，執行新建命令時，是根據這裡的模板頁來完成的，所以可在這裡根據自己的需求增加一些默認的分類值。<br>在寫文章時，如果我們的分類是程式，那麼在也面裡的分類就會是<code>categories:程式</code>，它的訪問路徑即是：<code>*/categories/程式</code></p><p>如果想把路徑明和分類明分別設置，可打開根目錄的<code>_config.yml</code>，找到以下位置或增加以下這段做修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">程式: programming</span><br><span class="line">生活: life</span><br><span class="line">其他: other</span><br><span class="line">tag_map:</span><br></pre></td></tr></table></figure><p><code>category_map:</code>是設置分類的地方，每行一個分類，冒號前面是分類名稱，後面是訪問路徑。可以提前在這裡設置好一些分類，當編輯的文章填寫了對應的分類名時，就會自動的按照對應的路徑來訪問。</p><h3 id="設定分類標籤在頁面裡"><a href="#設定分類標籤在頁面裡" class="headerlink" title="設定分類標籤在頁面裡"></a>設定分類標籤在頁面裡</h3><p>在編輯文章的時候，tags:後面是設置標籤的地方，如果有多個標籤的話，可以用下面兩種辦法來設置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tages: </span><br><span class="line">-標籤1</span><br><span class="line">-標籤2</span><br><span class="line">...</span><br><span class="line">- 標籤n</span><br><span class="line"></span><br><span class="line">// 或是</span><br><span class="line">tages: </span><br><span class="line">-標籤1</span><br><span class="line">-標籤2</span><br><span class="line">...</span><br><span class="line">- 標籤n</span><br></pre></td></tr></table></figure><h2 id="如何設定分類-menu"><a href="#如何設定分類-menu" class="headerlink" title="如何設定分類 menu"></a>如何設定分類 menu</h2><p>在 Hexo 默認菜單只有 Home 和 Archives 兩項，如何增加新的項目到 menu 裡？<br>打開themes裡主題的配置文件：<code>_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu :</span><br><span class="line">  Home: /</span><br><span class="line">  Archives: /archives</span><br><span class="line">  About: / about</span><br></pre></td></tr></table></figure><p><code>menu :</code> 表示 Nav，在底下加上的 <code>About: /about</code> 表示顯示的 Nav 項目/路徑。Nav 項目可為中文，路徑也可設置其他url。<br>記得建立一個 nav 的項目就要執行建立 Nav 項目的指令：<br><code>hexo n page &#39;about&#39;</code> hexo 就會自動生成這個分類的分類頁，在 source 目錄裡會生成一個對應的目錄，此目錄裡的<code>index.md</code> 就是顯示這個分類列表的頁面。</p><p>參考：<a href="http://ijiaober.github.io/2014/08/05/hexo/hexo-04/" target="_blank" rel="noopener">Hexo使用攻略：（四）Hexo的分类和标签设置</a></p><h2 id="如何增加站內搜尋功能"><a href="#如何增加站內搜尋功能" class="headerlink" title="如何增加站內搜尋功能"></a>如何增加站內搜尋功能</h2><p>以<a href="https://app.swiftype.com/" target="_blank" rel="noopener">swiftype.com</a>服務來設定站內服務，<br>先至 swiftype 申請帳號，再把生成的碼丟入網頁中。<br><a href="https://juejin.im/post/5bbdc8d8e51d450e5e0cb269" target="_blank" rel="noopener">參考教學 使用 Swiftype 给 Hexo 搭建的博客添加站内搜索功能</a></p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Other </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript ES6 箭頭函式 Arrow function</title>
      <link href="/tsuifei.github.io/2019/07/02/JS-ES6-%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F-Arrow-function/"/>
      <url>/tsuifei.github.io/2019/07/02/JS-ES6-%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F-Arrow-function/</url>
      
        <content type="html"><![CDATA[<p>箭頭函式是 ES6 的新語法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原本的寫法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或是 </span></span><br><span class="line"><span class="keyword">var</span> double = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 語法</span></span><br><span class="line"><span class="keyword">const</span> double = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="箭頭函式的簡寫規則"><a href="#箭頭函式的簡寫規則" class="headerlink" title="箭頭函式的簡寫規則"></a>箭頭函式的簡寫規則</h3><p>1.如果參數只有一個，可省略參數的括號(x)=&gt; x，0或多個都不可省略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.函式本體如果只有一行，且只有 return 一個值，可省略大花括號和 return，直接把本體接在=&gt;後面 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="This-是什麼？和箭頭函式的關係"><a href="#This-是什麼？和箭頭函式的關係" class="headerlink" title="This 是什麼？和箭頭函式的關係"></a>This 是什麼？和箭頭函式的關係</h3><p>this 指的是函式的情境(context)，某人去101大樓往下跳，但跳下去沒事，因為在爬樓梯，他只有跳一格的樓梯，當然沒事，但是跳這個動作很明確，就像是函式的定義一樣。<br>但是你在什麼樣的情境下跳，會影響他的結果，這個情境就是 Context 。<br>例如：一個跳的函式，裡面內容是固定的，但裡面的this就要看他執行時的情境而定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jump</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javascript 裡函式的執行基本上可分為三種：<br>1.直接執行： 函式裡的 this 是 window (global)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jump();</span><br><span class="line"><span class="comment">// window 物件</span></span><br></pre></td></tr></table></figure><p>2.作為一個物件的方法來執行:裡面的 this 就是物件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;</span><br><span class="line">a.jump = jump;</span><br><span class="line">a.jump();</span><br><span class="line"><span class="comment">// 執行結果是物件 &#123;jump:f..&#125;</span></span><br></pre></td></tr></table></figure><p>3.假設頁面上有一個button，點它就會執行 jump()，<br>如果一個函式以 Dom 監聽函式來執行，函式裡面的this就會指向所監聽的元素 Dom。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;btn&quot;&gt;</span><br><span class="line">btn</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jump</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">btn.sddEventListener(<span class="string">'click'</span>, jump);</span><br><span class="line"><span class="comment">// button DOM</span></span><br></pre></td></tr></table></figure><h3 id="用箭頭-This-會改變"><a href="#用箭頭-This-會改變" class="headerlink" title="用箭頭 This 會改變"></a>用箭頭 This 會改變</h3><p>如果以箭頭函式攥寫 Dom 的監聽函式，This就會改變成指向 window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jump = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">btn.sddEventListener(<span class="string">'click'</span>, jump);</span><br><span class="line"><span class="comment">// window</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;</span><br><span class="line">a.jump = jump; <span class="comment">// window</span></span><br><span class="line">a.jump(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>只要是箭頭函式，無論如何執行它，裡面的 this 都會指向 window，這就是箭頭函式的特性，它沒有自己的情境(Context)，它的內部 context 就等於它宣告的時候，它外面的this。</p><p>React 會大量的用到 This 所以一定要弄懂。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code 秘技 Rename Refactoring 重新命名＋Formatting重新整理程式碼</title>
      <link href="/tsuifei.github.io/2019/07/02/VS-Code-%E7%A7%98%E6%8A%80-Rename-Refactoring-%E9%87%8D%E6%96%B0%E5%91%BD%E5%90%8D%EF%BC%8BFormatting%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E7%A8%8B%E5%BC%8F%E7%A2%BC/"/>
      <url>/tsuifei.github.io/2019/07/02/VS-Code-%E7%A7%98%E6%8A%80-Rename-Refactoring-%E9%87%8D%E6%96%B0%E5%91%BD%E5%90%8D%EF%BC%8BFormatting%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E7%A8%8B%E5%BC%8F%E7%A2%BC/</url>
      
        <content type="html"><![CDATA[<p>在 VS Code 隱藏了一些相當好用的功能，在每次重啟 VS Code 時，就會有一些基本的講解，沒仔細看還真的很容易忽略。<br>這個功能主要在幫助增快原始的重構，可從以下位置找到這個說明功能。</p><ul><li>help -&gt; Interactive Playground -&gt; </li></ul><h2 id="重構工具"><a href="#重構工具" class="headerlink" title="重構工具"></a>重構工具</h2><h3 id="Rename-Refactoring-重新命名"><a href="#Rename-Refactoring-重新命名" class="headerlink" title="Rename Refactoring (重新命名)"></a>Rename Refactoring (重新命名)</h3><p>選中要修改的某一個名稱，按 fn+F2 即可重新輸入新的命名， enter 之後會發現所有用此函式名的地方，都會換成新名字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reference the function</span></span><br><span class="line"><span class="keyword">new</span> Book(<span class="string">"War of the Worlds"</span>, <span class="string">"H G Wells"</span>);</span><br><span class="line"><span class="keyword">new</span> Book(<span class="string">"The Martian"</span>, <span class="string">"Andy Weir"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a book.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Book</span>(<span class="params">title, author</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Refactoring-via-Extraction-透過提取重構函式"><a href="#Refactoring-via-Extraction-透過提取重構函式" class="headerlink" title="Refactoring via Extraction (透過提取重構函式)"></a>Refactoring via Extraction (透過提取重構函式)</h3><p>可將程式中某一部分提去出來自成一函式。<br>選取要提取出來成函式的部份，按 command + . 會出現選單：<br>1.Extract to inner function in function ‘findFirstEvenNumber’(提取函式中的內部函數尋找找’findFirstEvenNumber’函式)<br>2.Extract to function in global scope(提取全局範圍內的功能)<br>3.Extract to constant in enclosing scope(在封閉範圍內提取常量)</p><p>例如選2.會將選取提取出的碼轉成一函式，並需賦予函式名稱，即可成函式，輸入新函式名之後會自動替換，原題取出來的函式位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstEvenNumber</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> el === <span class="string">'number'</span> &amp;&amp; el % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> el;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Formatting-重新整理程式碼"><a href="#Formatting-重新整理程式碼" class="headerlink" title="Formatting (重新整理程式碼)"></a>Formatting (重新整理程式碼)</h3><p>shift + option + F 可重新整理程式碼的排列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = [<span class="string">"🚗"</span>, <span class="string">"🚙"</span>, <span class="string">"🚕"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> car <span class="keyword">of</span> cars)&#123;</span><br><span class="line">    <span class="comment">// Drive the car</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`This is the car <span class="subst">$&#123;car&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或是開啟 sstting 預設: editor.formatOnSave = true，即可啟動存檔就會自動編排的功能。</p>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
